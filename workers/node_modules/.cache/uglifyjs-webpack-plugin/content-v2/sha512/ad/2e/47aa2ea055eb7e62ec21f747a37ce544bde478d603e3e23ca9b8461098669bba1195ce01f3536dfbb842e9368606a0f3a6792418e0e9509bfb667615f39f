{"code":"!function(t){var e={};function n(i){if(e[i])return e[i].exports;var a=e[i]={i:i,l:!1,exports:{}};return t[i].call(a.exports,a,a.exports,n),a.l=!0,a.exports}n.m=t,n.c=e,n.d=function(t,e,i){n.o(t,e)||Object.defineProperty(t,e,{configurable:!1,enumerable:!0,get:i})},n.r=function(t){Object.defineProperty(t,\"__esModule\",{value:!0})},n.n=function(t){var e=t&&t.__esModule?function(){return t.default}:function(){return t};return n.d(e,\"a\",e),e},n.o=function(t,e){return Object.prototype.hasOwnProperty.call(t,e)},n.p=\"\",n(n.s=1)}([function(t,e){!function(t){var e={};function n(i){if(e[i])return e[i].exports;var a=e[i]={i:i,l:!1,exports:{}};return t[i].call(a.exports,a,a.exports,n),a.l=!0,a.exports}n.m=t,n.c=e,n.d=function(t,e,i){n.o(t,e)||Object.defineProperty(t,e,{configurable:!1,enumerable:!0,get:i})},n.r=function(t){Object.defineProperty(t,\"__esModule\",{value:!0})},n.n=function(t){var e=t&&t.__esModule?function(){return t.default}:function(){return t};return n.d(e,\"a\",e),e},n.o=function(t,e){return Object.prototype.hasOwnProperty.call(t,e)},n.p=\"\",n(n.s=0)}([function(t,e,n){\"use strict\";n.r(e);const i=\"#version 300 es\\nin vec2 position;\\nin vec2 texture;\\nout vec2 kernelPosition;\\n\\nvoid main(void) {\\n  kernelPosition = texture;\\n  gl_Position = vec4(position.xy, 0.0, 1.0);\\n}\\n\";class a{constructor(t,e=0,n=0,i=0){this.world=t,this.setPose(e,n,i)}static getFrontAxlePosition(t,e){return THREE.Vector2.fromAngle(e).multiplyScalar(a.WHEEL_BASE).add(t)}static getFakeAxlePosition(t,e){return a.frontToRearAxlePosition(t,e)}static centerToRearAxlePosition(t,e){return THREE.Vector2.fromAngle(e).multiplyScalar(a.REAR_AXLE_POS).add(t)}static frontToRearAxlePosition(t,e){return THREE.Vector2.fromAngle(e).multiplyScalar(-a.WHEEL_BASE).add(t)}get pose(){const t=this.rearAxlePosition;return{pos:new THREE.Vector2(t[0],t[1]),rot:this.rotation}}get position(){const t=this.body.GetPosition();return[t.get_x(),t.get_y()]}get rearAxlePosition(){const[t,e]=this.position,n=this.rotation;return[t+Math.cos(n)*a.REAR_AXLE_POS,e+Math.sin(n)*a.REAR_AXLE_POS]}get frontAxlePosition(){const[t,e]=this.position,n=this.rotation;return[t+Math.cos(n)*a.FRONT_AXLE_POS,e+Math.sin(n)*a.FRONT_AXLE_POS]}get rotation(){return this.body.GetAngle()}get speed(){return this.body.GetLinearVelocity().Length()}get wheelAngle(){return Math.wrapAngle(this.leftFrontWheel.joint.GetJointAngle())}setPose(t,e,n){this.destroyBodies(),t-=a.REAR_AXLE_POS*Math.cos(n),e-=a.REAR_AXLE_POS*Math.sin(n);const i=new Box2D.b2Vec2(t,e),o=new Box2D.b2BodyDef;o.set_type(Box2D.b2_dynamicBody),o.set_position(i),o.set_angle(n),this.body=this.world.CreateBody(o),this.body.SetAngularDamping(a.ANGULAR_DAMPING);const l=new Box2D.b2PolygonShape;l.SetAsBox(a.HALF_CAR_LENGTH,a.HALF_CAR_WIDTH);const c=new Box2D.b2FixtureDef;c.set_shape(l),c.set_density(a.CHASSIS_DENSITY),c.set_friction(a.FRICTION),c.set_restitution(a.RESTITUTION),this.body.CreateFixture(c);const p=new Box2D.b2Vec2(a.FRONT_AXLE_POS,a.WHEEL_LATERAL_POS),u=new Box2D.b2Vec2(a.FRONT_AXLE_POS,-a.WHEEL_LATERAL_POS),h=new Box2D.b2Vec2(a.REAR_AXLE_POS,a.WHEEL_LATERAL_POS),d=new Box2D.b2Vec2(a.REAR_AXLE_POS,-a.WHEEL_LATERAL_POS);this.leftFrontWheel=r.call(this,p,i,n),this.rightFrontWheel=r.call(this,u,i,n),this.leftRearWheel=s.call(this,h,i,n),this.rightRearWheel=s.call(this,d,i,n),Box2D.destroy(i),Box2D.destroy(o),Box2D.destroy(l),Box2D.destroy(c),Box2D.destroy(p),Box2D.destroy(u),Box2D.destroy(h),Box2D.destroy(d)}destroyBodies(){this.body&&(this.world.DestroyBody(this.body),this.body=null,this.world.DestroyBody(this.leftFrontWheel.body),this.leftFrontWheel=null,this.world.DestroyBody(this.rightFrontWheel.body),this.rightFrontWheel=null,this.world.DestroyBody(this.leftRearWheel.body),this.leftRearWheel=null,this.world.DestroyBody(this.rightRearWheel.body),this.rightRearWheel=null)}update(t,e){const n=Math.clamp(t.gas,-1,1),i=Math.clamp(t.brake,0,1),o=Math.clamp(t.steer,-1,1),s=this.body.GetMass(),r=this.body.GetLinearVelocity(),l=this.body.GetAngle();let c=r.LengthSquared(),p=r.Length();const u=.5*a.DRAG_COEFF*a.FRONTAL_AREA*a.DENSITY_OF_AIR*p;let h=new Box2D.b2Vec2(0,0),d=new Box2D.b2Vec2(0,0);if(i>0)if(p>.1)d.op_add(r),d.op_mul(a.MAX_BRAKE_DECEL*s*i),d.op_mul(1/p);else{const t=new Box2D.b2Vec2(0,0);this.body.SetLinearVelocity(t),r.Set(0,0),c=0,p=0,Box2D.destroy(t)}else{const t=a.MAX_GAS_ACCEL*s*n;Box2D.destroy(h),h=new Box2D.b2Vec2(t*Math.cos(l),t*Math.sin(l))}const f=new Box2D.b2Vec2(0,0);f.op_sub(r),f.op_mul(u+a.ROLL_RESIST),f.op_add(h),f.op_sub(d),this.body.ApplyForceToCenter(f);const m=Math.clamp(Math.atan(a.MAX_LATERAL_ACCEL*a.WHEEL_BASE/this.body.GetLinearVelocity().LengthSquared()),.07,a.MAX_WHEEL_ANGLE);let y;this.leftFrontWheel.joint.SetLimits(-m,m),this.rightFrontWheel.joint.SetLimits(-m,m);const g=this.leftFrontWheel.joint.GetJointAngle();y=0!=o?o*a.MAX_STEER_SPEED:Math.clamp(-g/a.MAX_WHEEL_ANGLE*c*e,-a.MAX_STEER_SPEED,a.MAX_STEER_SPEED),this.leftFrontWheel.joint.SetMotorSpeed(y),this.rightFrontWheel.joint.SetMotorSpeed(y),[\"leftFrontWheel\",\"rightFrontWheel\",\"leftRearWheel\",\"rightRearWheel\"].forEach(t=>{const n=this[t].body,i=n.GetLinearVelocity(),o=n.GetLocalVector(i),s=new Box2D.b2Vec2(0,-a.LATERAL_DAMPING*o.get_y()),r=new Box2D.b2Vec2(0,0);r.op_add(n.GetWorldVector(s)),r.op_mul(e),r.op_add(i),n.SetLinearVelocity(r),Box2D.destroy(s),Box2D.destroy(r)}),Box2D.destroy(h),Box2D.destroy(d),Box2D.destroy(f)}}function o(t,e,n){const i=Math.cos(n),o=Math.sin(n),s=new Box2D.b2Vec2(i*t.get_x()-o*t.get_y()+e.get_x(),o*t.get_x()+i*t.get_y()+e.get_y()),r=new Box2D.b2BodyDef;r.set_type(Box2D.b2_dynamicBody),r.set_position(s),r.set_angle(n);const l=this.world.CreateBody(r),c=new Box2D.b2PolygonShape;c.SetAsBox(a.HALF_WHEEL_LENGTH,a.HALF_WHEEL_WIDTH);const p=new Box2D.b2FixtureDef;return p.set_shape(c),p.set_density(a.WHEEL_DENSITY),p.set_friction(a.FRICTION),p.set_restitution(a.RESTITUTION),l.CreateFixture(p),Box2D.destroy(s),Box2D.destroy(r),Box2D.destroy(c),Box2D.destroy(p),l}function s(t,e,n){const i=o.call(this,t,e,n),a=new Box2D.b2Vec2(0,0),s=new Box2D.b2WeldJointDef;s.set_bodyA(this.body),s.set_bodyB(i),s.set_localAnchorA(t),s.set_localAnchorB(a);const r=Box2D.castObject(this.world.CreateJoint(s),Box2D.b2WeldJoint);return Box2D.destroy(a),Box2D.destroy(s),{body:i,joint:r}}function r(t,e,n){const i=o.call(this,t,e,n),s=new Box2D.b2Vec2(0,0),r=new Box2D.b2RevoluteJointDef;r.set_bodyA(this.body),r.set_bodyB(i),r.set_localAnchorA(t),r.set_localAnchorB(s),r.set_enableMotor(!0),r.set_motorSpeed(0),r.set_maxMotorTorque(a.MAX_WHEEL_MOTOR_TORQUE),r.set_enableLimit(!0),r.set_lowerAngle(-a.MAX_WHEEL_ANGLE),r.set_upperAngle(a.MAX_WHEEL_ANGLE);const l=Box2D.castObject(this.world.CreateJoint(r),Box2D.b2RevoluteJoint);return Box2D.destroy(s),Box2D.destroy(r),{body:i,joint:l}}a.HALF_CAR_LENGTH=2.5,a.HALF_CAR_WIDTH=1,a.CHASSIS_DENSITY=1600/9.2,a.HALF_WHEEL_LENGTH=.33,a.HALF_WHEEL_WIDTH=.12,a.WHEEL_DENSITY=250,a.MAX_WHEEL_MOTOR_TORQUE=1e3,a.MAX_WHEEL_ANGLE=32/180*Math.PI,a.ANGULAR_DAMPING=.3,a.FRICTION=.9,a.RESTITUTION=.1,a.DRAG_COEFF=.7,a.DENSITY_OF_AIR=1.8580608,a.FRONTAL_AREA=1.85,a.ROLL_RESIST=30,a.MAX_STEER_SPEED=1.2,a.MAX_GAS_ACCEL=3.5,a.MAX_BRAKE_DECEL=6.5,a.LATERAL_DAMPING=1e3,a.WHEEL_LATERAL_POS=.843,a.FRONT_AXLE_POS=1.56,a.REAR_AXLE_POS=-1.37,a.WHEEL_BASE=a.FRONT_AXLE_POS-a.REAR_AXLE_POS,a.MAX_LATERAL_ACCEL=9.81;const l=8,c=16,p=32,u=.01,h=new THREE.Matrix3,d=new THREE.Matrix3;class f{constructor(t,e,n=null){this.start=Object.assign({},t),this.end=Object.assign({},e),t.pos&&(this.start.x=t.pos.x,this.start.y=t.pos.y),e.pos&&(this.end.x=e.pos.x,this.end.y=e.pos.y);const i=this.end.x-this.start.x,a=this.end.y-this.start.y,o=Math.sin(this.start.rot),s=Math.cos(this.start.rot);this.goal={x:s*i+o*a,y:-o*i+s*a,rot:Math.wrapAngle(this.end.rot-this.start.rot),curv:this.end.curv},n?this.params=Object.assign({},n,{p0:this.start.curv,p3:this.end.curv}):this.guessInitialParams(),this.converged=!1}guessInitialParams(){const t=this.goal,e=this.start.curv/p,n=t.y/p,i=t.rot/p,a=t.curv/p;this.goal={x:t.x,y:0,rot:0,curv:0},this.params={p0:0,p1:0,p2:0,p3:0,sG:t.x};for(let t=0;t<p;t++)this.params.p0+=e,this.params.p3+=a,this.goal.y+=n,this.goal.rot+=i,this.goal.curv+=a,this.iterate();this.goal=t}optimize(){for(let t=0;t<c;t++)if(this.iterate())return this.converged=!0,!0;return this.converged=!1,!1}iterate(){const{p0:t,p1:e,p2:n,p3:i,sG:a}=this.params,o=a/l,s=a*a,r=s*a;let c,p,f,m,y,g,v=0,x=0,_=0,S=0,T=0,E=0,A=0,P=0;for(let u=0,h=0;u<=l;u++,h+=o){const o=0==u||u==l?1:u%2==0?2:4;c=(((-4.5*(t-3*e+3*n-i)/r*h/4+(9*t-22.5*e+18*n-4.5*i)/s/3)*h+(-5.5*t+9*e-4.5*n+i)/a/2)*h+t)*h,p=Math.cos(c);const d=h/a;v-=o*(f=Math.sin(c))*(m=((3.375*d-7.5)*d+4.5)*d*h),x-=o*f*(y=((-3.375*d+6)*d-2.25)*d*h),_-=o*f*(g=((3.375*(t-3*e+3*n-i)*d-3*(2*t-5*e+4*n-i))*d+.25*(11*t-18*e+9*n-2*i))*d*d),S+=o*p*m,T+=o*p*y,E+=o*p*g,A+=o*p,P+=o*f}const R=a/l/3,L=this.goal.x-A*R,b=this.goal.y-P*R,G=Math.wrapAngle(this.goal.rot-c);if(Math.abs(L)+Math.abs(b)+Math.abs(G)<u)return!0;h.set(v*R,x*R,p+_*R,S*R,T*R,f+E*R,m,y,g);const[C,I,O,w,D,V,N,F,M]=d.getInverse(h).elements;return this.params.p1+=C*L+w*b+N*G,this.params.p2+=I*L+D*b+F*G,this.params.sG+=O*L+V*b+M*G,!1}buildPath(t){const{p0:e,p1:n,p2:i,p3:a,sG:o}=this.params,s=o*o,r=e,l=(-5.5*e+9*n-4.5*i+a)/o,c=(9*e-22.5*n+18*i-4.5*a)/s,p=-4.5*(e-3*n+3*i-a)/(s*o),u=[{pos:new THREE.Vector2(this.start.x,this.start.y),rot:this.start.rot,curv:this.start.curv}],h=o/(t-1);let d=h,f=0,m=0,y=Math.cos(u[0].rot),g=Math.sin(u[0].rot);for(let e=1;e<t-1;e++){const t=(((p*d/4+c/3)*d+l/2)*d+r)*d+this.start.rot,n=((p*d+c)*d+l)*d+r,i=Math.cos(t),a=Math.sin(t);f=f*(e-1)/e+(i+y)/(2*e),m=m*(e-1)/e+(a+g)/(2*e),u.push({pos:new THREE.Vector2(d*f+this.start.x,d*m+this.start.y),rot:t,curv:n}),d+=h,y=i,g=a}return u.push({pos:new THREE.Vector2(this.end.x,this.end.y),rot:this.end.rot,curv:this.end.curv}),u}}class m{constructor(t,e,n){this.start=Object.assign({},t),this.end=Object.assign({},e),t.pos&&(this.start.x=t.pos.x,this.start.y=t.pos.y),e.pos&&(this.end.x=e.pos.x,this.end.y=e.pos.y);const i=this.end.x-this.start.x,a=this.end.y-this.start.y,o=Math.sin(this.start.rot),s=Math.cos(this.start.rot);this.goal={x:s*i+o*a,y:-o*i+s*a,rot:Math.wrapAngle(this.end.rot-this.start.rot),curv:this.end.curv},this.params=Object.assign({},n,{p0:this.start.curv,p1:this.start.dCurv||0,p2:this.start.ddCurv||0,p5:this.end.curv})}buildPath(t){const{p0:e,p1:n,p2:i,p3:a,p4:o,p5:s,sG:r}=this.params,l=r*r,c=l*r,p=e,u=n,h=i/2,d=(-71.875*e+81*a-10.125*o+s-21.25*n*r-2.75*i*l)/c,f=(166.5*e-202.5*a+40.5*o-4.5*s+45*n*r+4.5*i*l)/(l*l),m=(-95.625*e+121.5*a-30.375*o+4.5*s-24.75*n*r-2.25*i*l)/(l*c),y=[{pos:new THREE.Vector2(this.start.x,this.start.y),rot:this.start.rot,curv:this.start.curv}],g=r/(t-1);let v=g,x=0,_=0,S=Math.cos(y[0].rot),T=Math.sin(y[0].rot);for(let e=1;e<t-1;e++){const t=(((((m*v/6+f/5)*v+d/4)*v+h/3)*v+u/2)*v+p)*v+this.start.rot,n=((((m*v+f)*v+d)*v+h)*v+u)*v+p,i=Math.cos(t),a=Math.sin(t);x=x*(e-1)/e+(i+S)/(2*e),_=_*(e-1)/e+(a+T)/(2*e),y.push({pos:new THREE.Vector2(v*x+this.start.x,v*_+this.start.y),rot:t,curv:n}),v+=g,S=i,T=a}return y.push({pos:new THREE.Vector2(this.end.x,this.end.y),rot:this.end.rot,curv:this.end.curv}),y}}let y,g;var v={setUp:()=>({kernel:\"\\n  vec4 kernel() {\\n    return vec4(1, 0, 0, 1);\\n  }\\n\",vertexShader:\"#version 300 es\\nuniform mat3 xform;\\nin vec2 position;\\n\\nvoid main(void) {\\n  gl_Position = vec4((xform * vec3(position, 1)).xy, 0, 1);\\n}\\n\",output:{name:\"xyObstacleGrid\"},draw:(t,e)=>{t.clearColor(0,0,0,0),t.clear(t.COLOR_BUFFER_BIT),t.bindBuffer(t.ARRAY_BUFFER,t.createBuffer()),t.bufferData(t.ARRAY_BUFFER,y,t.STATIC_DRAW),t.enableVertexAttribArray(e.positionLocation),t.vertexAttribPointer(e.positionLocation,2,t.FLOAT,!1,0,0);const n=t.getUniformLocation(e.glProgram,\"xform\");t.uniformMatrix3fv(n,!1,g.elements),t.drawArrays(t.TRIANGLES,0,y.length/2)}}),update(t,e,n,i,a,o){y=new Float32Array(Array.prototype.concat.apply([],o.map(t=>t.vertices)));const s=new THREE.Matrix3;s.set(1,0,-i.x,0,1,-i.y,0,0,1);const r=new THREE.Matrix3;return r.set(2/(e*t.xyGridCellSize),0,0,0,2/(n*t.xyGridCellSize),0,0,0,1),g=r.multiply(s).multiply(a),{width:e,height:n}}},x=()=>({kernel:\"\\n\\nvec4 kernel() {\\n  float centerlineWidth = float(textureSize(centerline, 0).x);\\n\\n  vec2 sl = (kernelPosition - 0.5) * vec2(kernelSize) * vec2(slGridCellSize) + slCenterPoint;\\n  float centerlineCoord = sl.x / stationInterval / centerlineWidth * (centerlineWidth - 1.0) / centerlineWidth + (0.5 / centerlineWidth);\\n  if (centerlineCoord < 0.0 || centerlineCoord > 1.0) return vec4(0);\\n\\n  vec3 centerlineSample = texture(centerline, vec2(centerlineCoord, 0)).xyz;\\n  float perpindicular = centerlineSample.z + radians(90.0);\\n  vec2 xy = centerlineSample.xy + sl.yy * vec2(cos(perpindicular), sin(perpindicular));\\n\\n  vec2 xyTexCoords = (xy - xyCenterPoint) / vec2(textureSize(xyObstacleGrid, 0)) / vec2(xyGridCellSize) + 0.5;\\n  return texture(xyObstacleGrid, xyTexCoords);\\n}\\n\\n\",output:{name:\"slObstacleGrid\"},uniforms:{xyObstacleGrid:{type:\"outputTexture\"},slGridCellSize:{type:\"float\"},xyGridCellSize:{type:\"float\"},slCenterPoint:{type:\"vec2\"},xyCenterPoint:{type:\"vec2\"},stationInterval:{type:\"float\"},centerline:{type:\"sharedTexture\"}}}),_=(t,e,n,i,a)=>({width:e,height:n,uniforms:{slGridCellSize:t.slGridCellSize,xyGridCellSize:t.xyGridCellSize,slCenterPoint:[i.x,i.y],xyCenterPoint:[a.x,a.y],stationInterval:t.stationInterval}});const S=\"\\n\\n// TODO: test performance of returning early if non-zero pixel found\\nvec4 kernel() {\\n  float val = 0.0;\\n\\n  for (int d = 0; d <= lethalDilation; d++) {\\n    val = max(val, texture(slObstacleGrid, kernelPosition + delta * vec2(d)).r);\\n    val = max(val, texture(slObstacleGrid, kernelPosition + delta * vec2(-d)).r);\\n  }\\n\\n  for (int d = lethalDilation + 1; d <= lethalDilation + hazardDilation; d++) {\\n    val = max(val, texture(slObstacleGrid, kernelPosition + delta * vec2(d)).r * 0.5);\\n    val = max(val, texture(slObstacleGrid, kernelPosition + delta * vec2(-d)).r * 0.5);\\n  }\\n\\n  val = max(val, step(0.1, val) * 0.5);\\n\\n  return vec4(val, 0, 0, 1);\\n}\\n\\n\";var T=()=>[{kernel:S,output:{name:\"slObstacleGridStationDilated\"},uniforms:{slObstacleGrid:{type:\"outputTexture\"},delta:{type:\"vec2\"},lethalDilation:{type:\"int\"},hazardDilation:{type:\"int\"}}},{kernel:S,output:{name:\"slObstacleGridDilated\"},uniforms:{slObstacleGrid:{type:\"outputTexture\",name:\"slObstacleGridStationDilated\"},delta:{type:\"vec2\"},lethalDilation:{type:\"int\"},hazardDilation:{type:\"int\"}}}],E=(t,e,n)=>[{width:e,height:n,uniforms:{delta:[1/e,0],lethalDilation:Math.ceil(t.lethalDilationS/t.slGridCellSize),hazardDilation:Math.ceil(t.hazardDilationS/t.slGridCellSize)}},{width:e,height:n,uniforms:{delta:[0,1/n],lethalDilation:Math.ceil(t.lethalDilationL/t.slGridCellSize),hazardDilation:Math.ceil(t.hazardDilationL/t.slGridCellSize)}}],A=()=>({kernel:\"\\n\\nvec4 kernel() {\\n  vec2 xy = (kernelPosition - 0.5) * vec2(kernelSize) * vec2(xyGridCellSize) + xyCenterPoint;\\n\\n  int numSamples = textureSize(centerline, 0).x;\\n  int closest = 0;\\n  float closestDist = distance(xy, texelFetch(centerline, ivec2(0, 0), 0).xy);\\n  for (int i = 1; i < numSamples; i++) {\\n    float dist = distance(xy, texelFetch(centerline, ivec2(i, 0), 0).xy);\\n    if (dist < closestDist) {\\n      closestDist = dist;\\n      closest = i;\\n    }\\n  }\\n\\n  vec2 closestPos = texelFetch(centerline, ivec2(closest, 0), 0).xy;\\n  vec2 prev, next;\\n  int prevIndex, nextIndex;\\n\\n  if (closest == 0) {\\n    prevIndex = 0;\\n    nextIndex = 1;\\n    prev = closestPos;\\n    next = texelFetch(centerline, ivec2(1, 0), 0).xy;\\n  } else if (closest == numSamples - 1) {\\n    prevIndex = closest - 1;\\n    nextIndex = closest;\\n    prev = texelFetch(centerline, ivec2(prevIndex, 0), 0).xy;\\n    next = closestPos;\\n  } else {\\n    vec2 before = texelFetch(centerline, ivec2(closest - 1, 0), 0).xy;\\n    vec2 after = texelFetch(centerline, ivec2(closest + 1, 0), 0).xy;\\n\\n    if (distance(before, xy) < distance(after, xy)) {\\n      prevIndex = closest - 1;\\n      nextIndex = closest;\\n      prev = before;\\n      next = closestPos;\\n    } else {\\n      prevIndex = closest;\\n      nextIndex = closest + 1;\\n      prev = closestPos;\\n      next = after;\\n    }\\n  }\\n\\n  float dist = distance(prev, next);\\n  float progress = clamp(dot(xy - prev, next - prev) / dist / dist, 0.0, 1.0);\\n  vec2 projectedPos = (next - prev) * vec2(progress) + prev;\\n\\n  return vec4(\\n    (float(prevIndex) + progress) * stationInterval,\\n    sign(determinant(mat2(next - prev, xy - prev))) * distance(xy, projectedPos),\\n    0,\\n    0\\n  );\\n}\\n\\n\",output:{name:\"xyslMap\",filter:\"linear\"},uniforms:{centerline:{type:\"sharedTexture\"},xyCenterPoint:{type:\"vec2\"},xyGridCellSize:{type:\"float\"},stationInterval:{type:\"float\"}}}),P=(t,e,n,i,a)=>({width:e,height:n,uniforms:{xyCenterPoint:[i.x,i.y],xyGridCellSize:t.xyGridCellSize,stationInterval:t.stationInterval}}),R=()=>[{kernel:\"\\n\\nconst int NEWTON_ITERATIONS = 16;\\nconst int RELAXATION_ITERATIONS = 16;\\nconst float CONVERGENCE_ERROR = 0.01;\\n\\n// These two consts must stay in sync.\\nconst int SIMPSONS_INTERVALS = 8;\\n//const float SIMPSONS_COEFFS[SIMPSONS_INTERVALS + 1] = float[](1.0, 4.0, 2.0, 4.0, 2.0, 4.0, 2.0, 4.0, 2.0, 4.0, 2.0, 4.0, 2.0, 4.0, 2.0, 4.0, 1.0);\\nconst float SIMPSONS_COEFFS[SIMPSONS_INTERVALS + 1] = float[](1.0, 4.0, 2.0, 4.0, 2.0, 4.0, 2.0, 4.0, 1.0);\\n\\nconst float PI = 3.1415926535897932384626433832795;\\nconst float TWO_PI = PI + PI;\\n\\nconst float RELAXATION_ITERATIONS_F = float(RELAXATION_ITERATIONS);\\nconst float SIMPSONS_INTERVALS_F = float(SIMPSONS_INTERVALS);\\n\\nfloat wrapAngle(float angle) {\\n  angle = mod(angle, TWO_PI);\\n  if (angle <= -PI) return angle + TWO_PI;\\n  else if (angle > PI) return angle - TWO_PI;\\n  return angle;\\n}\\n\\nvec4 iterate(vec4 goal, float p0, float p1, float p2, float p3, float sG) {\\n  float ds = sG / SIMPSONS_INTERVALS_F;\\n  float sG_2 = sG * sG;\\n  float sG_3 = sG_2 * sG;\\n\\n  vec3 dX_p = vec3(0.0);\\n  vec3 dY_p = vec3(0.0);\\n  vec2 guess = vec2(0.0);\\n  float s = 0.0;\\n\\n  float theta, cosTheta, sinTheta;\\n  vec3 dT_p;\\n\\n  for (int i = 0; i <= SIMPSONS_INTERVALS; i++) {\\n    float coeff = SIMPSONS_COEFFS[i];\\n\\n    float a = p0;\\n    float b = (-5.5 * p0 + 9.0 * p1 - 4.5 * p2 + p3) / sG;\\n    float c = (9.0 * p0 - 22.5 * p1 + 18.0 * p2 - 4.5 * p3) / sG_2;\\n    float d = (-4.5 * (p0 - 3.0 * p1 + 3.0 * p2 - p3)) / sG_3;\\n\\n    theta = (((d * s / 4.0 + c / 3.0) * s + b / 2.0) * s + a) * s;\\n    cosTheta = cos(theta);\\n    sinTheta = sin(theta);\\n\\n    float s_sG = s / sG;\\n\\n    dT_p = vec3(\\n      // p1\\n      ((3.375 * s_sG - 7.5) * s_sG + 4.5) * s_sG * s,\\n\\n      // p2\\n      ((-3.375 * s_sG + 6.0) * s_sG - 2.25) * s_sG * s,\\n\\n      // sG\\n      ((3.375 * (p0 - 3.0 * p1 + 3.0 * p2 - p3) * s_sG - 3.0 * (2.0 * p0 - 5.0 * p1 + 4.0 * p2 - p3)) * s_sG + 0.25 * (11.0 * p0 - 18.0 * p1 + 9.0 * p2 - 2.0 * p3)) * s_sG * s_sG\\n    );\\n\\n    dX_p -= coeff * sinTheta * dT_p;\\n    dY_p += coeff * cosTheta * dT_p;\\n\\n    guess += coeff * vec2(cosTheta, sinTheta);\\n\\n    s += ds;\\n  }\\n\\n  float hOver3 = sG / SIMPSONS_INTERVALS_F / 3.0;\\n\\n  vec3 delta;\\n  delta.xy = goal.xy - guess * hOver3;\\n  delta.z = wrapAngle(goal.z - theta);\\n\\n  if (abs(delta.x) + abs(delta.y) + abs(delta.z) < CONVERGENCE_ERROR)\\n    return vec4(p1, p2, sG, 1.0);\\n\\n  dX_p.xyz *= hOver3;\\n  dY_p.xyz *= hOver3;\\n  dX_p.z += cosTheta;\\n  dY_p.z += sinTheta;\\n\\n  mat3 invJacobian = inverse(transpose(mat3(dX_p, dY_p, dT_p)));\\n\\n  vec3 deltaP = invJacobian * delta;\\n  vec4 params = vec4(p1, p2, sG, 0.0);\\n  params.xyz += deltaP;\\n\\n  return params;\\n}\\n\\n/* Input:\\n *   start: (vec4)\\n *     x: x position,\\n *     y: y position,\\n *     z: theta rotation,\\n *     w: k curvature\\n *   end: (vec4)\\n *     x: x position,\\n *     y: y position,\\n *     z: theta rotation,\\n *     w: k curvature\\n *\\n * Output: (vec4)\\n *   x: p1,\\n *   y: p2,\\n *   z: sG,\\n *   w: 1 if converged, 0 if not\\n */\\n\\nvec4 optimize(vec4 start, vec4 end) {\\n  // Translate and rotate start and end so that start is at the origin\\n  float sinRot = sin(start.z);\\n  float cosRot = cos(start.z);\\n\\n  vec4 diff = end - start;\\n  vec4 goal;\\n  goal.xy = mat2(cosRot, -sinRot, sinRot, cosRot) * diff.xy;\\n  goal.z = wrapAngle(diff.z);\\n  goal.w = end.w;\\n\\n  vec4 originalGoal = goal;\\n  vec4 dGoal;\\n  dGoal.x = 0.0;\\n  dGoal.yzw = goal.yzw / RELAXATION_ITERATIONS_F;\\n  float dK0 = start.w / RELAXATION_ITERATIONS_F;\\n\\n  // Relax the goal to (x, 0, 0, 0)\\n  goal.yzw = vec3(0, 0, 0);\\n\\n  // Relax the params to (0, 0, 0, 0, goal.x)\\n  float p0 = 0.0;\\n  float p1 = 0.0;\\n  float p2 = 0.0;\\n  float p3 = 0.0;\\n  float sG = goal.x;\\n\\n  for (int i = 0; i < RELAXATION_ITERATIONS; i++) {\\n    p0 += dK0;\\n    p3 += dGoal.w;\\n    goal += dGoal;\\n    \\n    vec4 result = iterate(goal, p0, p1, p2, p3, sG);\\n    p1 = result.x;\\n    p2 = result.y;\\n    sG = result.z;\\n  }\\n\\n  goal = originalGoal;\\n\\n  for (int i = 0; i < NEWTON_ITERATIONS; i++) {\\n    vec4 result = iterate(goal, p0, p1, p2, p3, sG);\\n    if (result.w == 1.0) return result;\\n\\n    p1 = result.x;\\n    p2 = result.y;\\n    sG = result.z;\\n  }\\n\\n  return vec4(p1, p2, sG, 0.0);\\n}\\n\\n\\n\\n// width: station * latitude index\\n// height: station_conn * lattice_conn\\n//\\n// lattice:\\n// width: latitudes\\n// height: stations\\n\\nvec4 kernel() {\\n  ivec2 indexes = ivec2(kernelPosition * vec2(kernelSize));\\n\\n  int endStation = indexes.x / numLatitudes;\\n  int endLatitude = int(mod(float(indexes.x), float(numLatitudes)));\\n\\n  int startStation = endStation - stationConnectivity + indexes.y / latitudeConnectivity;\\n  int startLatitude = endLatitude - latitudeConnectivity / 2 + int(mod(float(indexes.y), float(latitudeConnectivity)));\\n\\n  if (startStation < 0 || startStation >= numStations || startLatitude < 0 || startLatitude >= numLatitudes)\\n    return vec4(0.0);\\n\\n  vec4 start = texelFetch(lattice, ivec2(startLatitude, startStation), 0);\\n  vec4 end = texelFetch(lattice, ivec2(endLatitude, endStation), 0);\\n\\n  return optimize(start, end);\\n}\\n\\n\",output:{name:\"cubicPaths\",read:!0},uniforms:{lattice:{type:\"sharedTexture\"},numStations:{type:\"int\"},numLatitudes:{type:\"int\"},stationConnectivity:{type:\"int\"},latitudeConnectivity:{type:\"int\"}}},{kernel:\"\\n\\nconst int NEWTON_ITERATIONS = 16;\\nconst int RELAXATION_ITERATIONS = 16;\\nconst float CONVERGENCE_ERROR = 0.01;\\n\\n// These two consts must stay in sync.\\nconst int SIMPSONS_INTERVALS = 8;\\n//const float SIMPSONS_COEFFS[SIMPSONS_INTERVALS + 1] = float[](1.0, 4.0, 2.0, 4.0, 2.0, 4.0, 2.0, 4.0, 2.0, 4.0, 2.0, 4.0, 2.0, 4.0, 2.0, 4.0, 1.0);\\nconst float SIMPSONS_COEFFS[SIMPSONS_INTERVALS + 1] = float[](1.0, 4.0, 2.0, 4.0, 2.0, 4.0, 2.0, 4.0, 1.0);\\n\\nconst float PI = 3.1415926535897932384626433832795;\\nconst float TWO_PI = PI + PI;\\n\\nconst float RELAXATION_ITERATIONS_F = float(RELAXATION_ITERATIONS);\\nconst float SIMPSONS_INTERVALS_F = float(SIMPSONS_INTERVALS);\\n\\nfloat wrapAngle(float angle) {\\n  angle = mod(angle, TWO_PI);\\n  if (angle <= -PI) return angle + TWO_PI;\\n  else if (angle > PI) return angle - TWO_PI;\\n  return angle;\\n}\\n\\nvec4 iterate(vec4 goal, float p0, float p1, float p2, float p3, float sG) {\\n  float ds = sG / SIMPSONS_INTERVALS_F;\\n  float sG_2 = sG * sG;\\n  float sG_3 = sG_2 * sG;\\n\\n  vec3 dX_p = vec3(0.0);\\n  vec3 dY_p = vec3(0.0);\\n  vec2 guess = vec2(0.0);\\n  float s = 0.0;\\n\\n  float theta, cosTheta, sinTheta;\\n  vec3 dT_p;\\n\\n  for (int i = 0; i <= SIMPSONS_INTERVALS; i++) {\\n    float coeff = SIMPSONS_COEFFS[i];\\n\\n    float a = p0;\\n    float b = (-5.5 * p0 + 9.0 * p1 - 4.5 * p2 + p3) / sG;\\n    float c = (9.0 * p0 - 22.5 * p1 + 18.0 * p2 - 4.5 * p3) / sG_2;\\n    float d = (-4.5 * (p0 - 3.0 * p1 + 3.0 * p2 - p3)) / sG_3;\\n\\n    theta = (((d * s / 4.0 + c / 3.0) * s + b / 2.0) * s + a) * s;\\n    cosTheta = cos(theta);\\n    sinTheta = sin(theta);\\n\\n    float s_sG = s / sG;\\n\\n    dT_p = vec3(\\n      // p1\\n      ((3.375 * s_sG - 7.5) * s_sG + 4.5) * s_sG * s,\\n\\n      // p2\\n      ((-3.375 * s_sG + 6.0) * s_sG - 2.25) * s_sG * s,\\n\\n      // sG\\n      ((3.375 * (p0 - 3.0 * p1 + 3.0 * p2 - p3) * s_sG - 3.0 * (2.0 * p0 - 5.0 * p1 + 4.0 * p2 - p3)) * s_sG + 0.25 * (11.0 * p0 - 18.0 * p1 + 9.0 * p2 - 2.0 * p3)) * s_sG * s_sG\\n    );\\n\\n    dX_p -= coeff * sinTheta * dT_p;\\n    dY_p += coeff * cosTheta * dT_p;\\n\\n    guess += coeff * vec2(cosTheta, sinTheta);\\n\\n    s += ds;\\n  }\\n\\n  float hOver3 = sG / SIMPSONS_INTERVALS_F / 3.0;\\n\\n  vec3 delta;\\n  delta.xy = goal.xy - guess * hOver3;\\n  delta.z = wrapAngle(goal.z - theta);\\n\\n  if (abs(delta.x) + abs(delta.y) + abs(delta.z) < CONVERGENCE_ERROR)\\n    return vec4(p1, p2, sG, 1.0);\\n\\n  dX_p.xyz *= hOver3;\\n  dY_p.xyz *= hOver3;\\n  dX_p.z += cosTheta;\\n  dY_p.z += sinTheta;\\n\\n  mat3 invJacobian = inverse(transpose(mat3(dX_p, dY_p, dT_p)));\\n\\n  vec3 deltaP = invJacobian * delta;\\n  vec4 params = vec4(p1, p2, sG, 0.0);\\n  params.xyz += deltaP;\\n\\n  return params;\\n}\\n\\n/* Input:\\n *   start: (vec4)\\n *     x: x position,\\n *     y: y position,\\n *     z: theta rotation,\\n *     w: k curvature\\n *   end: (vec4)\\n *     x: x position,\\n *     y: y position,\\n *     z: theta rotation,\\n *     w: k curvature\\n *\\n * Output: (vec4)\\n *   x: p1,\\n *   y: p2,\\n *   z: sG,\\n *   w: 1 if converged, 0 if not\\n */\\n\\nvec4 optimize(vec4 start, vec4 end) {\\n  // Translate and rotate start and end so that start is at the origin\\n  float sinRot = sin(start.z);\\n  float cosRot = cos(start.z);\\n\\n  vec4 diff = end - start;\\n  vec4 goal;\\n  goal.xy = mat2(cosRot, -sinRot, sinRot, cosRot) * diff.xy;\\n  goal.z = wrapAngle(diff.z);\\n  goal.w = end.w;\\n\\n  vec4 originalGoal = goal;\\n  vec4 dGoal;\\n  dGoal.x = 0.0;\\n  dGoal.yzw = goal.yzw / RELAXATION_ITERATIONS_F;\\n  float dK0 = start.w / RELAXATION_ITERATIONS_F;\\n\\n  // Relax the goal to (x, 0, 0, 0)\\n  goal.yzw = vec3(0, 0, 0);\\n\\n  // Relax the params to (0, 0, 0, 0, goal.x)\\n  float p0 = 0.0;\\n  float p1 = 0.0;\\n  float p2 = 0.0;\\n  float p3 = 0.0;\\n  float sG = goal.x;\\n\\n  for (int i = 0; i < RELAXATION_ITERATIONS; i++) {\\n    p0 += dK0;\\n    p3 += dGoal.w;\\n    goal += dGoal;\\n    \\n    vec4 result = iterate(goal, p0, p1, p2, p3, sG);\\n    p1 = result.x;\\n    p2 = result.y;\\n    sG = result.z;\\n  }\\n\\n  goal = originalGoal;\\n\\n  for (int i = 0; i < NEWTON_ITERATIONS; i++) {\\n    vec4 result = iterate(goal, p0, p1, p2, p3, sG);\\n    if (result.w == 1.0) return result;\\n\\n    p1 = result.x;\\n    p2 = result.y;\\n    sG = result.z;\\n  }\\n\\n  return vec4(p1, p2, sG, 0.0);\\n}\\n\\n\\n\\nvec4 kernel() {\\n  ivec2 indexes = ivec2(kernelPosition * vec2(kernelSize));\\n\\n  vec4 start = vec4(0, 0, 0, curvVehicle);\\n  vec4 end = texelFetch(lattice, indexes, 0);\\n\\n  return optimize(start, end);\\n}\\n\\n\",output:{name:\"cubicPathsFromVehicle\",read:!0},uniforms:{lattice:{type:\"sharedTexture\"},curvVehicle:{type:\"float\"}}}],L=(t,e)=>[{width:t.lattice.numStations*t.lattice.numLatitudes,height:t.lattice.stationConnectivity*t.lattice.latitudeConnectivity,uniforms:{numStations:t.lattice.numStations,numLatitudes:t.lattice.numLatitudes,stationConnectivity:t.lattice.stationConnectivity,latitudeConnectivity:t.lattice.latitudeConnectivity}},{width:t.lattice.numLatitudes,height:t.lattice.stationConnectivity,uniforms:{curvVehicle:e.curv}}],b=()=>({kernel:\"\\n\\nconst int NEWTON_ITERATIONS = 16;\\nconst int RELAXATION_ITERATIONS = 16;\\nconst float CONVERGENCE_ERROR = 0.01;\\n\\n// These two consts must stay in sync.\\nconst int SIMPSONS_INTERVALS = 8;\\nconst float SIMPSONS_COEFFS[SIMPSONS_INTERVALS + 1] = float[](1.0, 4.0, 2.0, 4.0, 2.0, 4.0, 2.0, 4.0, 1.0);\\n\\nconst float PI = 3.1415926535897932384626433832795;\\nconst float TWO_PI = PI + PI;\\n\\nconst float RELAXATION_ITERATIONS_F = float(RELAXATION_ITERATIONS);\\nconst float SIMPSONS_INTERVALS_F = float(SIMPSONS_INTERVALS);\\n\\nfloat wrapAngle(float angle) {\\n  angle = mod(angle, TWO_PI);\\n  if (angle <= -PI) return angle + TWO_PI;\\n  else if (angle > PI) return angle - TWO_PI;\\n  return angle;\\n}\\n\\nvec4 iterate(vec4 goal, float p0, float p1, float p2, float p3, float p4, float p5, float sG) {\\n  float ds = sG / SIMPSONS_INTERVALS_F;\\n  float sG_2 = sG * sG;\\n  float sG_3 = sG_2 * sG;\\n\\n  vec3 dX_p = vec3(0.0);\\n  vec3 dY_p = vec3(0.0);\\n  vec2 guess = vec2(0.0);\\n  float s = 0.0;\\n\\n  float theta, cosTheta, sinTheta;\\n  vec3 dT_p;\\n\\n  for (int i = 0; i <= SIMPSONS_INTERVALS; i++) {\\n    float coeff = SIMPSONS_COEFFS[i];\\n\\n    float a = p0;\\n    float b = p1;\\n    float c = p2 / 2.0;\\n    float d = (-71.875 * p0 + 81.0 * p3 - 10.125 * p4 + p5 - 21.25 * p1 * sG - 2.75 * p2 * sG_2) / sG_3;\\n    float e = (166.5 * p0 - 202.5 * p3 + 40.5 * p4 - 4.5 * p5 + 45.0 * p1 * sG + 4.5 * p2 * sG_2) / (sG_2 * sG_2);\\n    float f = (-95.625 * p0 + 121.5 * p3 - 30.375 * p4 + 4.5 * p5 - 24.75 * p1 * sG - 2.25 * p2 * sG_2) / (sG_2 * sG_3);\\n\\n    theta = (((((f * s / 6.0 + e / 5.0) * s + d / 4.0) * s + c / 3.0) * s + b / 2.0) * s + a) * s;\\n    cosTheta = cos(theta);\\n    sinTheta = sin(theta);\\n\\n    float s_2 = s * s;\\n    float s_sG = s / sG;\\n    float s_sG_2 = s_sG * s_sG;\\n    float s_sG_3 = s_sG_2 * s_sG;\\n    float s_sG_4 = s_sG_3 * s_sG;\\n    float s_sG_5 = s_sG_4 * s_sG;\\n\\n    dT_p = vec3(\\n      // p3\\n      ((20.25 * s_sG - 40.5) * s_sG + 20.25) * s_sG_3 * s,\\n\\n      // p4\\n      ((-5.0625 * s_sG + 8.1) * s_sG - 2.53125) * s_sG_3 * s,\\n\\n      // sG\\n      (53.90625 * p0 - 60.75 * p3 + 7.59375 * p4 - 0.75 * p5) * s_sG_4 + 10.625 * p1 * s * s_sG_3 + 0.6875 * p2 * s_2 * s_sG_2 + (-133.2 * p0 + 162.0 * p3 - 32.4 * p4 + 3.6 * p5) * s_sG_5 + (-27.0) * p1 * s * s_sG_4 - 1.8 * p2 * s_2 * s_sG_3 + (79.6875 * p0 - 101.25 * p3 + 25.3125 * p4 - 3.75 * p5) * s_sG_5 * s_sG + 16.5 * p1 * s * s_sG_5 + 1.125 * p2 * s_2 * s_sG_4\\n    );\\n\\n    dX_p -= coeff * sinTheta * dT_p;\\n    dY_p += coeff * cosTheta * dT_p;\\n\\n    guess += coeff * vec2(cosTheta, sinTheta);\\n\\n    s += ds;\\n  }\\n\\n  float hOver3 = sG / SIMPSONS_INTERVALS_F / 3.0;\\n\\n  vec3 delta;\\n  delta.xy = goal.xy - guess * hOver3;\\n  delta.z = wrapAngle(goal.z - theta);\\n\\n  if (abs(delta.x) + abs(delta.y) + abs(delta.z) < CONVERGENCE_ERROR)\\n    return vec4(p3, p4, sG, 1.0);\\n\\n  dX_p.xyz *= hOver3;\\n  dY_p.xyz *= hOver3;\\n  dX_p.z += cosTheta;\\n  dY_p.z += sinTheta;\\n\\n  mat3 invJacobian = inverse(transpose(mat3(dX_p, dY_p, dT_p)));\\n\\n  vec3 deltaP = invJacobian * delta;\\n  vec4 params = vec4(p3, p4, sG, 0.0);\\n  params.xyz += deltaP;\\n\\n  return params;\\n}\\n\\nvec4 optimize(vec4 start, vec4 end) {\\n  // Translate and rotate start and end so that start is at the origin\\n  float sinRot = sin(start.z);\\n  float cosRot = cos(start.z);\\n\\n  vec4 diff = end - start;\\n  vec4 goal;\\n  goal.xy = mat2(cosRot, -sinRot, sinRot, cosRot) * diff.xy;\\n  goal.z = wrapAngle(diff.z);\\n  goal.w = end.w;\\n\\n  vec4 originalGoal = goal;\\n  vec4 dGoal;\\n  dGoal.x = 0.0;\\n  dGoal.yzw = goal.yzw / RELAXATION_ITERATIONS_F;\\n  float d_K0 = start.w / RELAXATION_ITERATIONS_F;\\n  float d_dK0 = dCurvVehicle / RELAXATION_ITERATIONS_F;\\n  float d_ddK0 = ddCurvVehicle / RELAXATION_ITERATIONS_F;\\n\\n  // Relax the goal to (x, 0, 0, 0)\\n  goal.yzw = vec3(0, 0, 0);\\n\\n  // Relax the params to (0, 0, 0, 0, goal.x)\\n  float p0 = 0.0;\\n  float p1 = 0.0;\\n  float p2 = 0.0;\\n  float p3 = 0.0;\\n  float p4 = 0.0;\\n  float p5 = 0.0;\\n  float sG = goal.x;\\n\\n  for (int i = 0; i < RELAXATION_ITERATIONS; i++) {\\n    p0 += d_K0;\\n    p1 += d_dK0;\\n    p2 += d_ddK0;\\n    p5 += dGoal.w;\\n    goal += dGoal;\\n    \\n    vec4 result = iterate(goal, p0, p1, p2, p3, p4, p5, sG);\\n    p3 = result.x;\\n    p4 = result.y;\\n    sG = result.z;\\n  }\\n\\n  goal = originalGoal;\\n\\n  for (int i = 0; i < NEWTON_ITERATIONS; i++) {\\n    vec4 result = iterate(goal, p0, p1, p2, p3, p4, p5, sG);\\n    if (result.w == 1.0) return result;\\n\\n    p3 = result.x;\\n    p4 = result.y;\\n    sG = result.z;\\n  }\\n\\n  return vec4(p3, p4, sG, 0.0);\\n}\\n\\nvec4 kernel() {\\n  ivec2 latticeIndexes = ivec2(kernelPosition * vec2(kernelSize));\\n\\n  vec4 start = vec4(0, 0, 0, curvVehicle);\\n  vec4 end = texelFetch(lattice, latticeIndexes, 0);\\n\\n  return optimize(start, end);\\n}\\n\\n\",output:{name:\"quinticPathsFromVehicle\",read:!0},uniforms:{lattice:{type:\"sharedTexture\"},curvVehicle:{type:\"float\"},dCurvVehicle:{type:\"float\"},ddCurvVehicle:{type:\"float\"}}}),G=(t,e)=>({width:t.lattice.numLatitudes,height:t.lattice.stationConnectivity,uniforms:{curvVehicle:e.curv,dCurvVehicle:e.dCurv,ddCurvVehicle:e.ddCurv}});const C=\"\\n\\nconst float smallV = 0.01;\\nvec4 pathSamples[128];\\nfloat pathSampleCurvRates[128];\\n\\nfloat calculateAcceleration(int index, float initialVelocitySq, float distance) {\\n  if (index <= 4) {\\n    // [aMaxHard, aMinHard, aMaxSoft, aMinSoft, 0]\\n    return accelerationProfiles[index];\\n  } else {\\n    float finalVelocity = finalVelocityProfiles[index - 5];\\n    return clamp((finalVelocity * finalVelocity - initialVelocitySq) / (2.0 * distance), accelerationProfiles[1], accelerationProfiles[0]);\\n  }\\n}\\n\\nfloat sampleStaticCost(vec4 xytk) {\\n  vec2 xyTexCoords = (xytk.xy - xyCenterPoint) / vec2(textureSize(xyslMap, 0)) / vec2(xyGridCellSize) + 0.5;\\n  vec2 sl = texture(xyslMap, xyTexCoords).xy;\\n\\n  vec2 slTexCoords = (sl - slCenterPoint) / vec2(textureSize(slObstacleGrid, 0)) / vec2(slGridCellSize) + 0.5;\\n  float obstacleCost = texture(slObstacleGrid, slTexCoords).x;\\n\\n  if (obstacleCost == 1.0) return -1.0; // Infinite cost\\n  obstacleCost = step(0.25, obstacleCost) * obstacleHazardCost;\\n\\n  float absLatitude = abs(sl.y);\\n  float laneCost = max(absLatitude * laneCostSlope, step(laneShoulderLatitude, absLatitude) * laneShoulderCost);\\n\\n  return obstacleCost + laneCost;\\n}\\n\\nfloat sampleDynamicCost(vec4 xytk, float time, float velocity, float acceleration) {\\n  return 1.0;\\n}\\n\\nfloat calculateAverageStaticCost(int numSamples) {\\n  float averageStaticCost = 0.0;\\n\\n  for (int i = 0; i < numSamples; i++) {\\n    float cost = sampleStaticCost(pathSamples[i]);\\n\\n    if (cost < 0.0) return cost;\\n\\n    averageStaticCost += cost;\\n  }\\n\\n  return averageStaticCost / float(numSamples);\\n}\\n\\nfloat calculateAverageDynamicCost(int numSamples, float pathLength, float initialVelocity, float acceleration) {\\n  float s = 0.0;\\n  float ds = pathLength / float(numSamples - 1);\\n  float averageDynamicCost = 0.0;\\n  float maxVelocity = 0.0;\\n  float maxLateralAcceleration = 0.0;\\n\\n  for (int i = 0; i < numSamples; i++) {\\n    vec4 pathSample = pathSamples[i]; // vec4(x-pos, y-pos, theta (rotation), kappa (curvature))\\n\\n    float velocitySq = 2.0 * acceleration * s + initialVelocity * initialVelocity;\\n    float velocity = max(smallV, sqrt(max(0.0, velocitySq)));\\n    maxVelocity = max(maxVelocity, velocity);\\n    maxLateralAcceleration = max(maxLateralAcceleration, abs(pathSample.w * velocity * velocity));\\n\\n    float time = 2.0 * s / (initialVelocity + velocity);\\n\\n    float dCurv = pathSampleCurvRates[i] * velocity;\\n    if (dCurv > dCurvatureMax) return -1.0;\\n\\n    float cost = sampleDynamicCost(pathSample, time, velocity, acceleration);\\n    if (cost < 0.0) return cost;\\n\\n    averageDynamicCost += cost;\\n    s += ds;\\n  }\\n\\n  averageDynamicCost /= float(numSamples);\\n\\n  // Apply speeding penality if any velocity along the trajectory is over the speed limit\\n  averageDynamicCost += step(speedLimit, maxVelocity) * speedLimitPenalty;\\n\\n  // Apply hard acceleration/deceleration penalties if the acceleration/deceleration exceeds the soft limits\\n  averageDynamicCost += step(accelerationProfiles[2] + 0.0001, acceleration) * hardAccelerationPenalty;\\n  averageDynamicCost += (1.0 - step(accelerationProfiles[3], acceleration)) * hardDecelerationPenalty;\\n\\n  // Penalize lateral acceleration\\n  averageDynamicCost += step(lateralAccelerationLimit, maxLateralAcceleration) * softLateralAccelerationPenalty;\\n  averageDynamicCost += linearLateralAccelerationPenalty * maxLateralAcceleration;\\n\\n  return averageDynamicCost;\\n}\\n\\nvec3 calculateAVT(int accelerationIndex, float initialVelocity, float initialTime, float pathLength) {\\n  float initialVelocitySq = initialVelocity * initialVelocity;\\n  float acceleration = calculateAcceleration(accelerationIndex, initialVelocitySq, pathLength);\\n\\n  float finalVelocitySq = 2.0 * acceleration * pathLength + initialVelocitySq;\\n  float finalVelocity = max(smallV, sqrt(max(0.0, finalVelocitySq)));\\n\\n  float finalTime = initialTime;\\n\\n  if (acceleration == 0.0) {\\n    finalTime += pathLength / finalVelocity;\\n  } else if (finalVelocitySq <= 0.0) { // Calculate final time if the vehicle stops before the end of the trajectory\\n    float distanceLeft = pathLength - (smallV * smallV - initialVelocitySq) / (2.0 * acceleration);\\n    finalTime += (finalVelocity - initialVelocity) / acceleration + distanceLeft / smallV;\\n  } else {\\n    finalTime += 2.0 * pathLength / (finalVelocity + initialVelocity);\\n  }\\n\\n  return vec3(acceleration, finalVelocity, finalTime);\\n}\\n\\n\",I=\"\\n\\nint sampleCubicPath(vec4 start, vec4 end, vec4 cubicPathParams) {\\n  float p0 = start.w;\\n  float p1 = cubicPathParams.x;\\n  float p2 = cubicPathParams.y;\\n  float p3 = end.w;\\n  float sG = cubicPathParams.z;\\n\\n  int numSamples = int(ceil(sG / pathSamplingStep)) + 1;\\n\\n  float sG_2 = sG * sG;\\n  float sG_3 = sG_2 * sG;\\n\\n  float a = p0;\\n  float b = (-5.5 * p0 + 9.0 * p1 - 4.5 * p2 + p3) / sG;\\n  float c = (9.0 * p0 - 22.5 * p1 + 18.0 * p2 - 4.5 * p3) / sG_2;\\n  float d = (-4.5 * (p0 - 3.0 * p1 + 3.0 * p2 - p3)) / sG_3;\\n\\n  pathSamples[0] = start;\\n\\n  float ds = sG / float(numSamples - 1);\\n  float s = ds;\\n  vec2 dxy = vec2(0);\\n  vec2 prevCosSin = vec2(cos(start.z), sin(start.z));\\n\\n  for (int i = 1; i < numSamples; i++) {\\n    float rot = (((d * s / 4.0 + c / 3.0) * s + b / 2.0) * s + a) * s + start.z;\\n    float curv = ((d * s + c) * s + b) * s + a;\\n\\n    vec2 cosSin = vec2(cos(rot), sin(rot));\\n    dxy = dxy * vec2(float(i - 1) / float(i)) + (cosSin + prevCosSin) / vec2(2 * i);\\n\\n    pathSamples[i] = vec4(dxy * vec2(s) + start.xy, rot, curv);\\n    pathSampleCurvRates[i] = b + s * (2.0 * c + 3.0 * d * s);\\n\\n    s += ds;\\n    prevCosSin = cosSin;\\n  }\\n\\n  return numSamples;\\n}\\n\\n\",O=\"\\n\\nint sampleQuinticPath(vec4 start, vec4 end, vec4 quinticPathParams) {\\n  float p0 = start.w;\\n  float p1 = dCurvVehicle;\\n  float p2 = ddCurvVehicle;\\n  float p3 = quinticPathParams.x;\\n  float p4 = quinticPathParams.y;\\n  float p5 = end.w;\\n  float sG = quinticPathParams.z;\\n\\n  int numSamples = int(ceil(sG / pathSamplingStep)) + 1;\\n\\n  float sG_2 = sG * sG;\\n  float sG_3 = sG_2 * sG;\\n\\n  float a = p0;\\n  float b = p1;\\n  float c = p2 / 2.0;\\n  float d = (-71.875 * p0 + 81.0 * p3 - 10.125 * p4 + p5 - 21.25 * p1 * sG - 2.75 * p2 * sG_2) / sG_3;\\n  float e = (166.5 * p0 - 202.5 * p3 + 40.5 * p4 - 4.5 * p5 + 45.0 * p1 * sG + 4.5 * p2 * sG_2) / (sG_2 * sG_2);\\n  float f = (-95.625 * p0 + 121.5 * p3 - 30.375 * p4 + 4.5 * p5 - 24.75 * p1 * sG - 2.25 * p2 * sG_2) / (sG_2 * sG_3);\\n\\n  pathSamples[0] = start;\\n\\n  float ds = sG / float(numSamples - 1);\\n  float s = ds;\\n  vec2 dxy = vec2(0);\\n  vec2 prevCosSin = vec2(cos(start.z), sin(start.z));\\n\\n  for (int i = 1; i < numSamples; i++) {\\n    float rot = (((((f * s / 6.0 + e / 5.0) * s + d / 4.0) * s + c / 3.0) * s + b / 2.0) * s + a) * s + start.z;\\n    float curv = ((((f * s + e) * s + d) * s + c) * s + b) * s + a;\\n\\n    vec2 cosSin = vec2(cos(rot), sin(rot));\\n    dxy = dxy * vec2(float(i - 1) / float(i)) + (cosSin + prevCosSin) / vec2(2 * i);\\n\\n    pathSamples[i] = vec4(dxy * vec2(s) + start.xy, rot, curv);\\n    pathSampleCurvRates[i] = b + s * (2.0 * c + s * (3.0 * d + s * (4.0 * e + 5.0 * f * s)));\\n\\n    s += ds;\\n    prevCosSin = cosSin;\\n  }\\n\\n  return numSamples;\\n}\\n\\n\",w={xyslMap:{type:\"outputTexture\"},slObstacleGrid:{type:\"outputTexture\",name:\"slObstacleGridDilated\"},accelerationProfiles:{type:\"float\",length:5},finalVelocityProfiles:{type:\"float\",length:3},xyCenterPoint:{type:\"vec2\"},xyGridCellSize:{type:\"float\"},slCenterPoint:{type:\"vec2\"},slGridCellSize:{type:\"float\"},laneCostSlope:{type:\"float\"},laneShoulderCost:{type:\"float\"},laneShoulderLatitude:{type:\"float\"},obstacleHazardCost:{type:\"float\"},speedLimit:{type:\"float\"},speedLimitPenalty:{type:\"float\"},hardAccelerationPenalty:{type:\"float\"},hardDecelerationPenalty:{type:\"float\"},lateralAccelerationLimit:{type:\"float\"},softLateralAccelerationPenalty:{type:\"float\"},linearLateralAccelerationPenalty:{type:\"float\"},dCurvatureMax:{type:\"float\"},pathSamplingStep:{type:\"float\"}};function D(t,e,n){return{accelerationProfiles:[3.5,-6.5,2,-3,0],finalVelocityProfiles:[.99*t.speedLimit,1,.01],xyCenterPoint:[e.x,e.y],xyGridCellSize:t.xyGridCellSize,slCenterPoint:[n.x,n.y],slGridCellSize:t.slGridCellSize,laneCostSlope:t.laneCostSlope,laneShoulderCost:t.laneShoulderCost,laneShoulderLatitude:t.laneShoulderLatitude,obstacleHazardCost:t.obstacleHazardCost,speedLimit:t.speedLimit,speedLimitPenalty:t.speedLimitPenalty,hardAccelerationPenalty:t.hardAccelerationPenalty,hardDecelerationPenalty:t.hardDecelerationPenalty,lateralAccelerationLimit:t.lateralAccelerationLimit,softLateralAccelerationPenalty:t.softLateralAccelerationPenalty,linearLateralAccelerationPenalty:t.linearLateralAccelerationPenalty,dCurvatureMax:t.dCurvatureMax,pathSamplingStep:t.pathSamplingStep}}function V(t){return C+(\"cubic\"==t?I:O)+`\\n\\n/* Calculate cost of a {cubic|quintic} path from vehicle to (stationConnectivity * numLatitudes * numAccelerations) nodes\\n *   width: numLatitudes\\n *   height: station * numAccelerations\\n */\\nvec4 kernel() {\\n  ivec2 indexes = ivec2(kernelPosition * vec2(kernelSize));\\n\\n  int latitude = indexes.x;\\n  int station = indexes.y / numAccelerations;\\n  int accelerationIndex = int(mod(float(indexes.y), float(numAccelerations)));\\n\\n  vec4 pathStart = vec4(0, 0, 0, curvVehicle);\\n  vec4 pathEnd = texelFetch(lattice, ivec2(latitude, station), 0);\\n\\n  vec4 pathParams = texelFetch(pathsFromVehicle, ivec2(latitude, station), 0);\\n\\n  // If the path didn't converge\\n  if (pathParams.w == 0.0) return vec4(-1);\\n\\n  int numSamples = ${\"cubic\"==t?\"sampleCubicPath\":\"sampleQuinticPath\"}(pathStart, pathEnd, pathParams);\\n  float pathLength = pathParams.z;\\n\\n  float averageStaticCost = calculateAverageStaticCost(numSamples);\\n  if (averageStaticCost < 0.0) return vec4(-1);\\n\\n  vec3 avt = calculateAVT(accelerationIndex, velocityVehicle, 0.0, pathLength);\\n  float acceleration = avt.x;\\n  float finalVelocity = avt.y;\\n  float finalTime = avt.z;\\n\\n  float averageDynamicCost = calculateAverageDynamicCost(numSamples, pathLength, velocityVehicle, acceleration);\\n  if (averageDynamicCost < 0.0) return vec4(-1);\\n\\n  // The cost of a trajectory is the average sample cost scaled by the path length\\n  float totalCost = (averageStaticCost + averageDynamicCost + ${\"cubic\"==t?\"(cubicPathPenalty * velocityVehicle * velocityVehicle)\":\"0.0\"}) * pathLength;\\n\\n  return vec4(totalCost, finalVelocity, finalTime, ${\"cubic\"==t?\"-2\":\"-1\"});\\n}\\n\\n`}var N=()=>[{kernel:V(\"cubic\"),output:{name:\"cubicPathFromVehicleCosts\"},uniforms:{...w,lattice:{type:\"sharedTexture\"},pathsFromVehicle:{type:\"outputTexture\",name:\"cubicPathsFromVehicle\"},velocityVehicle:{type:\"float\"},curvVehicle:{type:\"float\"},numAccelerations:{type:\"int\"},cubicPathPenalty:{type:\"float\"}}},{kernel:V(\"quintic\"),output:{name:\"quinticPathFromVehicleCosts\"},uniforms:{...w,lattice:{type:\"sharedTexture\"},pathsFromVehicle:{type:\"outputTexture\",name:\"quinticPathsFromVehicle\"},velocityVehicle:{type:\"float\"},curvVehicle:{type:\"float\"},dCurvVehicle:{type:\"float\"},ddCurvVehicle:{type:\"float\"},numAccelerations:{type:\"int\"}}}],F=(t,e,n,i)=>[{width:t.lattice.numLatitudes,height:8*t.lattice.stationConnectivity,uniforms:{...D(t,n,i),velocityVehicle:e.speed,curvVehicle:e.curv,numAccelerations:8,cubicPathPenalty:t.cubicPathPenalty}},{width:t.lattice.numLatitudes,height:8*t.lattice.stationConnectivity,uniforms:{...D(t,n,i),velocityVehicle:e.speed,curvVehicle:e.curv,dCurvVehicle:e.dCurv,ddCurvVehicle:e.ddCurv,numAccelerations:8}}];const M=C+I+O+\"\\n\\nvec4 kernel() {\\n  ivec2 indexes = ivec2(kernelPosition * vec2(kernelSize));\\n\\n  int latitude = indexes.y;\\n\\n  int numPerTime = numAccelerations * numVelocities;\\n  int timeIndex = indexes.x / numPerTime;\\n  indexes.x -= timeIndex * numPerTime;\\n  int velocityIndex = indexes.x / numAccelerations;\\n  int accelerationIndex = int(mod(float(indexes.x), float(numAccelerations)));\\n\\n  int minLatitude = max(latitude - latitudeConnectivity / 2, 0);\\n  int maxLatitude = min(latitude + latitudeConnectivity / 2, numLatitudes - 1);\\n\\n  int slIndex = station * numLatitudes + latitude;\\n\\n  vec4 pathEnd = texelFetch(lattice, ivec2(latitude, station), 0);\\n\\n  float minVelocity = velocityRanges[velocityIndex];\\n  float maxVelocity = velocityRanges[velocityIndex + 1];\\n\\n  float minTime = timeRanges[timeIndex];\\n  float maxTime = timeRanges[timeIndex + 1];\\n\\n  vec4 bestTrajectory = vec4(-1); // -1 means infinite cost\\n  float bestCost = 1000000000.0;\\n\\n  for (int prevStation = max(station - stationConnectivity, 0); prevStation < station; prevStation++) {\\n    int stationConnectivityIndex = prevStation - station + stationConnectivity;\\n\\n    for (int prevLatitude = minLatitude; prevLatitude <= maxLatitude; prevLatitude++) {\\n      int latitudeConnectivityIndex = prevLatitude - latitude + latitudeConnectivity / 2;\\n      int connectivityIndex = stationConnectivityIndex * latitudeConnectivity + latitudeConnectivityIndex;\\n\\n      vec4 pathStart = texelFetch(lattice, ivec2(prevLatitude, prevStation), 0);\\n      vec4 cubicPathParams = texelFetch(cubicPaths, ivec2(slIndex, connectivityIndex), 0);\\n\\n      // If the path didn't converge\\n      if (cubicPathParams.w == 0.0) continue;\\n\\n      int numSamples = sampleCubicPath(pathStart, pathEnd, cubicPathParams);\\n      float pathLength = cubicPathParams.z;\\n\\n      float averageStaticCost = calculateAverageStaticCost(numSamples);\\n      if (averageStaticCost < 0.0) continue;\\n\\n      for (int prevVelocity = 0; prevVelocity < numVelocities; prevVelocity++) {\\n        for (int prevTime = 0; prevTime < numTimes; prevTime++) {\\n          for (int prevAccel = 0; prevAccel < numAccelerations; prevAccel++) {\\n            int avtIndex = prevTime * numPerTime + prevVelocity * numAccelerations + prevAccel;\\n\\n            // Cost table entry:\\n            //   x: cost so far\\n            //   y: end speed\\n            //   z: end time\\n            //   w: parent index\\n            vec4 costTableEntry = texelFetch(costTable, ivec3(avtIndex, prevLatitude, prevStation), 0);\\n\\n            // If cost entry is infinity\\n            if (costTableEntry.x < 0.0) continue;\\n\\n            vec3 avt = calculateAVT(accelerationIndex, costTableEntry.y, costTableEntry.z, pathLength);\\n            float acceleration = avt.x;\\n            float finalVelocity = avt.y;\\n            float finalTime = avt.z;\\n\\n            // If the calculated final velocity does not match this fragment's velocity range, then skip this trajectory\\n            if (finalVelocity < minVelocity || finalVelocity >= maxVelocity) continue;\\n\\n            // If the calculated final time does not match this fragment's time range, then skip this trajectory\\n            if (finalTime < minTime || finalTime >= maxTime) continue;\\n\\n            float averageDynamicCost = calculateAverageDynamicCost(numSamples, pathLength, costTableEntry.y, acceleration);\\n            if (averageDynamicCost < 0.0) continue;\\n\\n            // The cost of a trajectory is the average sample cost scaled by the path length\\n            float totalCost = (averageStaticCost + averageDynamicCost) * pathLength + costTableEntry.x;\\n\\n            float terminalCost = totalCost + extraTimePenalty * finalTime;\\n            if (terminalCost >= bestCost) continue;\\n            bestCost = terminalCost;\\n\\n            int incomingIndex = avtIndex + numPerTime * numTimes * (prevLatitude + numLatitudes * prevStation);\\n            bestTrajectory = vec4(totalCost, finalVelocity, finalTime, incomingIndex);\\n          }\\n        }\\n      }\\n    }\\n  }\\n\\n  if (station < stationConnectivity) {\\n    ivec2 slaIndex = ivec2(latitude, station * numAccelerations + accelerationIndex);\\n\\n    vec4 costTableEntry = texelFetch(cubicPathFromVehicleCosts, slaIndex, 0);\\n    float terminalCost;\\n\\n    if (costTableEntry.x >= 0.0) {\\n      terminalCost = costTableEntry.x + extraTimePenalty * costTableEntry.z;\\n\\n      if (terminalCost < bestCost) {\\n        bestCost = terminalCost;\\n        bestTrajectory = costTableEntry;\\n      }\\n    }\\n\\n    costTableEntry = texelFetch(quinticPathFromVehicleCosts, slaIndex, 0);\\n\\n    if (costTableEntry.x >= 0.0) {\\n      terminalCost = costTableEntry.x + extraTimePenalty * costTableEntry.z;\\n\\n      if (terminalCost < bestCost) {\\n        bestCost = terminalCost;\\n        bestTrajectory = costTableEntry;\\n      }\\n    }\\n  }\\n\\n  return bestTrajectory;\\n}\\n\\n\";var z=()=>({kernel:M,output:{name:\"graphSearch\"},uniforms:{...w,lattice:{type:\"sharedTexture\"},costTable:{type:\"sharedTexture\",textureType:\"2DArray\"},cubicPaths:{type:\"outputTexture\"},cubicPathFromVehicleCosts:{type:\"outputTexture\"},quinticPathFromVehicleCosts:{type:\"outputTexture\"},velocityVehicle:{type:\"float\"},curvVehicle:{type:\"float\"},dCurvVehicle:{type:\"float\"},ddCurvVehicle:{type:\"float\"},extraTimePenalty:{type:\"float\"},numStations:{type:\"int\"},numLatitudes:{type:\"int\"},numAccelerations:{type:\"int\"},numVelocities:{type:\"int\"},numTimes:{type:\"int\"},stationConnectivity:{type:\"int\"},latitudeConnectivity:{type:\"int\"},velocityRanges:{type:\"float\",length:5},timeRanges:{type:\"float\",length:3},station:{type:\"int\"}},drawProxy:(t,e,n)=>{const i=e.meta.lattice.numLatitudes,a=new Float32Array(64*i*e.meta.lattice.numStations*4);for(let o=0;o<e.meta.lattice.numStations;o++)t.updateProgramUniforms(e,{station:o}),n(),t.gl.readPixels(0,0,64,i,t.gl.RGBA,t.gl.FLOAT,a,64*o*i*4),t.gl.bindTexture(t.gl.TEXTURE_2D_ARRAY,t.sharedTextures.costTable),t.gl.copyTexSubImage3D(t.gl.TEXTURE_2D_ARRAY,0,0,0,o,0,0,64,i);t._graphSearchCostTable=a}}),B=(t,e,n,i)=>({width:64,height:t.lattice.numLatitudes,meta:{lattice:t.lattice},uniforms:{...D(t,n,i),velocityVehicle:e.speed,curvVehicle:e.curv,dCurvVehicle:e.dCurv,ddCurvVehicle:e.ddCurv,extraTimePenalty:t.extraTimePenalty,numStations:t.lattice.numStations,numLatitudes:t.lattice.numLatitudes,numAccelerations:8,numVelocities:4,numTimes:2,stationConnectivity:t.lattice.stationConnectivity,latitudeConnectivity:t.lattice.latitudeConnectivity,velocityRanges:[0,t.speedLimit/3,2*t.speedLimit/3,t.speedLimit,1e6],timeRanges:[0,10,1e6]}});const H={spatialHorizon:100,stationInterval:.5,lattice:{numStations:10,numLatitudes:19,stationConnectivity:3,latitudeConnectivity:9},xyGridCellSize:.3,slGridCellSize:.15,gridMargin:10,pathSamplingStep:.5,cubicPathPenalty:.1,lethalDilationS:a.HALF_CAR_LENGTH+.6,hazardDilationS:2,lethalDilationL:a.HALF_CAR_WIDTH+.3,hazardDilationL:1,obstacleHazardCost:10,laneWidth:3.7,laneShoulderCost:5,laneShoulderLatitude:1.85-a.HALF_CAR_WIDTH,laneCostSlope:.5,stationReachDiscount:-10,extraTimePenalty:10,speedLimit:25,speedLimitPenalty:25,hardAccelerationPenalty:10,hardDecelerationPenalty:10,lateralAccelerationLimit:3,softLateralAccelerationPenalty:10,linearLateralAccelerationPenalty:1,dCurvatureMax:a.MAX_STEER_SPEED/a.WHEEL_BASE};(class{constructor(){const t=[v.setUp(),x(),...T(),A(),...R(),b(),...N(),z()].map(t=>Object.assign({},t,{width:1,height:1}));this.gpgpu=new class{static alloc(t,e){if(!Number.isInteger(e)||e<1||e>4)throw new Error(\"Data stride must be an integer between 1 and 4.\");const n=Math.pow(Math.ceil(Math.sqrt(t)),2),i=new Float32Array(n*e);return i.gpgpuSize=t,i.gpgpuStride=e,i}constructor(t,e={}){this._setUpGL(),this.outputTextures={},this.sharedTextures={},this.programs=t.map(t=>this._prepareProgram(t));for(const t in e){const{width:n,height:i,channels:a,data:o,...s}=e[t];this.sharedTextures[t]=this._createTexture(o,n,i,a,s)}}updateSharedTextures(t){this.sharedTextures={};for(const e in t){const{width:n,height:i,channels:a,data:o,...s}=t[e];this.sharedTextures[e]=this._createTexture(o,n,i,a,s)}}updateProgram(t,e){const n=\"number\"==typeof t?this.programs[t]:t;if(!n)throw new Error(`Program with index ${t} does not exist.`);if(e.inputs)throw new Error(\"The `updateProgram` function cannot be used to update inputs. Use `updateProgramInputs` instead.\");e.meta&&(n.meta=Object.assign(n.meta,e.meta)),void 0!==e.width&&void 0!==e.height&&this.updateProgramSize(n,e.width,e.height),\"object\"==typeof e.uniforms&&this.updateProgramUniforms(n,e.uniforms)}updateProgramInputs(t,e){const n=this.programs[t];if(!n)throw new Error(`Program with index ${t} does not exist.`);if(n.inputTextures.length!=e.length)throw new Error(`You must provide the same number of inputs as when the program was set up: got ${e.length} but expected ${n.inputTextures.length}.`);const i=n.inputWidth,a=n.inputHeight,o=n.config;void 0!==o.width&&void 0!==o.height||(n.inputWidth=void 0,n.inputHeight=void 0,n.inputDataSize=void 0),this._prepareProgramInputs(n,e),n.inputWidth==i&&n.inputHeight==a||(this.gl.useProgram(n.glProgram),this.gl.uniform2i(n.kernelSizeLocation,n.inputWidth,n.inputHeight),this._prepareProgramOutput(n))}updateProgramSize(t,e,n){const i=\"number\"==typeof t?this.programs[t]:t;if(!i)throw new Error(`Program with index ${t} does not exist.`);if(0!=i.inputTextures.length)throw new Error(\"Size can only be updated on programs with no inputs.\");e==i.inputWidth&&n==i.inputHeight||(i.inputWidth=e,i.inputHeight=n,i.inputDataSize=e*n,this.gl.useProgram(i.glProgram),this.gl.uniform2i(i.kernelSizeLocation,i.inputWidth,i.inputHeight),this._prepareProgramOutput(i))}updateProgramUniforms(t,e){const n=\"number\"==typeof t?this.programs[t]:t;if(this.gl.useProgram(n.glProgram),!n)throw new Error(`Program with index ${t} does not exist.`);for(const t in e){const i=e[t];let a;if(a=n.uniforms[t])this._setUniform(a.type,a.location,i);else{if(!(a=n.uniformTextures[t]))throw new Error(`The uniform ${t} does not exist in this program.`);{if(\"object\"!=typeof i||\"texture\"!=i.type)throw new Error(`Expected texture type for uniform ${t}.`);const{width:e,height:o,channels:s,data:r,...l}=a;n.uniformTextures[t].texture=this._createTexture(r,e,o,s,l)}}}}run(){const t=[];for(const e of this.programs){this.gl.useProgram(e.glProgram),this.gl.viewport(0,0,e.inputWidth,e.inputHeight),this.gl.bindFramebuffer(this.gl.FRAMEBUFFER,e.frameBuffer);for(const[t,n]of e.inputTextures.entries())this.gl.activeTexture(this.gl.TEXTURE0+t),this.gl.bindTexture(this.gl.TEXTURE_2D,n);for(const t in e.uniformTextures){const n=e.uniformTextures[t];this.gl.activeTexture(this.gl.TEXTURE0+n.index),this.gl.bindTexture(n.target,n.texture||this.sharedTextures[n.name]||this.outputTextures[n.name])}if(\"function\"==typeof e.draw)e.draw(this.gl,e);else if(this.gl.bindBuffer(this.gl.ARRAY_BUFFER,this.textureBuffer),this.gl.enableVertexAttribArray(e.textureLocation),this.gl.vertexAttribPointer(e.textureLocation,2,this.gl.FLOAT,!1,0,0),this.gl.bindBuffer(this.gl.ARRAY_BUFFER,this.positionBuffer),this.gl.enableVertexAttribArray(e.positionLocation),this.gl.vertexAttribPointer(e.positionLocation,2,this.gl.FLOAT,!1,0,0),this.gl.bindBuffer(this.gl.ELEMENT_ARRAY_BUFFER,this.indexBuffer),e.drawProxy){const t=(()=>this.gl.drawElements(this.gl.TRIANGLES,6,this.gl.UNSIGNED_SHORT,0)).bind(this);e.drawProxy(this,e,t)}else this.gl.drawElements(this.gl.TRIANGLES,6,this.gl.UNSIGNED_SHORT,0);if(e.output&&e.output.name&&!e.output.read)t.push(null);else{const n=new Float32Array(e.inputWidth*e.inputHeight*4);this.gl.readPixels(0,0,e.inputWidth,e.inputHeight,this.gl.RGBA,this.gl.FLOAT,n),t.push(n.subarray(0,4*e.inputDataSize))}}return t}_setUpGL(){const t=document.createElement(\"canvas\"),e={alpha:!1,antialias:!1};if(this.gl=t.getContext(\"webgl2\",e)||t.getContext(\"experimental-webgl2\",e),!this.gl)throw new Error(\"Unable to initialize WebGL2. Your browser may not support it.\");if(!this.gl.getExtension(\"EXT_color_buffer_float\"))throw new Error(\"Required WebGL extension EXT_color_buffer_float not supported.\");if(!this.gl.getExtension(\"OES_texture_float_linear\"))throw new Error(\"Required WebGL extension OES_texture_float_linear not supported.\");this.positionBuffer=this._newBuffer([-1,-1,1,-1,1,1,-1,1]),this.textureBuffer=this._newBuffer([0,0,1,0,1,1,0,1]),this.indexBuffer=this._newBuffer([1,2,0,3,0,2],Uint16Array,this.gl.ELEMENT_ARRAY_BUFFER)}_prepareProgram(t){const e={config:t};e.draw=t.draw,e.drawProxy=t.drawProxy,e.meta=Object.assign({},t.meta),t.width&&t.height&&(e.inputWidth=t.width,e.inputHeight=t.height,e.inputDataSize=t.width*t.height),e.output=t.output;const n=t.kernel;if(\"string\"!=typeof n||0==n.length)throw new Error(\"Kernel code cannot be empty.\");const a=t.inputs||[],o=t.uniforms||{};this._prepareProgramInputs(e,a);let s=\"\";for(const t in a)s+=`uniform sampler2D _input${t};\\n`;if(void 0===e.inputWidth||void 0===e.inputHeight)throw new Error(\"Unknown kernel size. You must provide either an input or the `width` and `height` parameters in the kernel config.\");e.uniformTextures={},e.uniforms={};for(const t in o){const n=o[t];if(\"number\"==typeof n)e.uniforms[t]={type:\"float\",value:n},s+=`uniform float ${t};\\n`;else if(Array.isArray(n)){if(n.length<2||n.length>4)throw new Error(\"Array uniforms can only have lengths of 2, 3, or 4 elements (corresponding to vec2, vec3, and vec4).\");const i=[\"vec2\",\"vec3\",\"vec4\"][n.length-2];e.uniforms[t]={type:i,value:n},s+=`uniform ${i} ${t};\\n`}else{const{type:i,width:a,height:o,channels:r,data:l,value:c,length:p,name:u,...h}=n;if(\"texture\"==i||\"outputTexture\"==i||\"sharedTexture\"==i){let n,i;\"3D\"==h.textureType?(n=this.gl.TEXTURE_3D,i=\"sampler3D\"):\"2DArray\"==h.textureType?(n=this.gl.TEXTURE_2D_ARRAY,i=\"sampler2DArray\"):(n=this.gl.TEXTURE_2D,i=\"sampler2D\"),e.uniformTextures[t]=\"texture\"==i?{target:n,texture:l?this._createTexture(l,a,o,r,h):null}:{target:n,texture:null,name:u||t},s+=`uniform ${i} ${t};\\n`}else e.uniforms[t]={type:i,value:c},s+=void 0!==p?`uniform ${i} ${t}[${p}];\\n`:`uniform ${i} ${t};\\n`}}const r=this.gl.createShader(this.gl.VERTEX_SHADER);if(this.gl.shaderSource(r,t.vertexShader||i),this.gl.compileShader(r),!this.gl.getShaderParameter(r,this.gl.COMPILE_STATUS))throw new Error(\"Could not build internal vertex shader (fatal).\\n\\n--- CODE DUMP ---\\n\"+i+\"\\n\\n--- ERROR LOG ---\\n\"+this.gl.getShaderInfoLog(r));const l=`\\nvoid main() {\\n  kernelOut = vec4(kernel(${[...Array(a.length).keys()].map(t=>`texture(_input${t}, kernelPosition)`).join(\", \")}));\\n}\\n    `,c=this.gl.createShader(this.gl.FRAGMENT_SHADER),p=\"#version 300 es\\nprecision highp float;\\nprecision highp int;\\nprecision highp sampler2D;\\nprecision highp sampler2DArray;\\nprecision highp sampler3D;\\nprecision highp samplerCube;\\n\\nin vec2 kernelPosition;\\nout vec4 kernelOut;\\nuniform ivec2 kernelSize;\\n\"+s+n+l;if(this.gl.shaderSource(c,p),this.gl.compileShader(c),!this.gl.getShaderParameter(c,this.gl.COMPILE_STATUS)){const t=p.split(\"\\n\");let e=\"ERROR: Could not build shader (fatal).\\n\\n------------------ KERNEL CODE DUMP ------------------\\n\";for(let n=0;n<t.length;n++)e+=`${n+1}> ${t[n]}\\n`;throw e+=\"\\n--------------------- ERROR  LOG ---------------------\\n\"+this.gl.getShaderInfoLog(c),new Error(e)}if(e.glProgram=this.gl.createProgram(),this.gl.attachShader(e.glProgram,r),this.gl.attachShader(e.glProgram,c),this.gl.linkProgram(e.glProgram),this.gl.useProgram(e.glProgram),!this.gl.getProgramParameter(e.glProgram,this.gl.LINK_STATUS))throw new Error(\"Failed to link GLSL program code.\");let u=0;for(const t of e.inputTextures){const t=this.gl.getUniformLocation(e.glProgram,`_input${u}`);this.gl.uniform1i(t,u),u++}for(const t in e.uniformTextures){e.uniformTextures[t].index=u;const n=this.gl.getUniformLocation(e.glProgram,t);this.gl.uniform1i(n,u),u++}for(const t in e.uniforms){const{type:n,value:i}=e.uniforms[t],a=e.uniforms[t].location=this.gl.getUniformLocation(e.glProgram,t);void 0!==i&&this._setUniform(n,a,i),delete e.uniforms[t].value}return e.kernelSizeLocation=this.gl.getUniformLocation(e.glProgram,\"kernelSize\"),this.gl.uniform2i(e.kernelSizeLocation,e.inputWidth,e.inputHeight),e.positionLocation=this.gl.getAttribLocation(e.glProgram,\"position\"),e.textureLocation=this.gl.getAttribLocation(e.glProgram,\"texture\"),e.frameBuffer=this.gl.createFramebuffer(),this._prepareProgramOutput(e),e}_prepareProgramInputs(t,e){t.inputTextures=[];for(const[n,i]of e.entries()){if(void 0===i.gpgpuSize||void 0===i.gpgpuStride)throw new Error(\"GPGPU inputs must be created by the `alloc` function.\");const e=Math.sqrt(i.length/i.gpgpuStride);if(e<=0||e%1!=0)throw new Error(\"GPGPU input size is expected to be a perfect square.\");if(void 0===t.inputWidth||void 0===t.inputHeight)t.inputWidth=e,t.inputHeight=e,t.inputDataSize=i.gpgpuSize;else if(e!=t.inputWidth||e!=t.inputHeight)throw new Error(`All GPGPU inputs must be of the same size. Received ${i.gpgpuSize} (internal ${e*e}) but expected ${t.inputDataSize} (internal ${t.inputWidth*t.inputHeight}).`);t.inputTextures.push(this._createTexture(i,e,e,i.gpgpuStride))}}_prepareProgramOutput(t){this.gl.bindFramebuffer(this.gl.FRAMEBUFFER,t.frameBuffer);const e=this._createTexture(null,t.inputWidth,t.inputHeight,4,t.output);if(this.gl.framebufferTexture2D(this.gl.FRAMEBUFFER,this.gl.COLOR_ATTACHMENT0,this.gl.TEXTURE_2D,e,0),this.gl.checkFramebufferStatus(this.gl.FRAMEBUFFER)!=this.gl.FRAMEBUFFER_COMPLETE)throw new Error(\"Error attaching float texture to framebuffer. Your device is probably incompatible.\");t.output&&t.output.name&&(this.outputTextures[t.output.name]=e)}_setUniform(t,e,n){switch(t){case\"int\":this.gl.uniform1i(e,n);break;case\"float\":Array.isArray(n)?this.gl.uniform1fv(e,n):this.gl.uniform1f(e,n);break;case\"vec2\":this.gl.uniform2fv(e,n);break;case\"vec3\":this.gl.uniform3fv(e,n);break;case\"vec4\":this.gl.uniform4fv(e,n);break;case\"mat3\":this.gl.uniformMatrix3fv(e,n);break;default:throw new Error(`Unknown uniform type ${t}.`)}}_newBuffer(t,e,n){const i=this.gl.createBuffer();return this.gl.bindBuffer(n||this.gl.ARRAY_BUFFER,i),this.gl.bufferData(n||this.gl.ARRAY_BUFFER,new(e||Float32Array)(t),this.gl.STATIC_DRAW),i}_createTexture(t,e,n,i,a={}){const o=this.gl.createTexture();let s,r;switch(i){case 1:s=this.gl.R32F,r=this.gl.RED;break;case 2:s=this.gl.RG32F,r=this.gl.RG;break;case 3:s=this.gl.RGB32F,r=this.gl.RGB;break;case 4:s=this.gl.RGBA32F,r=this.gl.RGBA;break;default:throw\"Texture channels must between 1 and 4.\"}const l=\"3D\"==a.textureType?this.gl.TEXTURE_3D:\"2DArray\"==a.textureType?this.gl.TEXTURE_2D_ARRAY:this.gl.TEXTURE_2D;return this.gl.bindTexture(l,o),this.gl.texParameteri(l,this.gl.TEXTURE_WRAP_S,this.gl.CLAMP_TO_EDGE),this.gl.texParameteri(l,this.gl.TEXTURE_WRAP_T,this.gl.CLAMP_TO_EDGE),this.gl.texParameteri(l,this.gl.TEXTURE_MIN_FILTER,\"linear\"==a.filter?this.gl.LINEAR:this.gl.NEAREST),this.gl.texParameteri(l,this.gl.TEXTURE_MAG_FILTER,\"linear\"==a.filter?this.gl.LINEAR:this.gl.NEAREST),\"3D\"==a.textureType||\"2DArray\"==a.textureType?this.gl.texImage3D(l,0,s,e,n,a.depth,0,r,this.gl.FLOAT,t):this.gl.texImage2D(l,0,s,e,n,0,r,this.gl.FLOAT,t),this.gl.bindTexture(l,null),o}}(t)}plan(t,e){const n=t.sampleStations(0,Math.ceil(H.spatialHorizon/H.stationInterval)+1,H.stationInterval),i={pos:n[0].pos.clone().sub(n[1].pos).normalize().multiplyScalar(10).add(n[0].pos),rot:n[0].rot,curv:0,dCurv:0,ddCurv:0,speed:0},a=function({pos:t,rot:e}){const n=new THREE.Matrix3;n.set(1,0,-t.x,0,1,-t.y,0,0,1);const i=Math.cos(e),a=Math.sin(e),o=new THREE.Matrix3;return o.set(i,a,0,-a,i,0,0,0,1),o.multiply(n)}(i),o=n.map(t=>({pos:t.pos.clone().applyMatrix3(a),rot:t.rot-i.rot,curv:t.curv})),s=new Float32Array(3*o.length),r=new THREE.Vector2(0,0),l=new THREE.Vector2(0,0);for(let t=0;t<o.length;t++){const e=o[t],n=e.pos;s[3*t+0]=n.x,s[3*t+1]=n.y,s[3*t+2]=e.rot,r.max(n),l.min(n)}const c=r.clone().sub(l),p=l.clone().add(r).divideScalar(2),u=Math.ceil((c.x+2*H.gridMargin)/H.xyGridCellSize),h=Math.ceil((c.y+2*H.gridMargin)/H.xyGridCellSize),d=new THREE.Vector2(H.spatialHorizon/2,0),f=Math.ceil(H.spatialHorizon/H.slGridCellSize),m=Math.ceil((H.laneWidth+2*H.gridMargin)/H.slGridCellSize);for(const[t,n]of[v.update(H,u,h,p,a,e),_(H,f,m,d,p),...E(H,f,m),P(H,u,h,p),...L(H,i),G(H,i),...F(H,i,p,d),B(H,i,p,d)].entries())this.gpgpu.updateProgram(t,n);const y=this._buildLattice(t,i.rot,a);this.gpgpu.updateSharedTextures({centerline:{width:o.length,height:1,channels:3,filter:\"linear\",data:s},lattice:{width:H.lattice.numLatitudes,height:H.lattice.numStations,channels:4,data:y},costTable:{width:64,height:H.lattice.numLatitudes,depth:H.lattice.numStations,channels:4,textureType:\"2DArray\"}});let g=performance.now();const x=this.gpgpu.run();console.log(`Planner GPU time: ${(performance.now()-g)/1e3}s`);const S=this.gpgpu._graphSearchCostTable,T=x[5],A=x[6],R=x[7];let b,C=[Number.POSITIVE_INFINITY];const I=S.length/4;for(let t=0;t<I;t++){const e=this._unpackCostTableIndex(t),n=[S[4*t],S[4*t+1],S[4*t+2],S[4*t+3]];n[0]<0||(n[0]+=this._terminalCost(e,n),n[0]<C[0]&&(b=t,C=n))}const O=(new THREE.Matrix3).getInverse(a),w=this._reconstructTrajectory(b,S,T,A,R,i.curv,y).map(t=>({pos:t.pos.applyMatrix3(O),rot:t.rot+i.rot,curv:t.curv}));return{xysl:x[4],width:u,height:h,center:p.applyMatrix3(O),rot:i.rot,path:w,vehiclePose:i}}_buildLattice(t,e,n){const i=H.spatialHorizon/H.lattice.numStations,a=t.sampleStations(i,H.lattice.numStations,i),o=Math.floor(H.lattice.numLatitudes/2),s=new Float32Array(H.lattice.numStations*H.lattice.numLatitudes*4);let r=0;for(let t=0;t<H.lattice.numStations;t++){const i=a[t];for(let t=0;t<H.lattice.numLatitudes;t++){const a=(t-o)/o*H.laneWidth/2,l=i.rot-e,c=THREE.Vector2.fromAngle(l+Math.PI/2).multiplyScalar(a).add(i.pos.clone().applyMatrix3(n)),p=0==i.curv?0:1/(1/i.curv-a);s[r++]=c.x,s[r++]=c.y,s[r++]=l,s[r++]=p}}return s}_terminalCost([t,e,n,i,a],[o,s,r,l]){if(t!=H.lattice.numStations-1&&s>.05)return Number.POSITIVE_INFINITY;const c=H.spatialHorizon/H.lattice.numStations*(t+1);return H.stationReachDiscount*c+H.extraTimePenalty*r}_unpackCostTableIndex(t){if(t<0)return[-1,t+2,null,null,null];const e=64*H.lattice.numLatitudes,n=Math.floor(t/e);t-=n*e;const i=Math.floor(t/64);t-=64*i;const a=Math.floor(t/32);return t-=32*a,[n,i,a,Math.floor(t/8),t%8]}_reconstructTrajectory(t,e,n,i,a,o,s){let r=this._unpackCostTableIndex(t);const l=[r];let c=0;for(;r[0]>=0&&c++<100;)t=e[4*t+3],r=this._unpackCostTableIndex(t),l.unshift(r);if(c>=100)throw new Error(\"Infinite loop encountered while reconstructing trajectory.\");const p=[];for(let t=0;t<l.length-1;t++){const[e,r]=l[t],[c,u]=l[t+1];let h,d;if(e<0){const t={pos:new THREE.Vector2(0,0),rot:0,curv:o},e=4*(c*H.lattice.numLatitudes+u),n={pos:new THREE.Vector2(s[e],s[e+1]),rot:s[e+2],curv:s[e+3]};0==r?(h=i[e+2],d=new f(t,n,{p1:i[e],p2:i[e+1],sG:h})):(h=a[e+2],d=new m(t,n,{p3:a[e],p4:a[e+1],sG:h}))}else{const t=4*(e*H.lattice.numLatitudes+r),i=4*(c*H.lattice.numLatitudes+u),a={pos:new THREE.Vector2(s[t],s[t+1]),rot:s[t+2],curv:s[t+3]},o={pos:new THREE.Vector2(s[i],s[i+1]),rot:s[i+2],curv:s[i+3]},l=c*H.lattice.numLatitudes+u,p=4*(((e-c+H.lattice.stationConnectivity)*H.lattice.latitudeConnectivity+r-u+Math.floor(H.lattice.latitudeConnectivity/2))*H.lattice.numStations*H.lattice.numLatitudes+l);h=n[p+2],d=new f(a,o,{p1:n[p],p2:n[p+1],sG:h})}const y=d.buildPath(Math.ceil(h/H.pathSamplingStep));t<l.length-2&&y.pop(),p.push(...y)}return p}}).config=H,console.log(\"WEB WORKER!\")}])},function(t,e,n){!function(){var t=new Error('Cannot find module \"src/Path*utput\"');throw t.code=\"MODULE_NOT_FOUND\",t}(),t.exports=n(0)}]);","extractedComments":[]}