{"code":"!function(t){var e={};function n(i){if(e[i])return e[i].exports;var a=e[i]={i:i,l:!1,exports:{}};return t[i].call(a.exports,a,a.exports,n),a.l=!0,a.exports}n.m=t,n.c=e,n.d=function(t,e,i){n.o(t,e)||Object.defineProperty(t,e,{configurable:!1,enumerable:!0,get:i})},n.r=function(t){Object.defineProperty(t,\"__esModule\",{value:!0})},n.n=function(t){var e=t&&t.__esModule?function(){return t.default}:function(){return t};return n.d(e,\"a\",e),e},n.o=function(t,e){return Object.prototype.hasOwnProperty.call(t,e)},n.p=\"\",n(n.s=14)}([function(t,e,n){\"use strict\";n.d(e,\"f\",function(){return i}),n.d(e,\"d\",function(){return a}),n.d(e,\"e\",function(){return o}),n.d(e,\"a\",function(){return s}),n.d(e,\"c\",function(){return r}),n.d(e,\"b\",function(){return l}),n.d(e,\"g\",function(){return c}),n.d(e,\"h\",function(){return u});const i=\"\\n\\nconst float smallV = 0.01;\\nvec4 pathSamples[128];\\nfloat pathSampleCurvRates[128];\\n\\nfloat calculateAcceleration(int index, float initialVelocitySq, float distance) {\\n  if (index <= 4) {\\n    // [aMaxHard, aMinHard, aMaxSoft, aMinSoft, 0]\\n    return accelerationProfiles[index];\\n  } else {\\n    float finalVelocity = finalVelocityProfiles[index - 5];\\n    return clamp((finalVelocity * finalVelocity - initialVelocitySq) / (2.0 * distance), accelerationProfiles[1], accelerationProfiles[0]);\\n  }\\n}\\n\\nfloat sampleStaticCost(vec4 xytk) {\\n  vec2 xyTexCoords = (xytk.xy - xyCenterPoint) / vec2(textureSize(xyslMap, 0)) / vec2(xyGridCellSize) + 0.5;\\n  vec2 sl = texture(xyslMap, xyTexCoords).xy;\\n\\n  vec2 slTexCoords = (sl - slCenterPoint) / vec2(textureSize(slObstacleGrid, 0)) / vec2(slGridCellSize) + 0.5;\\n  float obstacleCost = texture(slObstacleGrid, slTexCoords).x;\\n\\n  if (obstacleCost == 1.0) return -1.0; // Infinite cost\\n  obstacleCost = step(0.25, obstacleCost) * obstacleHazardCost;\\n\\n  float absLatitude = abs(sl.y);\\n  float laneCost = max(absLatitude * laneCostSlope, step(laneShoulderLatitude, absLatitude) * laneShoulderCost);\\n\\n  return obstacleCost + laneCost;\\n}\\n\\nfloat sampleDynamicCost(vec4 xytk, float time, float velocity, float acceleration) {\\n  return 1.0;\\n}\\n\\nfloat calculateAverageStaticCost(int numSamples) {\\n  float averageStaticCost = 0.0;\\n\\n  for (int i = 0; i < numSamples; i++) {\\n    float cost = sampleStaticCost(pathSamples[i]);\\n\\n    if (cost < 0.0) return cost;\\n\\n    averageStaticCost += cost;\\n  }\\n\\n  return averageStaticCost / float(numSamples);\\n}\\n\\nfloat calculateAverageDynamicCost(int numSamples, float pathLength, float initialVelocity, float acceleration) {\\n  float s = 0.0;\\n  float ds = pathLength / float(numSamples - 1);\\n  float averageDynamicCost = 0.0;\\n  float maxVelocity = 0.0;\\n  float maxLateralAcceleration = 0.0;\\n\\n  for (int i = 0; i < numSamples; i++) {\\n    vec4 pathSample = pathSamples[i]; // vec4(x-pos, y-pos, theta (rotation), kappa (curvature))\\n\\n    float velocitySq = 2.0 * acceleration * s + initialVelocity * initialVelocity;\\n    float velocity = max(smallV, sqrt(max(0.0, velocitySq)));\\n    maxVelocity = max(maxVelocity, velocity);\\n    maxLateralAcceleration = max(maxLateralAcceleration, abs(pathSample.w * velocity * velocity));\\n\\n    float time = 2.0 * s / (initialVelocity + velocity);\\n\\n    float dCurv = pathSampleCurvRates[i] * velocity;\\n    if (dCurv > dCurvatureMax) return -1.0;\\n\\n    float cost = sampleDynamicCost(pathSample, time, velocity, acceleration);\\n    if (cost < 0.0) return cost;\\n\\n    averageDynamicCost += cost;\\n    s += ds;\\n  }\\n\\n  averageDynamicCost /= float(numSamples);\\n\\n  // Apply speeding penality if any velocity along the trajectory is over the speed limit\\n  averageDynamicCost += step(speedLimit, maxVelocity) * speedLimitPenalty;\\n\\n  // Apply hard acceleration/deceleration penalties if the acceleration/deceleration exceeds the soft limits\\n  averageDynamicCost += step(accelerationProfiles[2] + 0.0001, acceleration) * hardAccelerationPenalty;\\n  averageDynamicCost += (1.0 - step(accelerationProfiles[3], acceleration)) * hardDecelerationPenalty;\\n\\n  // Penalize lateral acceleration\\n  averageDynamicCost += step(lateralAccelerationLimit, maxLateralAcceleration) * softLateralAccelerationPenalty;\\n  averageDynamicCost += linearLateralAccelerationPenalty * maxLateralAcceleration;\\n\\n  return averageDynamicCost;\\n}\\n\\nvec3 calculateAVT(int accelerationIndex, float initialVelocity, float initialTime, float pathLength) {\\n  float initialVelocitySq = initialVelocity * initialVelocity;\\n  float acceleration = calculateAcceleration(accelerationIndex, initialVelocitySq, pathLength);\\n\\n  float finalVelocitySq = 2.0 * acceleration * pathLength + initialVelocitySq;\\n  float finalVelocity = max(smallV, sqrt(max(0.0, finalVelocitySq)));\\n\\n  float finalTime = initialTime;\\n\\n  if (acceleration == 0.0) {\\n    finalTime += pathLength / finalVelocity;\\n  } else if (finalVelocitySq <= 0.0) { // Calculate final time if the vehicle stops before the end of the trajectory\\n    float distanceLeft = pathLength - (smallV * smallV - initialVelocitySq) / (2.0 * acceleration);\\n    finalTime += (finalVelocity - initialVelocity) / acceleration + distanceLeft / smallV;\\n  } else {\\n    finalTime += 2.0 * pathLength / (finalVelocity + initialVelocity);\\n  }\\n\\n  return vec3(acceleration, finalVelocity, finalTime);\\n}\\n\\n\",a=\"\\n\\nint sampleCubicPath(vec4 start, vec4 end, vec4 cubicPathParams) {\\n  float p0 = start.w;\\n  float p1 = cubicPathParams.x;\\n  float p2 = cubicPathParams.y;\\n  float p3 = end.w;\\n  float sG = cubicPathParams.z;\\n\\n  int numSamples = int(ceil(sG / pathSamplingStep)) + 1;\\n\\n  float sG_2 = sG * sG;\\n  float sG_3 = sG_2 * sG;\\n\\n  float a = p0;\\n  float b = (-5.5 * p0 + 9.0 * p1 - 4.5 * p2 + p3) / sG;\\n  float c = (9.0 * p0 - 22.5 * p1 + 18.0 * p2 - 4.5 * p3) / sG_2;\\n  float d = (-4.5 * (p0 - 3.0 * p1 + 3.0 * p2 - p3)) / sG_3;\\n\\n  pathSamples[0] = start;\\n\\n  float ds = sG / float(numSamples - 1);\\n  float s = ds;\\n  vec2 dxy = vec2(0);\\n  vec2 prevCosSin = vec2(cos(start.z), sin(start.z));\\n\\n  for (int i = 1; i < numSamples; i++) {\\n    float rot = (((d * s / 4.0 + c / 3.0) * s + b / 2.0) * s + a) * s + start.z;\\n    float curv = ((d * s + c) * s + b) * s + a;\\n\\n    vec2 cosSin = vec2(cos(rot), sin(rot));\\n    dxy = dxy * vec2(float(i - 1) / float(i)) + (cosSin + prevCosSin) / vec2(2 * i);\\n\\n    pathSamples[i] = vec4(dxy * vec2(s) + start.xy, rot, curv);\\n    pathSampleCurvRates[i] = b + s * (2.0 * c + 3.0 * d * s);\\n\\n    s += ds;\\n    prevCosSin = cosSin;\\n  }\\n\\n  return numSamples;\\n}\\n\\n\",o=\"\\n\\nint sampleQuinticPath(vec4 start, vec4 end, vec4 quinticPathParams) {\\n  float p0 = start.w;\\n  float p1 = dCurvVehicle;\\n  float p2 = ddCurvVehicle;\\n  float p3 = quinticPathParams.x;\\n  float p4 = quinticPathParams.y;\\n  float p5 = end.w;\\n  float sG = quinticPathParams.z;\\n\\n  int numSamples = int(ceil(sG / pathSamplingStep)) + 1;\\n\\n  float sG_2 = sG * sG;\\n  float sG_3 = sG_2 * sG;\\n\\n  float a = p0;\\n  float b = p1;\\n  float c = p2 / 2.0;\\n  float d = (-71.875 * p0 + 81.0 * p3 - 10.125 * p4 + p5 - 21.25 * p1 * sG - 2.75 * p2 * sG_2) / sG_3;\\n  float e = (166.5 * p0 - 202.5 * p3 + 40.5 * p4 - 4.5 * p5 + 45.0 * p1 * sG + 4.5 * p2 * sG_2) / (sG_2 * sG_2);\\n  float f = (-95.625 * p0 + 121.5 * p3 - 30.375 * p4 + 4.5 * p5 - 24.75 * p1 * sG - 2.25 * p2 * sG_2) / (sG_2 * sG_3);\\n\\n  pathSamples[0] = start;\\n\\n  float ds = sG / float(numSamples - 1);\\n  float s = ds;\\n  vec2 dxy = vec2(0);\\n  vec2 prevCosSin = vec2(cos(start.z), sin(start.z));\\n\\n  for (int i = 1; i < numSamples; i++) {\\n    float rot = (((((f * s / 6.0 + e / 5.0) * s + d / 4.0) * s + c / 3.0) * s + b / 2.0) * s + a) * s + start.z;\\n    float curv = ((((f * s + e) * s + d) * s + c) * s + b) * s + a;\\n\\n    vec2 cosSin = vec2(cos(rot), sin(rot));\\n    dxy = dxy * vec2(float(i - 1) / float(i)) + (cosSin + prevCosSin) / vec2(2 * i);\\n\\n    pathSamples[i] = vec4(dxy * vec2(s) + start.xy, rot, curv);\\n    pathSampleCurvRates[i] = b + s * (2.0 * c + s * (3.0 * d + s * (4.0 * e + 5.0 * f * s)));\\n\\n    s += ds;\\n    prevCosSin = cosSin;\\n  }\\n\\n  return numSamples;\\n}\\n\\n\",s=8,r=4,l=2,c={xyslMap:{type:\"outputTexture\"},slObstacleGrid:{type:\"outputTexture\",name:\"slObstacleGridDilated\"},accelerationProfiles:{type:\"float\",length:5},finalVelocityProfiles:{type:\"float\",length:3},xyCenterPoint:{type:\"vec2\"},xyGridCellSize:{type:\"float\"},slCenterPoint:{type:\"vec2\"},slGridCellSize:{type:\"float\"},laneCostSlope:{type:\"float\"},laneShoulderCost:{type:\"float\"},laneShoulderLatitude:{type:\"float\"},obstacleHazardCost:{type:\"float\"},speedLimit:{type:\"float\"},speedLimitPenalty:{type:\"float\"},hardAccelerationPenalty:{type:\"float\"},hardDecelerationPenalty:{type:\"float\"},lateralAccelerationLimit:{type:\"float\"},softLateralAccelerationPenalty:{type:\"float\"},linearLateralAccelerationPenalty:{type:\"float\"},dCurvatureMax:{type:\"float\"},pathSamplingStep:{type:\"float\"}};function u(t,e,n){return{accelerationProfiles:[3.5,-6.5,2,-3,0],finalVelocityProfiles:[.99*t.speedLimit,1,.01],xyCenterPoint:[e.x,e.y],xyGridCellSize:t.xyGridCellSize,slCenterPoint:[n.x,n.y],slGridCellSize:t.slGridCellSize,laneCostSlope:t.laneCostSlope,laneShoulderCost:t.laneShoulderCost,laneShoulderLatitude:t.laneShoulderLatitude,obstacleHazardCost:t.obstacleHazardCost,speedLimit:t.speedLimit,speedLimitPenalty:t.speedLimitPenalty,hardAccelerationPenalty:t.hardAccelerationPenalty,hardDecelerationPenalty:t.hardDecelerationPenalty,lateralAccelerationLimit:t.lateralAccelerationLimit,softLateralAccelerationPenalty:t.softLateralAccelerationPenalty,linearLateralAccelerationPenalty:t.linearLateralAccelerationPenalty,dCurvatureMax:t.dCurvatureMax,pathSamplingStep:t.pathSamplingStep}}},function(t,e,n){\"use strict\";(function(t){n.d(e,\"a\",function(){return i});class i{constructor(t,e=0,n=0,i=0){this.world=t,this.setPose(e,n,i)}static getFrontAxlePosition(e,n){return t.Vector2.fromAngle(n).multiplyScalar(i.WHEEL_BASE).add(e)}static getFakeAxlePosition(t,e){return i.frontToRearAxlePosition(t,e)}static centerToRearAxlePosition(e,n){return t.Vector2.fromAngle(n).multiplyScalar(i.REAR_AXLE_POS).add(e)}static frontToRearAxlePosition(e,n){return t.Vector2.fromAngle(n).multiplyScalar(-i.WHEEL_BASE).add(e)}get pose(){const e=this.rearAxlePosition;return{pos:new t.Vector2(e[0],e[1]),rot:this.rotation}}get position(){const t=this.body.GetPosition();return[t.get_x(),t.get_y()]}get rearAxlePosition(){const[t,e]=this.position,n=this.rotation;return[t+Math.cos(n)*i.REAR_AXLE_POS,e+Math.sin(n)*i.REAR_AXLE_POS]}get frontAxlePosition(){const[t,e]=this.position,n=this.rotation;return[t+Math.cos(n)*i.FRONT_AXLE_POS,e+Math.sin(n)*i.FRONT_AXLE_POS]}get rotation(){return this.body.GetAngle()}get speed(){return this.body.GetLinearVelocity().Length()}get wheelAngle(){return Math.wrapAngle(this.leftFrontWheel.joint.GetJointAngle())}setPose(t,e,n){this.destroyBodies(),t-=i.REAR_AXLE_POS*Math.cos(n),e-=i.REAR_AXLE_POS*Math.sin(n);const a=new Box2D.b2Vec2(t,e),r=new Box2D.b2BodyDef;r.set_type(Box2D.b2_dynamicBody),r.set_position(a),r.set_angle(n),this.body=this.world.CreateBody(r),this.body.SetAngularDamping(i.ANGULAR_DAMPING);const l=new Box2D.b2PolygonShape;l.SetAsBox(i.HALF_CAR_LENGTH,i.HALF_CAR_WIDTH);const c=new Box2D.b2FixtureDef;c.set_shape(l),c.set_density(i.CHASSIS_DENSITY),c.set_friction(i.FRICTION),c.set_restitution(i.RESTITUTION),this.body.CreateFixture(c);const u=new Box2D.b2Vec2(i.FRONT_AXLE_POS,i.WHEEL_LATERAL_POS),p=new Box2D.b2Vec2(i.FRONT_AXLE_POS,-i.WHEEL_LATERAL_POS),h=new Box2D.b2Vec2(i.REAR_AXLE_POS,i.WHEEL_LATERAL_POS),d=new Box2D.b2Vec2(i.REAR_AXLE_POS,-i.WHEEL_LATERAL_POS);this.leftFrontWheel=s.call(this,u,a,n),this.rightFrontWheel=s.call(this,p,a,n),this.leftRearWheel=o.call(this,h,a,n),this.rightRearWheel=o.call(this,d,a,n),Box2D.destroy(a),Box2D.destroy(r),Box2D.destroy(l),Box2D.destroy(c),Box2D.destroy(u),Box2D.destroy(p),Box2D.destroy(h),Box2D.destroy(d)}destroyBodies(){this.body&&(this.world.DestroyBody(this.body),this.body=null,this.world.DestroyBody(this.leftFrontWheel.body),this.leftFrontWheel=null,this.world.DestroyBody(this.rightFrontWheel.body),this.rightFrontWheel=null,this.world.DestroyBody(this.leftRearWheel.body),this.leftRearWheel=null,this.world.DestroyBody(this.rightRearWheel.body),this.rightRearWheel=null)}update(t,e){const n=Math.clamp(t.gas,-1,1),a=Math.clamp(t.brake,0,1),o=Math.clamp(t.steer,-1,1),s=this.body.GetMass(),r=this.body.GetLinearVelocity(),l=this.body.GetAngle();let c=r.LengthSquared(),u=r.Length();const p=.5*i.DRAG_COEFF*i.FRONTAL_AREA*i.DENSITY_OF_AIR*u;let h=new Box2D.b2Vec2(0,0),d=new Box2D.b2Vec2(0,0);if(a>0)if(u>.1)d.op_add(r),d.op_mul(i.MAX_BRAKE_DECEL*s*a),d.op_mul(1/u);else{const t=new Box2D.b2Vec2(0,0);this.body.SetLinearVelocity(t),r.Set(0,0),c=0,u=0,Box2D.destroy(t)}else{const t=i.MAX_GAS_ACCEL*s*n;Box2D.destroy(h),h=new Box2D.b2Vec2(t*Math.cos(l),t*Math.sin(l))}const f=new Box2D.b2Vec2(0,0);f.op_sub(r),f.op_mul(p+i.ROLL_RESIST),f.op_add(h),f.op_sub(d),this.body.ApplyForceToCenter(f);const m=Math.clamp(Math.atan(i.MAX_LATERAL_ACCEL*i.WHEEL_BASE/this.body.GetLinearVelocity().LengthSquared()),.07,i.MAX_WHEEL_ANGLE);let y;this.leftFrontWheel.joint.SetLimits(-m,m),this.rightFrontWheel.joint.SetLimits(-m,m);const g=this.leftFrontWheel.joint.GetJointAngle();y=0!=o?o*i.MAX_STEER_SPEED:Math.clamp(-g/i.MAX_WHEEL_ANGLE*c*e,-i.MAX_STEER_SPEED,i.MAX_STEER_SPEED),this.leftFrontWheel.joint.SetMotorSpeed(y),this.rightFrontWheel.joint.SetMotorSpeed(y),[\"leftFrontWheel\",\"rightFrontWheel\",\"leftRearWheel\",\"rightRearWheel\"].forEach(t=>{const n=this[t].body,a=n.GetLinearVelocity(),o=n.GetLocalVector(a),s=new Box2D.b2Vec2(0,-i.LATERAL_DAMPING*o.get_y()),r=new Box2D.b2Vec2(0,0);r.op_add(n.GetWorldVector(s)),r.op_mul(e),r.op_add(a),n.SetLinearVelocity(r),Box2D.destroy(s),Box2D.destroy(r)}),Box2D.destroy(h),Box2D.destroy(d),Box2D.destroy(f)}}function a(t,e,n){const a=Math.cos(n),o=Math.sin(n),s=new Box2D.b2Vec2(a*t.get_x()-o*t.get_y()+e.get_x(),o*t.get_x()+a*t.get_y()+e.get_y()),r=new Box2D.b2BodyDef;r.set_type(Box2D.b2_dynamicBody),r.set_position(s),r.set_angle(n);const l=this.world.CreateBody(r),c=new Box2D.b2PolygonShape;c.SetAsBox(i.HALF_WHEEL_LENGTH,i.HALF_WHEEL_WIDTH);const u=new Box2D.b2FixtureDef;return u.set_shape(c),u.set_density(i.WHEEL_DENSITY),u.set_friction(i.FRICTION),u.set_restitution(i.RESTITUTION),l.CreateFixture(u),Box2D.destroy(s),Box2D.destroy(r),Box2D.destroy(c),Box2D.destroy(u),l}function o(t,e,n){const i=a.call(this,t,e,n),o=new Box2D.b2Vec2(0,0),s=new Box2D.b2WeldJointDef;s.set_bodyA(this.body),s.set_bodyB(i),s.set_localAnchorA(t),s.set_localAnchorB(o);const r=Box2D.castObject(this.world.CreateJoint(s),Box2D.b2WeldJoint);return Box2D.destroy(o),Box2D.destroy(s),{body:i,joint:r}}function s(t,e,n){const o=a.call(this,t,e,n),s=new Box2D.b2Vec2(0,0),r=new Box2D.b2RevoluteJointDef;r.set_bodyA(this.body),r.set_bodyB(o),r.set_localAnchorA(t),r.set_localAnchorB(s),r.set_enableMotor(!0),r.set_motorSpeed(0),r.set_maxMotorTorque(i.MAX_WHEEL_MOTOR_TORQUE),r.set_enableLimit(!0),r.set_lowerAngle(-i.MAX_WHEEL_ANGLE),r.set_upperAngle(i.MAX_WHEEL_ANGLE);const l=Box2D.castObject(this.world.CreateJoint(r),Box2D.b2RevoluteJoint);return Box2D.destroy(s),Box2D.destroy(r),{body:o,joint:l}}i.HALF_CAR_LENGTH=2.5,i.HALF_CAR_WIDTH=1,i.CHASSIS_DENSITY=1600/9.2,i.HALF_WHEEL_LENGTH=.33,i.HALF_WHEEL_WIDTH=.12,i.WHEEL_DENSITY=250,i.MAX_WHEEL_MOTOR_TORQUE=1e3,i.MAX_WHEEL_ANGLE=32/180*Math.PI,i.ANGULAR_DAMPING=.3,i.FRICTION=.9,i.RESTITUTION=.1,i.DRAG_COEFF=.7,i.DENSITY_OF_AIR=1.8580608,i.FRONTAL_AREA=1.85,i.ROLL_RESIST=30,i.MAX_STEER_SPEED=1.2,i.MAX_GAS_ACCEL=3.5,i.MAX_BRAKE_DECEL=6.5,i.LATERAL_DAMPING=1e3,i.WHEEL_LATERAL_POS=.843,i.FRONT_AXLE_POS=1.56,i.REAR_AXLE_POS=-1.37,i.WHEEL_BASE=i.FRONT_AXLE_POS-i.REAR_AXLE_POS,i.MAX_LATERAL_ACCEL=9.81}).call(this,n(!function(){var t=new Error('Cannot find module \"../js/vendor/three.js\"');throw t.code=\"MODULE_NOT_FOUND\",t}()))},function(t,e,n){\"use strict\";var i=n(0);const a=i.f+i.d+i.e+\"\\n\\nvec4 kernel() {\\n  ivec2 indexes = ivec2(kernelPosition * vec2(kernelSize));\\n\\n  int latitude = indexes.y;\\n\\n  int numPerTime = numAccelerations * numVelocities;\\n  int timeIndex = indexes.x / numPerTime;\\n  indexes.x -= timeIndex * numPerTime;\\n  int velocityIndex = indexes.x / numAccelerations;\\n  int accelerationIndex = int(mod(float(indexes.x), float(numAccelerations)));\\n\\n  int minLatitude = max(latitude - latitudeConnectivity / 2, 0);\\n  int maxLatitude = min(latitude + latitudeConnectivity / 2, numLatitudes - 1);\\n\\n  int slIndex = station * numLatitudes + latitude;\\n\\n  vec4 pathEnd = texelFetch(lattice, ivec2(latitude, station), 0);\\n\\n  float minVelocity = velocityRanges[velocityIndex];\\n  float maxVelocity = velocityRanges[velocityIndex + 1];\\n\\n  float minTime = timeRanges[timeIndex];\\n  float maxTime = timeRanges[timeIndex + 1];\\n\\n  vec4 bestTrajectory = vec4(-1); // -1 means infinite cost\\n  float bestCost = 1000000000.0;\\n\\n  for (int prevStation = max(station - stationConnectivity, 0); prevStation < station; prevStation++) {\\n    int stationConnectivityIndex = prevStation - station + stationConnectivity;\\n\\n    for (int prevLatitude = minLatitude; prevLatitude <= maxLatitude; prevLatitude++) {\\n      int latitudeConnectivityIndex = prevLatitude - latitude + latitudeConnectivity / 2;\\n      int connectivityIndex = stationConnectivityIndex * latitudeConnectivity + latitudeConnectivityIndex;\\n\\n      vec4 pathStart = texelFetch(lattice, ivec2(prevLatitude, prevStation), 0);\\n      vec4 cubicPathParams = texelFetch(cubicPaths, ivec2(slIndex, connectivityIndex), 0);\\n\\n      // If the path didn't converge\\n      if (cubicPathParams.w == 0.0) continue;\\n\\n      int numSamples = sampleCubicPath(pathStart, pathEnd, cubicPathParams);\\n      float pathLength = cubicPathParams.z;\\n\\n      float averageStaticCost = calculateAverageStaticCost(numSamples);\\n      if (averageStaticCost < 0.0) continue;\\n\\n      for (int prevVelocity = 0; prevVelocity < numVelocities; prevVelocity++) {\\n        for (int prevTime = 0; prevTime < numTimes; prevTime++) {\\n          for (int prevAccel = 0; prevAccel < numAccelerations; prevAccel++) {\\n            int avtIndex = prevTime * numPerTime + prevVelocity * numAccelerations + prevAccel;\\n\\n            // Cost table entry:\\n            //   x: cost so far\\n            //   y: end speed\\n            //   z: end time\\n            //   w: parent index\\n            vec4 costTableEntry = texelFetch(costTable, ivec3(avtIndex, prevLatitude, prevStation), 0);\\n\\n            // If cost entry is infinity\\n            if (costTableEntry.x < 0.0) continue;\\n\\n            vec3 avt = calculateAVT(accelerationIndex, costTableEntry.y, costTableEntry.z, pathLength);\\n            float acceleration = avt.x;\\n            float finalVelocity = avt.y;\\n            float finalTime = avt.z;\\n\\n            // If the calculated final velocity does not match this fragment's velocity range, then skip this trajectory\\n            if (finalVelocity < minVelocity || finalVelocity >= maxVelocity) continue;\\n\\n            // If the calculated final time does not match this fragment's time range, then skip this trajectory\\n            if (finalTime < minTime || finalTime >= maxTime) continue;\\n\\n            float averageDynamicCost = calculateAverageDynamicCost(numSamples, pathLength, costTableEntry.y, acceleration);\\n            if (averageDynamicCost < 0.0) continue;\\n\\n            // The cost of a trajectory is the average sample cost scaled by the path length\\n            float totalCost = (averageStaticCost + averageDynamicCost) * pathLength + costTableEntry.x;\\n\\n            float terminalCost = totalCost + extraTimePenalty * finalTime;\\n            if (terminalCost >= bestCost) continue;\\n            bestCost = terminalCost;\\n\\n            int incomingIndex = avtIndex + numPerTime * numTimes * (prevLatitude + numLatitudes * prevStation);\\n            bestTrajectory = vec4(totalCost, finalVelocity, finalTime, incomingIndex);\\n          }\\n        }\\n      }\\n    }\\n  }\\n\\n  if (station < stationConnectivity) {\\n    ivec2 slaIndex = ivec2(latitude, station * numAccelerations + accelerationIndex);\\n\\n    vec4 costTableEntry = texelFetch(cubicPathFromVehicleCosts, slaIndex, 0);\\n    float terminalCost;\\n\\n    if (costTableEntry.x >= 0.0) {\\n      terminalCost = costTableEntry.x + extraTimePenalty * costTableEntry.z;\\n\\n      if (terminalCost < bestCost) {\\n        bestCost = terminalCost;\\n        bestTrajectory = costTableEntry;\\n      }\\n    }\\n\\n    costTableEntry = texelFetch(quinticPathFromVehicleCosts, slaIndex, 0);\\n\\n    if (costTableEntry.x >= 0.0) {\\n      terminalCost = costTableEntry.x + extraTimePenalty * costTableEntry.z;\\n\\n      if (terminalCost < bestCost) {\\n        bestCost = terminalCost;\\n        bestTrajectory = costTableEntry;\\n      }\\n    }\\n  }\\n\\n  return bestTrajectory;\\n}\\n\\n\";e.a={setUp:()=>({kernel:a,output:{name:\"graphSearch\"},uniforms:{...i.g,lattice:{type:\"sharedTexture\"},costTable:{type:\"sharedTexture\",textureType:\"2DArray\"},cubicPaths:{type:\"outputTexture\"},cubicPathFromVehicleCosts:{type:\"outputTexture\"},quinticPathFromVehicleCosts:{type:\"outputTexture\"},velocityVehicle:{type:\"float\"},curvVehicle:{type:\"float\"},dCurvVehicle:{type:\"float\"},ddCurvVehicle:{type:\"float\"},extraTimePenalty:{type:\"float\"},numStations:{type:\"int\"},numLatitudes:{type:\"int\"},numAccelerations:{type:\"int\"},numVelocities:{type:\"int\"},numTimes:{type:\"int\"},stationConnectivity:{type:\"int\"},latitudeConnectivity:{type:\"int\"},velocityRanges:{type:\"float\",length:i.c+1},timeRanges:{type:\"float\",length:i.b+1},station:{type:\"int\"}},drawProxy:(t,e,n)=>{const a=i.a*i.c*i.b,o=e.meta.lattice.numLatitudes,s=new Float32Array(a*o*e.meta.lattice.numStations*4);for(let i=0;i<e.meta.lattice.numStations;i++)t.updateProgramUniforms(e,{station:i}),n(),t.gl.readPixels(0,0,a,o,t.gl.RGBA,t.gl.FLOAT,s,i*a*o*4),t.gl.bindTexture(t.gl.TEXTURE_2D_ARRAY,t.sharedTextures.costTable),t.gl.copyTexSubImage3D(t.gl.TEXTURE_2D_ARRAY,0,0,0,i,0,0,a,o);t._graphSearchCostTable=s}}),update:(t,e,n,a)=>({width:i.a*i.c*i.b,height:t.lattice.numLatitudes,meta:{lattice:t.lattice},uniforms:{...Object(i.h)(t,n,a),velocityVehicle:e.speed,curvVehicle:e.curv,dCurvVehicle:e.dCurv,ddCurvVehicle:e.ddCurv,extraTimePenalty:t.extraTimePenalty,numStations:t.lattice.numStations,numLatitudes:t.lattice.numLatitudes,numAccelerations:i.a,numVelocities:i.c,numTimes:i.b,stationConnectivity:t.lattice.stationConnectivity,latitudeConnectivity:t.lattice.latitudeConnectivity,velocityRanges:[0,t.speedLimit/3,2*t.speedLimit/3,t.speedLimit,1e6],timeRanges:[0,10,1e6]}})}},function(t,e,n){\"use strict\";var i=n(0);function a(t){return i.f+(\"cubic\"==t?i.d:i.e)+`\\n\\n/* Calculate cost of a {cubic|quintic} path from vehicle to (stationConnectivity * numLatitudes * numAccelerations) nodes\\n *   width: numLatitudes\\n *   height: station * numAccelerations\\n */\\nvec4 kernel() {\\n  ivec2 indexes = ivec2(kernelPosition * vec2(kernelSize));\\n\\n  int latitude = indexes.x;\\n  int station = indexes.y / numAccelerations;\\n  int accelerationIndex = int(mod(float(indexes.y), float(numAccelerations)));\\n\\n  vec4 pathStart = vec4(0, 0, 0, curvVehicle);\\n  vec4 pathEnd = texelFetch(lattice, ivec2(latitude, station), 0);\\n\\n  vec4 pathParams = texelFetch(pathsFromVehicle, ivec2(latitude, station), 0);\\n\\n  // If the path didn't converge\\n  if (pathParams.w == 0.0) return vec4(-1);\\n\\n  int numSamples = ${\"cubic\"==t?\"sampleCubicPath\":\"sampleQuinticPath\"}(pathStart, pathEnd, pathParams);\\n  float pathLength = pathParams.z;\\n\\n  float averageStaticCost = calculateAverageStaticCost(numSamples);\\n  if (averageStaticCost < 0.0) return vec4(-1);\\n\\n  vec3 avt = calculateAVT(accelerationIndex, velocityVehicle, 0.0, pathLength);\\n  float acceleration = avt.x;\\n  float finalVelocity = avt.y;\\n  float finalTime = avt.z;\\n\\n  float averageDynamicCost = calculateAverageDynamicCost(numSamples, pathLength, velocityVehicle, acceleration);\\n  if (averageDynamicCost < 0.0) return vec4(-1);\\n\\n  // The cost of a trajectory is the average sample cost scaled by the path length\\n  float totalCost = (averageStaticCost + averageDynamicCost + ${\"cubic\"==t?\"(cubicPathPenalty * velocityVehicle * velocityVehicle)\":\"0.0\"}) * pathLength;\\n\\n  return vec4(totalCost, finalVelocity, finalTime, ${\"cubic\"==t?\"-2\":\"-1\"});\\n}\\n\\n`}e.a={setUp:()=>[{kernel:a(\"cubic\"),output:{name:\"cubicPathFromVehicleCosts\"},uniforms:{...i.g,lattice:{type:\"sharedTexture\"},pathsFromVehicle:{type:\"outputTexture\",name:\"cubicPathsFromVehicle\"},velocityVehicle:{type:\"float\"},curvVehicle:{type:\"float\"},numAccelerations:{type:\"int\"},cubicPathPenalty:{type:\"float\"}}},{kernel:a(\"quintic\"),output:{name:\"quinticPathFromVehicleCosts\"},uniforms:{...i.g,lattice:{type:\"sharedTexture\"},pathsFromVehicle:{type:\"outputTexture\",name:\"quinticPathsFromVehicle\"},velocityVehicle:{type:\"float\"},curvVehicle:{type:\"float\"},dCurvVehicle:{type:\"float\"},ddCurvVehicle:{type:\"float\"},numAccelerations:{type:\"int\"}}}],update:(t,e,n,a)=>[{width:t.lattice.numLatitudes,height:t.lattice.stationConnectivity*i.a,uniforms:{...Object(i.h)(t,n,a),velocityVehicle:e.speed,curvVehicle:e.curv,numAccelerations:i.a,cubicPathPenalty:t.cubicPathPenalty}},{width:t.lattice.numLatitudes,height:t.lattice.stationConnectivity*i.a,uniforms:{...Object(i.h)(t,n,a),velocityVehicle:e.speed,curvVehicle:e.curv,dCurvVehicle:e.dCurv,ddCurvVehicle:e.ddCurv,numAccelerations:i.a}}]}},function(t,e,n){\"use strict\";e.a={setUp:()=>({kernel:\"\\n\\nconst int NEWTON_ITERATIONS = 16;\\nconst int RELAXATION_ITERATIONS = 16;\\nconst float CONVERGENCE_ERROR = 0.01;\\n\\n// These two consts must stay in sync.\\nconst int SIMPSONS_INTERVALS = 8;\\nconst float SIMPSONS_COEFFS[SIMPSONS_INTERVALS + 1] = float[](1.0, 4.0, 2.0, 4.0, 2.0, 4.0, 2.0, 4.0, 1.0);\\n\\nconst float PI = 3.1415926535897932384626433832795;\\nconst float TWO_PI = PI + PI;\\n\\nconst float RELAXATION_ITERATIONS_F = float(RELAXATION_ITERATIONS);\\nconst float SIMPSONS_INTERVALS_F = float(SIMPSONS_INTERVALS);\\n\\nfloat wrapAngle(float angle) {\\n  angle = mod(angle, TWO_PI);\\n  if (angle <= -PI) return angle + TWO_PI;\\n  else if (angle > PI) return angle - TWO_PI;\\n  return angle;\\n}\\n\\nvec4 iterate(vec4 goal, float p0, float p1, float p2, float p3, float p4, float p5, float sG) {\\n  float ds = sG / SIMPSONS_INTERVALS_F;\\n  float sG_2 = sG * sG;\\n  float sG_3 = sG_2 * sG;\\n\\n  vec3 dX_p = vec3(0.0);\\n  vec3 dY_p = vec3(0.0);\\n  vec2 guess = vec2(0.0);\\n  float s = 0.0;\\n\\n  float theta, cosTheta, sinTheta;\\n  vec3 dT_p;\\n\\n  for (int i = 0; i <= SIMPSONS_INTERVALS; i++) {\\n    float coeff = SIMPSONS_COEFFS[i];\\n\\n    float a = p0;\\n    float b = p1;\\n    float c = p2 / 2.0;\\n    float d = (-71.875 * p0 + 81.0 * p3 - 10.125 * p4 + p5 - 21.25 * p1 * sG - 2.75 * p2 * sG_2) / sG_3;\\n    float e = (166.5 * p0 - 202.5 * p3 + 40.5 * p4 - 4.5 * p5 + 45.0 * p1 * sG + 4.5 * p2 * sG_2) / (sG_2 * sG_2);\\n    float f = (-95.625 * p0 + 121.5 * p3 - 30.375 * p4 + 4.5 * p5 - 24.75 * p1 * sG - 2.25 * p2 * sG_2) / (sG_2 * sG_3);\\n\\n    theta = (((((f * s / 6.0 + e / 5.0) * s + d / 4.0) * s + c / 3.0) * s + b / 2.0) * s + a) * s;\\n    cosTheta = cos(theta);\\n    sinTheta = sin(theta);\\n\\n    float s_2 = s * s;\\n    float s_sG = s / sG;\\n    float s_sG_2 = s_sG * s_sG;\\n    float s_sG_3 = s_sG_2 * s_sG;\\n    float s_sG_4 = s_sG_3 * s_sG;\\n    float s_sG_5 = s_sG_4 * s_sG;\\n\\n    dT_p = vec3(\\n      // p3\\n      ((20.25 * s_sG - 40.5) * s_sG + 20.25) * s_sG_3 * s,\\n\\n      // p4\\n      ((-5.0625 * s_sG + 8.1) * s_sG - 2.53125) * s_sG_3 * s,\\n\\n      // sG\\n      (53.90625 * p0 - 60.75 * p3 + 7.59375 * p4 - 0.75 * p5) * s_sG_4 + 10.625 * p1 * s * s_sG_3 + 0.6875 * p2 * s_2 * s_sG_2 + (-133.2 * p0 + 162.0 * p3 - 32.4 * p4 + 3.6 * p5) * s_sG_5 + (-27.0) * p1 * s * s_sG_4 - 1.8 * p2 * s_2 * s_sG_3 + (79.6875 * p0 - 101.25 * p3 + 25.3125 * p4 - 3.75 * p5) * s_sG_5 * s_sG + 16.5 * p1 * s * s_sG_5 + 1.125 * p2 * s_2 * s_sG_4\\n    );\\n\\n    dX_p -= coeff * sinTheta * dT_p;\\n    dY_p += coeff * cosTheta * dT_p;\\n\\n    guess += coeff * vec2(cosTheta, sinTheta);\\n\\n    s += ds;\\n  }\\n\\n  float hOver3 = sG / SIMPSONS_INTERVALS_F / 3.0;\\n\\n  vec3 delta;\\n  delta.xy = goal.xy - guess * hOver3;\\n  delta.z = wrapAngle(goal.z - theta);\\n\\n  if (abs(delta.x) + abs(delta.y) + abs(delta.z) < CONVERGENCE_ERROR)\\n    return vec4(p3, p4, sG, 1.0);\\n\\n  dX_p.xyz *= hOver3;\\n  dY_p.xyz *= hOver3;\\n  dX_p.z += cosTheta;\\n  dY_p.z += sinTheta;\\n\\n  mat3 invJacobian = inverse(transpose(mat3(dX_p, dY_p, dT_p)));\\n\\n  vec3 deltaP = invJacobian * delta;\\n  vec4 params = vec4(p3, p4, sG, 0.0);\\n  params.xyz += deltaP;\\n\\n  return params;\\n}\\n\\nvec4 optimize(vec4 start, vec4 end) {\\n  // Translate and rotate start and end so that start is at the origin\\n  float sinRot = sin(start.z);\\n  float cosRot = cos(start.z);\\n\\n  vec4 diff = end - start;\\n  vec4 goal;\\n  goal.xy = mat2(cosRot, -sinRot, sinRot, cosRot) * diff.xy;\\n  goal.z = wrapAngle(diff.z);\\n  goal.w = end.w;\\n\\n  vec4 originalGoal = goal;\\n  vec4 dGoal;\\n  dGoal.x = 0.0;\\n  dGoal.yzw = goal.yzw / RELAXATION_ITERATIONS_F;\\n  float d_K0 = start.w / RELAXATION_ITERATIONS_F;\\n  float d_dK0 = dCurvVehicle / RELAXATION_ITERATIONS_F;\\n  float d_ddK0 = ddCurvVehicle / RELAXATION_ITERATIONS_F;\\n\\n  // Relax the goal to (x, 0, 0, 0)\\n  goal.yzw = vec3(0, 0, 0);\\n\\n  // Relax the params to (0, 0, 0, 0, goal.x)\\n  float p0 = 0.0;\\n  float p1 = 0.0;\\n  float p2 = 0.0;\\n  float p3 = 0.0;\\n  float p4 = 0.0;\\n  float p5 = 0.0;\\n  float sG = goal.x;\\n\\n  for (int i = 0; i < RELAXATION_ITERATIONS; i++) {\\n    p0 += d_K0;\\n    p1 += d_dK0;\\n    p2 += d_ddK0;\\n    p5 += dGoal.w;\\n    goal += dGoal;\\n    \\n    vec4 result = iterate(goal, p0, p1, p2, p3, p4, p5, sG);\\n    p3 = result.x;\\n    p4 = result.y;\\n    sG = result.z;\\n  }\\n\\n  goal = originalGoal;\\n\\n  for (int i = 0; i < NEWTON_ITERATIONS; i++) {\\n    vec4 result = iterate(goal, p0, p1, p2, p3, p4, p5, sG);\\n    if (result.w == 1.0) return result;\\n\\n    p3 = result.x;\\n    p4 = result.y;\\n    sG = result.z;\\n  }\\n\\n  return vec4(p3, p4, sG, 0.0);\\n}\\n\\nvec4 kernel() {\\n  ivec2 latticeIndexes = ivec2(kernelPosition * vec2(kernelSize));\\n\\n  vec4 start = vec4(0, 0, 0, curvVehicle);\\n  vec4 end = texelFetch(lattice, latticeIndexes, 0);\\n\\n  return optimize(start, end);\\n}\\n\\n\",output:{name:\"quinticPathsFromVehicle\",read:!0},uniforms:{lattice:{type:\"sharedTexture\"},curvVehicle:{type:\"float\"},dCurvVehicle:{type:\"float\"},ddCurvVehicle:{type:\"float\"}}}),update:(t,e)=>({width:t.lattice.numLatitudes,height:t.lattice.stationConnectivity,uniforms:{curvVehicle:e.curv,dCurvVehicle:e.dCurv,ddCurvVehicle:e.ddCurv}})}},function(t,e,n){\"use strict\";e.a={setUp:()=>[{kernel:\"\\n\\nconst int NEWTON_ITERATIONS = 16;\\nconst int RELAXATION_ITERATIONS = 16;\\nconst float CONVERGENCE_ERROR = 0.01;\\n\\n// These two consts must stay in sync.\\nconst int SIMPSONS_INTERVALS = 8;\\n//const float SIMPSONS_COEFFS[SIMPSONS_INTERVALS + 1] = float[](1.0, 4.0, 2.0, 4.0, 2.0, 4.0, 2.0, 4.0, 2.0, 4.0, 2.0, 4.0, 2.0, 4.0, 2.0, 4.0, 1.0);\\nconst float SIMPSONS_COEFFS[SIMPSONS_INTERVALS + 1] = float[](1.0, 4.0, 2.0, 4.0, 2.0, 4.0, 2.0, 4.0, 1.0);\\n\\nconst float PI = 3.1415926535897932384626433832795;\\nconst float TWO_PI = PI + PI;\\n\\nconst float RELAXATION_ITERATIONS_F = float(RELAXATION_ITERATIONS);\\nconst float SIMPSONS_INTERVALS_F = float(SIMPSONS_INTERVALS);\\n\\nfloat wrapAngle(float angle) {\\n  angle = mod(angle, TWO_PI);\\n  if (angle <= -PI) return angle + TWO_PI;\\n  else if (angle > PI) return angle - TWO_PI;\\n  return angle;\\n}\\n\\nvec4 iterate(vec4 goal, float p0, float p1, float p2, float p3, float sG) {\\n  float ds = sG / SIMPSONS_INTERVALS_F;\\n  float sG_2 = sG * sG;\\n  float sG_3 = sG_2 * sG;\\n\\n  vec3 dX_p = vec3(0.0);\\n  vec3 dY_p = vec3(0.0);\\n  vec2 guess = vec2(0.0);\\n  float s = 0.0;\\n\\n  float theta, cosTheta, sinTheta;\\n  vec3 dT_p;\\n\\n  for (int i = 0; i <= SIMPSONS_INTERVALS; i++) {\\n    float coeff = SIMPSONS_COEFFS[i];\\n\\n    float a = p0;\\n    float b = (-5.5 * p0 + 9.0 * p1 - 4.5 * p2 + p3) / sG;\\n    float c = (9.0 * p0 - 22.5 * p1 + 18.0 * p2 - 4.5 * p3) / sG_2;\\n    float d = (-4.5 * (p0 - 3.0 * p1 + 3.0 * p2 - p3)) / sG_3;\\n\\n    theta = (((d * s / 4.0 + c / 3.0) * s + b / 2.0) * s + a) * s;\\n    cosTheta = cos(theta);\\n    sinTheta = sin(theta);\\n\\n    float s_sG = s / sG;\\n\\n    dT_p = vec3(\\n      // p1\\n      ((3.375 * s_sG - 7.5) * s_sG + 4.5) * s_sG * s,\\n\\n      // p2\\n      ((-3.375 * s_sG + 6.0) * s_sG - 2.25) * s_sG * s,\\n\\n      // sG\\n      ((3.375 * (p0 - 3.0 * p1 + 3.0 * p2 - p3) * s_sG - 3.0 * (2.0 * p0 - 5.0 * p1 + 4.0 * p2 - p3)) * s_sG + 0.25 * (11.0 * p0 - 18.0 * p1 + 9.0 * p2 - 2.0 * p3)) * s_sG * s_sG\\n    );\\n\\n    dX_p -= coeff * sinTheta * dT_p;\\n    dY_p += coeff * cosTheta * dT_p;\\n\\n    guess += coeff * vec2(cosTheta, sinTheta);\\n\\n    s += ds;\\n  }\\n\\n  float hOver3 = sG / SIMPSONS_INTERVALS_F / 3.0;\\n\\n  vec3 delta;\\n  delta.xy = goal.xy - guess * hOver3;\\n  delta.z = wrapAngle(goal.z - theta);\\n\\n  if (abs(delta.x) + abs(delta.y) + abs(delta.z) < CONVERGENCE_ERROR)\\n    return vec4(p1, p2, sG, 1.0);\\n\\n  dX_p.xyz *= hOver3;\\n  dY_p.xyz *= hOver3;\\n  dX_p.z += cosTheta;\\n  dY_p.z += sinTheta;\\n\\n  mat3 invJacobian = inverse(transpose(mat3(dX_p, dY_p, dT_p)));\\n\\n  vec3 deltaP = invJacobian * delta;\\n  vec4 params = vec4(p1, p2, sG, 0.0);\\n  params.xyz += deltaP;\\n\\n  return params;\\n}\\n\\n/* Input:\\n *   start: (vec4)\\n *     x: x position,\\n *     y: y position,\\n *     z: theta rotation,\\n *     w: k curvature\\n *   end: (vec4)\\n *     x: x position,\\n *     y: y position,\\n *     z: theta rotation,\\n *     w: k curvature\\n *\\n * Output: (vec4)\\n *   x: p1,\\n *   y: p2,\\n *   z: sG,\\n *   w: 1 if converged, 0 if not\\n */\\n\\nvec4 optimize(vec4 start, vec4 end) {\\n  // Translate and rotate start and end so that start is at the origin\\n  float sinRot = sin(start.z);\\n  float cosRot = cos(start.z);\\n\\n  vec4 diff = end - start;\\n  vec4 goal;\\n  goal.xy = mat2(cosRot, -sinRot, sinRot, cosRot) * diff.xy;\\n  goal.z = wrapAngle(diff.z);\\n  goal.w = end.w;\\n\\n  vec4 originalGoal = goal;\\n  vec4 dGoal;\\n  dGoal.x = 0.0;\\n  dGoal.yzw = goal.yzw / RELAXATION_ITERATIONS_F;\\n  float dK0 = start.w / RELAXATION_ITERATIONS_F;\\n\\n  // Relax the goal to (x, 0, 0, 0)\\n  goal.yzw = vec3(0, 0, 0);\\n\\n  // Relax the params to (0, 0, 0, 0, goal.x)\\n  float p0 = 0.0;\\n  float p1 = 0.0;\\n  float p2 = 0.0;\\n  float p3 = 0.0;\\n  float sG = goal.x;\\n\\n  for (int i = 0; i < RELAXATION_ITERATIONS; i++) {\\n    p0 += dK0;\\n    p3 += dGoal.w;\\n    goal += dGoal;\\n    \\n    vec4 result = iterate(goal, p0, p1, p2, p3, sG);\\n    p1 = result.x;\\n    p2 = result.y;\\n    sG = result.z;\\n  }\\n\\n  goal = originalGoal;\\n\\n  for (int i = 0; i < NEWTON_ITERATIONS; i++) {\\n    vec4 result = iterate(goal, p0, p1, p2, p3, sG);\\n    if (result.w == 1.0) return result;\\n\\n    p1 = result.x;\\n    p2 = result.y;\\n    sG = result.z;\\n  }\\n\\n  return vec4(p1, p2, sG, 0.0);\\n}\\n\\n\\n\\n// width: station * latitude index\\n// height: station_conn * lattice_conn\\n//\\n// lattice:\\n// width: latitudes\\n// height: stations\\n\\nvec4 kernel() {\\n  ivec2 indexes = ivec2(kernelPosition * vec2(kernelSize));\\n\\n  int endStation = indexes.x / numLatitudes;\\n  int endLatitude = int(mod(float(indexes.x), float(numLatitudes)));\\n\\n  int startStation = endStation - stationConnectivity + indexes.y / latitudeConnectivity;\\n  int startLatitude = endLatitude - latitudeConnectivity / 2 + int(mod(float(indexes.y), float(latitudeConnectivity)));\\n\\n  if (startStation < 0 || startStation >= numStations || startLatitude < 0 || startLatitude >= numLatitudes)\\n    return vec4(0.0);\\n\\n  vec4 start = texelFetch(lattice, ivec2(startLatitude, startStation), 0);\\n  vec4 end = texelFetch(lattice, ivec2(endLatitude, endStation), 0);\\n\\n  return optimize(start, end);\\n}\\n\\n\",output:{name:\"cubicPaths\",read:!0},uniforms:{lattice:{type:\"sharedTexture\"},numStations:{type:\"int\"},numLatitudes:{type:\"int\"},stationConnectivity:{type:\"int\"},latitudeConnectivity:{type:\"int\"}}},{kernel:\"\\n\\nconst int NEWTON_ITERATIONS = 16;\\nconst int RELAXATION_ITERATIONS = 16;\\nconst float CONVERGENCE_ERROR = 0.01;\\n\\n// These two consts must stay in sync.\\nconst int SIMPSONS_INTERVALS = 8;\\n//const float SIMPSONS_COEFFS[SIMPSONS_INTERVALS + 1] = float[](1.0, 4.0, 2.0, 4.0, 2.0, 4.0, 2.0, 4.0, 2.0, 4.0, 2.0, 4.0, 2.0, 4.0, 2.0, 4.0, 1.0);\\nconst float SIMPSONS_COEFFS[SIMPSONS_INTERVALS + 1] = float[](1.0, 4.0, 2.0, 4.0, 2.0, 4.0, 2.0, 4.0, 1.0);\\n\\nconst float PI = 3.1415926535897932384626433832795;\\nconst float TWO_PI = PI + PI;\\n\\nconst float RELAXATION_ITERATIONS_F = float(RELAXATION_ITERATIONS);\\nconst float SIMPSONS_INTERVALS_F = float(SIMPSONS_INTERVALS);\\n\\nfloat wrapAngle(float angle) {\\n  angle = mod(angle, TWO_PI);\\n  if (angle <= -PI) return angle + TWO_PI;\\n  else if (angle > PI) return angle - TWO_PI;\\n  return angle;\\n}\\n\\nvec4 iterate(vec4 goal, float p0, float p1, float p2, float p3, float sG) {\\n  float ds = sG / SIMPSONS_INTERVALS_F;\\n  float sG_2 = sG * sG;\\n  float sG_3 = sG_2 * sG;\\n\\n  vec3 dX_p = vec3(0.0);\\n  vec3 dY_p = vec3(0.0);\\n  vec2 guess = vec2(0.0);\\n  float s = 0.0;\\n\\n  float theta, cosTheta, sinTheta;\\n  vec3 dT_p;\\n\\n  for (int i = 0; i <= SIMPSONS_INTERVALS; i++) {\\n    float coeff = SIMPSONS_COEFFS[i];\\n\\n    float a = p0;\\n    float b = (-5.5 * p0 + 9.0 * p1 - 4.5 * p2 + p3) / sG;\\n    float c = (9.0 * p0 - 22.5 * p1 + 18.0 * p2 - 4.5 * p3) / sG_2;\\n    float d = (-4.5 * (p0 - 3.0 * p1 + 3.0 * p2 - p3)) / sG_3;\\n\\n    theta = (((d * s / 4.0 + c / 3.0) * s + b / 2.0) * s + a) * s;\\n    cosTheta = cos(theta);\\n    sinTheta = sin(theta);\\n\\n    float s_sG = s / sG;\\n\\n    dT_p = vec3(\\n      // p1\\n      ((3.375 * s_sG - 7.5) * s_sG + 4.5) * s_sG * s,\\n\\n      // p2\\n      ((-3.375 * s_sG + 6.0) * s_sG - 2.25) * s_sG * s,\\n\\n      // sG\\n      ((3.375 * (p0 - 3.0 * p1 + 3.0 * p2 - p3) * s_sG - 3.0 * (2.0 * p0 - 5.0 * p1 + 4.0 * p2 - p3)) * s_sG + 0.25 * (11.0 * p0 - 18.0 * p1 + 9.0 * p2 - 2.0 * p3)) * s_sG * s_sG\\n    );\\n\\n    dX_p -= coeff * sinTheta * dT_p;\\n    dY_p += coeff * cosTheta * dT_p;\\n\\n    guess += coeff * vec2(cosTheta, sinTheta);\\n\\n    s += ds;\\n  }\\n\\n  float hOver3 = sG / SIMPSONS_INTERVALS_F / 3.0;\\n\\n  vec3 delta;\\n  delta.xy = goal.xy - guess * hOver3;\\n  delta.z = wrapAngle(goal.z - theta);\\n\\n  if (abs(delta.x) + abs(delta.y) + abs(delta.z) < CONVERGENCE_ERROR)\\n    return vec4(p1, p2, sG, 1.0);\\n\\n  dX_p.xyz *= hOver3;\\n  dY_p.xyz *= hOver3;\\n  dX_p.z += cosTheta;\\n  dY_p.z += sinTheta;\\n\\n  mat3 invJacobian = inverse(transpose(mat3(dX_p, dY_p, dT_p)));\\n\\n  vec3 deltaP = invJacobian * delta;\\n  vec4 params = vec4(p1, p2, sG, 0.0);\\n  params.xyz += deltaP;\\n\\n  return params;\\n}\\n\\n/* Input:\\n *   start: (vec4)\\n *     x: x position,\\n *     y: y position,\\n *     z: theta rotation,\\n *     w: k curvature\\n *   end: (vec4)\\n *     x: x position,\\n *     y: y position,\\n *     z: theta rotation,\\n *     w: k curvature\\n *\\n * Output: (vec4)\\n *   x: p1,\\n *   y: p2,\\n *   z: sG,\\n *   w: 1 if converged, 0 if not\\n */\\n\\nvec4 optimize(vec4 start, vec4 end) {\\n  // Translate and rotate start and end so that start is at the origin\\n  float sinRot = sin(start.z);\\n  float cosRot = cos(start.z);\\n\\n  vec4 diff = end - start;\\n  vec4 goal;\\n  goal.xy = mat2(cosRot, -sinRot, sinRot, cosRot) * diff.xy;\\n  goal.z = wrapAngle(diff.z);\\n  goal.w = end.w;\\n\\n  vec4 originalGoal = goal;\\n  vec4 dGoal;\\n  dGoal.x = 0.0;\\n  dGoal.yzw = goal.yzw / RELAXATION_ITERATIONS_F;\\n  float dK0 = start.w / RELAXATION_ITERATIONS_F;\\n\\n  // Relax the goal to (x, 0, 0, 0)\\n  goal.yzw = vec3(0, 0, 0);\\n\\n  // Relax the params to (0, 0, 0, 0, goal.x)\\n  float p0 = 0.0;\\n  float p1 = 0.0;\\n  float p2 = 0.0;\\n  float p3 = 0.0;\\n  float sG = goal.x;\\n\\n  for (int i = 0; i < RELAXATION_ITERATIONS; i++) {\\n    p0 += dK0;\\n    p3 += dGoal.w;\\n    goal += dGoal;\\n    \\n    vec4 result = iterate(goal, p0, p1, p2, p3, sG);\\n    p1 = result.x;\\n    p2 = result.y;\\n    sG = result.z;\\n  }\\n\\n  goal = originalGoal;\\n\\n  for (int i = 0; i < NEWTON_ITERATIONS; i++) {\\n    vec4 result = iterate(goal, p0, p1, p2, p3, sG);\\n    if (result.w == 1.0) return result;\\n\\n    p1 = result.x;\\n    p2 = result.y;\\n    sG = result.z;\\n  }\\n\\n  return vec4(p1, p2, sG, 0.0);\\n}\\n\\n\\n\\nvec4 kernel() {\\n  ivec2 indexes = ivec2(kernelPosition * vec2(kernelSize));\\n\\n  vec4 start = vec4(0, 0, 0, curvVehicle);\\n  vec4 end = texelFetch(lattice, indexes, 0);\\n\\n  return optimize(start, end);\\n}\\n\\n\",output:{name:\"cubicPathsFromVehicle\",read:!0},uniforms:{lattice:{type:\"sharedTexture\"},curvVehicle:{type:\"float\"}}}],update:(t,e)=>[{width:t.lattice.numStations*t.lattice.numLatitudes,height:t.lattice.stationConnectivity*t.lattice.latitudeConnectivity,uniforms:{numStations:t.lattice.numStations,numLatitudes:t.lattice.numLatitudes,stationConnectivity:t.lattice.stationConnectivity,latitudeConnectivity:t.lattice.latitudeConnectivity}},{width:t.lattice.numLatitudes,height:t.lattice.stationConnectivity,uniforms:{curvVehicle:e.curv}}]}},function(t,e,n){\"use strict\";e.a={setUp:()=>({kernel:\"\\n\\nvec4 kernel() {\\n  vec2 xy = (kernelPosition - 0.5) * vec2(kernelSize) * vec2(xyGridCellSize) + xyCenterPoint;\\n\\n  int numSamples = textureSize(centerline, 0).x;\\n  int closest = 0;\\n  float closestDist = distance(xy, texelFetch(centerline, ivec2(0, 0), 0).xy);\\n  for (int i = 1; i < numSamples; i++) {\\n    float dist = distance(xy, texelFetch(centerline, ivec2(i, 0), 0).xy);\\n    if (dist < closestDist) {\\n      closestDist = dist;\\n      closest = i;\\n    }\\n  }\\n\\n  vec2 closestPos = texelFetch(centerline, ivec2(closest, 0), 0).xy;\\n  vec2 prev, next;\\n  int prevIndex, nextIndex;\\n\\n  if (closest == 0) {\\n    prevIndex = 0;\\n    nextIndex = 1;\\n    prev = closestPos;\\n    next = texelFetch(centerline, ivec2(1, 0), 0).xy;\\n  } else if (closest == numSamples - 1) {\\n    prevIndex = closest - 1;\\n    nextIndex = closest;\\n    prev = texelFetch(centerline, ivec2(prevIndex, 0), 0).xy;\\n    next = closestPos;\\n  } else {\\n    vec2 before = texelFetch(centerline, ivec2(closest - 1, 0), 0).xy;\\n    vec2 after = texelFetch(centerline, ivec2(closest + 1, 0), 0).xy;\\n\\n    if (distance(before, xy) < distance(after, xy)) {\\n      prevIndex = closest - 1;\\n      nextIndex = closest;\\n      prev = before;\\n      next = closestPos;\\n    } else {\\n      prevIndex = closest;\\n      nextIndex = closest + 1;\\n      prev = closestPos;\\n      next = after;\\n    }\\n  }\\n\\n  float dist = distance(prev, next);\\n  float progress = clamp(dot(xy - prev, next - prev) / dist / dist, 0.0, 1.0);\\n  vec2 projectedPos = (next - prev) * vec2(progress) + prev;\\n\\n  return vec4(\\n    (float(prevIndex) + progress) * stationInterval,\\n    sign(determinant(mat2(next - prev, xy - prev))) * distance(xy, projectedPos),\\n    0,\\n    0\\n  );\\n}\\n\\n\",output:{name:\"xyslMap\",filter:\"linear\"},uniforms:{centerline:{type:\"sharedTexture\"},xyCenterPoint:{type:\"vec2\"},xyGridCellSize:{type:\"float\"},stationInterval:{type:\"float\"}}}),update:(t,e,n,i,a)=>({width:e,height:n,uniforms:{xyCenterPoint:[i.x,i.y],xyGridCellSize:t.xyGridCellSize,stationInterval:t.stationInterval}})}},function(t,e,n){\"use strict\";const i=\"\\n\\n// TODO: test performance of returning early if non-zero pixel found\\nvec4 kernel() {\\n  float val = 0.0;\\n\\n  for (int d = 0; d <= lethalDilation; d++) {\\n    val = max(val, texture(slObstacleGrid, kernelPosition + delta * vec2(d)).r);\\n    val = max(val, texture(slObstacleGrid, kernelPosition + delta * vec2(-d)).r);\\n  }\\n\\n  for (int d = lethalDilation + 1; d <= lethalDilation + hazardDilation; d++) {\\n    val = max(val, texture(slObstacleGrid, kernelPosition + delta * vec2(d)).r * 0.5);\\n    val = max(val, texture(slObstacleGrid, kernelPosition + delta * vec2(-d)).r * 0.5);\\n  }\\n\\n  val = max(val, step(0.1, val) * 0.5);\\n\\n  return vec4(val, 0, 0, 1);\\n}\\n\\n\";e.a={setUp:()=>[{kernel:i,output:{name:\"slObstacleGridStationDilated\"},uniforms:{slObstacleGrid:{type:\"outputTexture\"},delta:{type:\"vec2\"},lethalDilation:{type:\"int\"},hazardDilation:{type:\"int\"}}},{kernel:i,output:{name:\"slObstacleGridDilated\"},uniforms:{slObstacleGrid:{type:\"outputTexture\",name:\"slObstacleGridStationDilated\"},delta:{type:\"vec2\"},lethalDilation:{type:\"int\"},hazardDilation:{type:\"int\"}}}],update:(t,e,n)=>[{width:e,height:n,uniforms:{delta:[1/e,0],lethalDilation:Math.ceil(t.lethalDilationS/t.slGridCellSize),hazardDilation:Math.ceil(t.hazardDilationS/t.slGridCellSize)}},{width:e,height:n,uniforms:{delta:[0,1/n],lethalDilation:Math.ceil(t.lethalDilationL/t.slGridCellSize),hazardDilation:Math.ceil(t.hazardDilationL/t.slGridCellSize)}}]}},function(t,e,n){\"use strict\";e.a={setUp:()=>({kernel:\"\\n\\nvec4 kernel() {\\n  float centerlineWidth = float(textureSize(centerline, 0).x);\\n\\n  vec2 sl = (kernelPosition - 0.5) * vec2(kernelSize) * vec2(slGridCellSize) + slCenterPoint;\\n  float centerlineCoord = sl.x / stationInterval / centerlineWidth * (centerlineWidth - 1.0) / centerlineWidth + (0.5 / centerlineWidth);\\n  if (centerlineCoord < 0.0 || centerlineCoord > 1.0) return vec4(0);\\n\\n  vec3 centerlineSample = texture(centerline, vec2(centerlineCoord, 0)).xyz;\\n  float perpindicular = centerlineSample.z + radians(90.0);\\n  vec2 xy = centerlineSample.xy + sl.yy * vec2(cos(perpindicular), sin(perpindicular));\\n\\n  vec2 xyTexCoords = (xy - xyCenterPoint) / vec2(textureSize(xyObstacleGrid, 0)) / vec2(xyGridCellSize) + 0.5;\\n  return texture(xyObstacleGrid, xyTexCoords);\\n}\\n\\n\",output:{name:\"slObstacleGrid\"},uniforms:{xyObstacleGrid:{type:\"outputTexture\"},slGridCellSize:{type:\"float\"},xyGridCellSize:{type:\"float\"},slCenterPoint:{type:\"vec2\"},xyCenterPoint:{type:\"vec2\"},stationInterval:{type:\"float\"},centerline:{type:\"sharedTexture\"}}}),update:(t,e,n,i,a)=>({width:e,height:n,uniforms:{slGridCellSize:t.slGridCellSize,xyGridCellSize:t.xyGridCellSize,slCenterPoint:[i.x,i.y],xyCenterPoint:[a.x,a.y],stationInterval:t.stationInterval}})}},function(t,e,n){\"use strict\";(function(t){let n,i;e.a={setUp:()=>({kernel:\"\\n  vec4 kernel() {\\n    return vec4(1, 0, 0, 1);\\n  }\\n\",vertexShader:\"#version 300 es\\nuniform mat3 xform;\\nin vec2 position;\\n\\nvoid main(void) {\\n  gl_Position = vec4((xform * vec3(position, 1)).xy, 0, 1);\\n}\\n\",output:{name:\"xyObstacleGrid\"},draw:(t,e)=>{t.clearColor(0,0,0,0),t.clear(t.COLOR_BUFFER_BIT),t.bindBuffer(t.ARRAY_BUFFER,t.createBuffer()),t.bufferData(t.ARRAY_BUFFER,n,t.STATIC_DRAW),t.enableVertexAttribArray(e.positionLocation),t.vertexAttribPointer(e.positionLocation,2,t.FLOAT,!1,0,0);const a=t.getUniformLocation(e.glProgram,\"xform\");t.uniformMatrix3fv(a,!1,i.elements),t.drawArrays(t.TRIANGLES,0,n.length/2)}}),update(e,a,o,s,r,l){n=new Float32Array(Array.prototype.concat.apply([],l.map(t=>t.vertices)));const c=new t.Matrix3;c.set(1,0,-s.x,0,1,-s.y,0,0,1);const u=new t.Matrix3;return u.set(2/(a*e.xyGridCellSize),0,0,0,2/(o*e.xyGridCellSize),0,0,0,1),i=u.multiply(c).multiply(r),{width:a,height:o}}}}).call(this,n(!function(){var t=new Error('Cannot find module \"../js/vendor/three.js\"');throw t.code=\"MODULE_NOT_FOUND\",t}()))},function(t,e,n){\"use strict\";(function(t){n.d(e,\"a\",function(){return c});const i=8,a=16,o=32,s=.01,r=new t.Matrix3,l=new t.Matrix3;class c{constructor(t,e,n=null){this.start=Object.assign({},t),this.end=Object.assign({},e),t.pos&&(this.start.x=t.pos.x,this.start.y=t.pos.y),e.pos&&(this.end.x=e.pos.x,this.end.y=e.pos.y);const i=this.end.x-this.start.x,a=this.end.y-this.start.y,o=Math.sin(this.start.rot),s=Math.cos(this.start.rot);this.goal={x:s*i+o*a,y:-o*i+s*a,rot:Math.wrapAngle(this.end.rot-this.start.rot),curv:this.end.curv},n?this.params=Object.assign({},n,{p0:this.start.curv,p3:this.end.curv}):this.guessInitialParams(),this.converged=!1}guessInitialParams(){const t=this.goal,e=this.start.curv/o,n=t.y/o,i=t.rot/o,a=t.curv/o;this.goal={x:t.x,y:0,rot:0,curv:0},this.params={p0:0,p1:0,p2:0,p3:0,sG:t.x};for(let t=0;t<o;t++)this.params.p0+=e,this.params.p3+=a,this.goal.y+=n,this.goal.rot+=i,this.goal.curv+=a,this.iterate();this.goal=t}optimize(){for(let t=0;t<a;t++)if(this.iterate())return this.converged=!0,!0;return this.converged=!1,!1}iterate(){const{p0:t,p1:e,p2:n,p3:a,sG:o}=this.params,c=o/i,u=o*o,p=u*o;let h,d,f,m,y,g,v=0,x=0,_=0,S=0,T=0,E=0,A=0,P=0;for(let s=0,r=0;s<=i;s++,r+=c){const l=0==s||s==i?1:s%2==0?2:4;h=(((-4.5*(t-3*e+3*n-a)/p*r/4+(9*t-22.5*e+18*n-4.5*a)/u/3)*r+(-5.5*t+9*e-4.5*n+a)/o/2)*r+t)*r,d=Math.cos(h);const c=r/o;v-=l*(f=Math.sin(h))*(m=((3.375*c-7.5)*c+4.5)*c*r),x-=l*f*(y=((-3.375*c+6)*c-2.25)*c*r),_-=l*f*(g=((3.375*(t-3*e+3*n-a)*c-3*(2*t-5*e+4*n-a))*c+.25*(11*t-18*e+9*n-2*a))*c*c),S+=l*d*m,T+=l*d*y,E+=l*d*g,A+=l*d,P+=l*f}const L=o/i/3,R=this.goal.x-A*L,b=this.goal.y-P*L,C=Math.wrapAngle(this.goal.rot-h);if(Math.abs(R)+Math.abs(b)+Math.abs(C)<s)return!0;r.set(v*L,x*L,d+_*L,S*L,T*L,f+E*L,m,y,g);const[G,I,O,w,D,N,V,F,M]=l.getInverse(r).elements;return this.params.p1+=G*R+w*b+V*C,this.params.p2+=I*R+D*b+F*C,this.params.sG+=O*R+N*b+M*C,!1}buildPath(e){const{p0:n,p1:i,p2:a,p3:o,sG:s}=this.params,r=s*s,l=n,c=(-5.5*n+9*i-4.5*a+o)/s,u=(9*n-22.5*i+18*a-4.5*o)/r,p=-4.5*(n-3*i+3*a-o)/(r*s),h=[{pos:new t.Vector2(this.start.x,this.start.y),rot:this.start.rot,curv:this.start.curv}],d=s/(e-1);let f=d,m=0,y=0,g=Math.cos(h[0].rot),v=Math.sin(h[0].rot);for(let n=1;n<e-1;n++){const e=(((p*f/4+u/3)*f+c/2)*f+l)*f+this.start.rot,i=((p*f+u)*f+c)*f+l,a=Math.cos(e),o=Math.sin(e);m=m*(n-1)/n+(a+g)/(2*n),y=y*(n-1)/n+(o+v)/(2*n),h.push({pos:new t.Vector2(f*m+this.start.x,f*y+this.start.y),rot:e,curv:i}),f+=d,g=a,v=o}return h.push({pos:new t.Vector2(this.end.x,this.end.y),rot:this.end.rot,curv:this.end.curv}),h}}}).call(this,n(!function(){var t=new Error('Cannot find module \"../js/vendor/three.js\"');throw t.code=\"MODULE_NOT_FOUND\",t}()))},function(t,e,n){\"use strict\";(function(t){n.d(e,\"a\",function(){return i});class i{constructor(t,e,n){this.start=Object.assign({},t),this.end=Object.assign({},e),t.pos&&(this.start.x=t.pos.x,this.start.y=t.pos.y),e.pos&&(this.end.x=e.pos.x,this.end.y=e.pos.y);const i=this.end.x-this.start.x,a=this.end.y-this.start.y,o=Math.sin(this.start.rot),s=Math.cos(this.start.rot);this.goal={x:s*i+o*a,y:-o*i+s*a,rot:Math.wrapAngle(this.end.rot-this.start.rot),curv:this.end.curv},this.params=Object.assign({},n,{p0:this.start.curv,p1:this.start.dCurv||0,p2:this.start.ddCurv||0,p5:this.end.curv})}buildPath(e){const{p0:n,p1:i,p2:a,p3:o,p4:s,p5:r,sG:l}=this.params,c=l*l,u=c*l,p=n,h=i,d=a/2,f=(-71.875*n+81*o-10.125*s+r-21.25*i*l-2.75*a*c)/u,m=(166.5*n-202.5*o+40.5*s-4.5*r+45*i*l+4.5*a*c)/(c*c),y=(-95.625*n+121.5*o-30.375*s+4.5*r-24.75*i*l-2.25*a*c)/(c*u),g=[{pos:new t.Vector2(this.start.x,this.start.y),rot:this.start.rot,curv:this.start.curv}],v=l/(e-1);let x=v,_=0,S=0,T=Math.cos(g[0].rot),E=Math.sin(g[0].rot);for(let n=1;n<e-1;n++){const e=(((((y*x/6+m/5)*x+f/4)*x+d/3)*x+h/2)*x+p)*x+this.start.rot,i=((((y*x+m)*x+f)*x+d)*x+h)*x+p,a=Math.cos(e),o=Math.sin(e);_=_*(n-1)/n+(a+T)/(2*n),S=S*(n-1)/n+(o+E)/(2*n),g.push({pos:new t.Vector2(x*_+this.start.x,x*S+this.start.y),rot:e,curv:i}),x+=v,T=a,E=o}return g.push({pos:new t.Vector2(this.end.x,this.end.y),rot:this.end.rot,curv:this.end.curv}),g}}}).call(this,n(!function(){var t=new Error('Cannot find module \"../js/vendor/three.js\"');throw t.code=\"MODULE_NOT_FOUND\",t}()))},function(t,e,n){\"use strict\";const i=\"#version 300 es\\nin vec2 position;\\nin vec2 texture;\\nout vec2 kernelPosition;\\n\\nvoid main(void) {\\n  kernelPosition = texture;\\n  gl_Position = vec4(position.xy, 0.0, 1.0);\\n}\\n\";e.a=class{static alloc(t,e){if(!Number.isInteger(e)||e<1||e>4)throw new Error(\"Data stride must be an integer between 1 and 4.\");const n=Math.pow(Math.ceil(Math.sqrt(t)),2),i=new Float32Array(n*e);return i.gpgpuSize=t,i.gpgpuStride=e,i}constructor(t,e={}){this._setUpGL(),this.outputTextures={},this.sharedTextures={},this.programs=t.map(t=>this._prepareProgram(t));for(const t in e){const{width:n,height:i,channels:a,data:o,...s}=e[t];this.sharedTextures[t]=this._createTexture(o,n,i,a,s)}}updateSharedTextures(t){this.sharedTextures={};for(const e in t){const{width:n,height:i,channels:a,data:o,...s}=t[e];this.sharedTextures[e]=this._createTexture(o,n,i,a,s)}}updateProgram(t,e){const n=\"number\"==typeof t?this.programs[t]:t;if(!n)throw new Error(`Program with index ${t} does not exist.`);if(e.inputs)throw new Error(\"The `updateProgram` function cannot be used to update inputs. Use `updateProgramInputs` instead.\");e.meta&&(n.meta=Object.assign(n.meta,e.meta)),void 0!==e.width&&void 0!==e.height&&this.updateProgramSize(n,e.width,e.height),\"object\"==typeof e.uniforms&&this.updateProgramUniforms(n,e.uniforms)}updateProgramInputs(t,e){const n=this.programs[t];if(!n)throw new Error(`Program with index ${t} does not exist.`);if(n.inputTextures.length!=e.length)throw new Error(`You must provide the same number of inputs as when the program was set up: got ${e.length} but expected ${n.inputTextures.length}.`);const i=n.inputWidth,a=n.inputHeight,o=n.config;void 0!==o.width&&void 0!==o.height||(n.inputWidth=void 0,n.inputHeight=void 0,n.inputDataSize=void 0),this._prepareProgramInputs(n,e),n.inputWidth==i&&n.inputHeight==a||(this.gl.useProgram(n.glProgram),this.gl.uniform2i(n.kernelSizeLocation,n.inputWidth,n.inputHeight),this._prepareProgramOutput(n))}updateProgramSize(t,e,n){const i=\"number\"==typeof t?this.programs[t]:t;if(!i)throw new Error(`Program with index ${t} does not exist.`);if(0!=i.inputTextures.length)throw new Error(\"Size can only be updated on programs with no inputs.\");e==i.inputWidth&&n==i.inputHeight||(i.inputWidth=e,i.inputHeight=n,i.inputDataSize=e*n,this.gl.useProgram(i.glProgram),this.gl.uniform2i(i.kernelSizeLocation,i.inputWidth,i.inputHeight),this._prepareProgramOutput(i))}updateProgramUniforms(t,e){const n=\"number\"==typeof t?this.programs[t]:t;if(this.gl.useProgram(n.glProgram),!n)throw new Error(`Program with index ${t} does not exist.`);for(const t in e){const i=e[t];let a;if(a=n.uniforms[t])this._setUniform(a.type,a.location,i);else{if(!(a=n.uniformTextures[t]))throw new Error(`The uniform ${t} does not exist in this program.`);{if(\"object\"!=typeof i||\"texture\"!=i.type)throw new Error(`Expected texture type for uniform ${t}.`);const{width:e,height:o,channels:s,data:r,...l}=a;n.uniformTextures[t].texture=this._createTexture(r,e,o,s,l)}}}}run(){const t=[];for(const e of this.programs){this.gl.useProgram(e.glProgram),this.gl.viewport(0,0,e.inputWidth,e.inputHeight),this.gl.bindFramebuffer(this.gl.FRAMEBUFFER,e.frameBuffer);for(const[t,n]of e.inputTextures.entries())this.gl.activeTexture(this.gl.TEXTURE0+t),this.gl.bindTexture(this.gl.TEXTURE_2D,n);for(const t in e.uniformTextures){const n=e.uniformTextures[t];this.gl.activeTexture(this.gl.TEXTURE0+n.index),this.gl.bindTexture(n.target,n.texture||this.sharedTextures[n.name]||this.outputTextures[n.name])}if(\"function\"==typeof e.draw)e.draw(this.gl,e);else if(this.gl.bindBuffer(this.gl.ARRAY_BUFFER,this.textureBuffer),this.gl.enableVertexAttribArray(e.textureLocation),this.gl.vertexAttribPointer(e.textureLocation,2,this.gl.FLOAT,!1,0,0),this.gl.bindBuffer(this.gl.ARRAY_BUFFER,this.positionBuffer),this.gl.enableVertexAttribArray(e.positionLocation),this.gl.vertexAttribPointer(e.positionLocation,2,this.gl.FLOAT,!1,0,0),this.gl.bindBuffer(this.gl.ELEMENT_ARRAY_BUFFER,this.indexBuffer),e.drawProxy){const t=(()=>this.gl.drawElements(this.gl.TRIANGLES,6,this.gl.UNSIGNED_SHORT,0)).bind(this);e.drawProxy(this,e,t)}else this.gl.drawElements(this.gl.TRIANGLES,6,this.gl.UNSIGNED_SHORT,0);if(e.output&&e.output.name&&!e.output.read)t.push(null);else{const n=new Float32Array(e.inputWidth*e.inputHeight*4);this.gl.readPixels(0,0,e.inputWidth,e.inputHeight,this.gl.RGBA,this.gl.FLOAT,n),t.push(n.subarray(0,4*e.inputDataSize))}}return t}_setUpGL(){const t=document.createElement(\"canvas\"),e={alpha:!1,antialias:!1};if(this.gl=t.getContext(\"webgl2\",e)||t.getContext(\"experimental-webgl2\",e),!this.gl)throw new Error(\"Unable to initialize WebGL2. Your browser may not support it.\");if(!this.gl.getExtension(\"EXT_color_buffer_float\"))throw new Error(\"Required WebGL extension EXT_color_buffer_float not supported.\");if(!this.gl.getExtension(\"OES_texture_float_linear\"))throw new Error(\"Required WebGL extension OES_texture_float_linear not supported.\");this.positionBuffer=this._newBuffer([-1,-1,1,-1,1,1,-1,1]),this.textureBuffer=this._newBuffer([0,0,1,0,1,1,0,1]),this.indexBuffer=this._newBuffer([1,2,0,3,0,2],Uint16Array,this.gl.ELEMENT_ARRAY_BUFFER)}_prepareProgram(t){const e={config:t};e.draw=t.draw,e.drawProxy=t.drawProxy,e.meta=Object.assign({},t.meta),t.width&&t.height&&(e.inputWidth=t.width,e.inputHeight=t.height,e.inputDataSize=t.width*t.height),e.output=t.output;const n=t.kernel;if(\"string\"!=typeof n||0==n.length)throw new Error(\"Kernel code cannot be empty.\");const a=t.inputs||[],o=t.uniforms||{};this._prepareProgramInputs(e,a);let s=\"\";for(const t in a)s+=`uniform sampler2D _input${t};\\n`;if(void 0===e.inputWidth||void 0===e.inputHeight)throw new Error(\"Unknown kernel size. You must provide either an input or the `width` and `height` parameters in the kernel config.\");e.uniformTextures={},e.uniforms={};for(const t in o){const n=o[t];if(\"number\"==typeof n)e.uniforms[t]={type:\"float\",value:n},s+=`uniform float ${t};\\n`;else if(Array.isArray(n)){if(n.length<2||n.length>4)throw new Error(\"Array uniforms can only have lengths of 2, 3, or 4 elements (corresponding to vec2, vec3, and vec4).\");const i=[\"vec2\",\"vec3\",\"vec4\"][n.length-2];e.uniforms[t]={type:i,value:n},s+=`uniform ${i} ${t};\\n`}else{const{type:i,width:a,height:o,channels:r,data:l,value:c,length:u,name:p,...h}=n;if(\"texture\"==i||\"outputTexture\"==i||\"sharedTexture\"==i){let n,i;\"3D\"==h.textureType?(n=this.gl.TEXTURE_3D,i=\"sampler3D\"):\"2DArray\"==h.textureType?(n=this.gl.TEXTURE_2D_ARRAY,i=\"sampler2DArray\"):(n=this.gl.TEXTURE_2D,i=\"sampler2D\"),e.uniformTextures[t]=\"texture\"==i?{target:n,texture:l?this._createTexture(l,a,o,r,h):null}:{target:n,texture:null,name:p||t},s+=`uniform ${i} ${t};\\n`}else e.uniforms[t]={type:i,value:c},s+=void 0!==u?`uniform ${i} ${t}[${u}];\\n`:`uniform ${i} ${t};\\n`}}const r=this.gl.createShader(this.gl.VERTEX_SHADER);if(this.gl.shaderSource(r,t.vertexShader||i),this.gl.compileShader(r),!this.gl.getShaderParameter(r,this.gl.COMPILE_STATUS))throw new Error(\"Could not build internal vertex shader (fatal).\\n\\n--- CODE DUMP ---\\n\"+i+\"\\n\\n--- ERROR LOG ---\\n\"+this.gl.getShaderInfoLog(r));const l=`\\nvoid main() {\\n  kernelOut = vec4(kernel(${[...Array(a.length).keys()].map(t=>`texture(_input${t}, kernelPosition)`).join(\", \")}));\\n}\\n    `,c=this.gl.createShader(this.gl.FRAGMENT_SHADER),u=\"#version 300 es\\nprecision highp float;\\nprecision highp int;\\nprecision highp sampler2D;\\nprecision highp sampler2DArray;\\nprecision highp sampler3D;\\nprecision highp samplerCube;\\n\\nin vec2 kernelPosition;\\nout vec4 kernelOut;\\nuniform ivec2 kernelSize;\\n\"+s+n+l;if(this.gl.shaderSource(c,u),this.gl.compileShader(c),!this.gl.getShaderParameter(c,this.gl.COMPILE_STATUS)){const t=u.split(\"\\n\");let e=\"ERROR: Could not build shader (fatal).\\n\\n------------------ KERNEL CODE DUMP ------------------\\n\";for(let n=0;n<t.length;n++)e+=`${n+1}> ${t[n]}\\n`;throw e+=\"\\n--------------------- ERROR  LOG ---------------------\\n\"+this.gl.getShaderInfoLog(c),new Error(e)}if(e.glProgram=this.gl.createProgram(),this.gl.attachShader(e.glProgram,r),this.gl.attachShader(e.glProgram,c),this.gl.linkProgram(e.glProgram),this.gl.useProgram(e.glProgram),!this.gl.getProgramParameter(e.glProgram,this.gl.LINK_STATUS))throw new Error(\"Failed to link GLSL program code.\");let p=0;for(const t of e.inputTextures){const t=this.gl.getUniformLocation(e.glProgram,`_input${p}`);this.gl.uniform1i(t,p),p++}for(const t in e.uniformTextures){e.uniformTextures[t].index=p;const n=this.gl.getUniformLocation(e.glProgram,t);this.gl.uniform1i(n,p),p++}for(const t in e.uniforms){const{type:n,value:i}=e.uniforms[t],a=e.uniforms[t].location=this.gl.getUniformLocation(e.glProgram,t);void 0!==i&&this._setUniform(n,a,i),delete e.uniforms[t].value}return e.kernelSizeLocation=this.gl.getUniformLocation(e.glProgram,\"kernelSize\"),this.gl.uniform2i(e.kernelSizeLocation,e.inputWidth,e.inputHeight),e.positionLocation=this.gl.getAttribLocation(e.glProgram,\"position\"),e.textureLocation=this.gl.getAttribLocation(e.glProgram,\"texture\"),e.frameBuffer=this.gl.createFramebuffer(),this._prepareProgramOutput(e),e}_prepareProgramInputs(t,e){t.inputTextures=[];for(const[n,i]of e.entries()){if(void 0===i.gpgpuSize||void 0===i.gpgpuStride)throw new Error(\"GPGPU inputs must be created by the `alloc` function.\");const e=Math.sqrt(i.length/i.gpgpuStride);if(e<=0||e%1!=0)throw new Error(\"GPGPU input size is expected to be a perfect square.\");if(void 0===t.inputWidth||void 0===t.inputHeight)t.inputWidth=e,t.inputHeight=e,t.inputDataSize=i.gpgpuSize;else if(e!=t.inputWidth||e!=t.inputHeight)throw new Error(`All GPGPU inputs must be of the same size. Received ${i.gpgpuSize} (internal ${e*e}) but expected ${t.inputDataSize} (internal ${t.inputWidth*t.inputHeight}).`);t.inputTextures.push(this._createTexture(i,e,e,i.gpgpuStride))}}_prepareProgramOutput(t){this.gl.bindFramebuffer(this.gl.FRAMEBUFFER,t.frameBuffer);const e=this._createTexture(null,t.inputWidth,t.inputHeight,4,t.output);if(this.gl.framebufferTexture2D(this.gl.FRAMEBUFFER,this.gl.COLOR_ATTACHMENT0,this.gl.TEXTURE_2D,e,0),!(this.gl.checkFramebufferStatus(this.gl.FRAMEBUFFER)==this.gl.FRAMEBUFFER_COMPLETE))throw new Error(\"Error attaching float texture to framebuffer. Your device is probably incompatible.\");t.output&&t.output.name&&(this.outputTextures[t.output.name]=e)}_setUniform(t,e,n){switch(t){case\"int\":this.gl.uniform1i(e,n);break;case\"float\":Array.isArray(n)?this.gl.uniform1fv(e,n):this.gl.uniform1f(e,n);break;case\"vec2\":this.gl.uniform2fv(e,n);break;case\"vec3\":this.gl.uniform3fv(e,n);break;case\"vec4\":this.gl.uniform4fv(e,n);break;case\"mat3\":this.gl.uniformMatrix3fv(e,n);break;default:throw new Error(`Unknown uniform type ${t}.`)}}_newBuffer(t,e,n){const i=this.gl.createBuffer();return this.gl.bindBuffer(n||this.gl.ARRAY_BUFFER,i),this.gl.bufferData(n||this.gl.ARRAY_BUFFER,new(e||Float32Array)(t),this.gl.STATIC_DRAW),i}_createTexture(t,e,n,i,a={}){const o=this.gl.createTexture();let s,r;switch(i){case 1:s=this.gl.R32F,r=this.gl.RED;break;case 2:s=this.gl.RG32F,r=this.gl.RG;break;case 3:s=this.gl.RGB32F,r=this.gl.RGB;break;case 4:s=this.gl.RGBA32F,r=this.gl.RGBA;break;default:throw\"Texture channels must between 1 and 4.\"}const l=\"3D\"==a.textureType?this.gl.TEXTURE_3D:\"2DArray\"==a.textureType?this.gl.TEXTURE_2D_ARRAY:this.gl.TEXTURE_2D;return this.gl.bindTexture(l,o),this.gl.texParameteri(l,this.gl.TEXTURE_WRAP_S,this.gl.CLAMP_TO_EDGE),this.gl.texParameteri(l,this.gl.TEXTURE_WRAP_T,this.gl.CLAMP_TO_EDGE),this.gl.texParameteri(l,this.gl.TEXTURE_MIN_FILTER,\"linear\"==a.filter?this.gl.LINEAR:this.gl.NEAREST),this.gl.texParameteri(l,this.gl.TEXTURE_MAG_FILTER,\"linear\"==a.filter?this.gl.LINEAR:this.gl.NEAREST),\"3D\"==a.textureType||\"2DArray\"==a.textureType?this.gl.texImage3D(l,0,s,e,n,a.depth,0,r,this.gl.FLOAT,t):this.gl.texImage2D(l,0,s,e,n,0,r,this.gl.FLOAT,t),this.gl.bindTexture(l,null),o}}},function(t,e,n){\"use strict\";(function(t){n.d(e,\"a\",function(){return x});var i=n(12),a=n(1),o=n(10),s=n(11),r=n(9),l=n(8),c=n(7),u=n(6),p=n(5),h=n(4),d=n(3),f=n(2);const m=8,y=4,g=2,v={spatialHorizon:100,stationInterval:.5,lattice:{numStations:10,numLatitudes:19,stationConnectivity:3,latitudeConnectivity:9},xyGridCellSize:.3,slGridCellSize:.15,gridMargin:10,pathSamplingStep:.5,cubicPathPenalty:.1,lethalDilationS:a.a.HALF_CAR_LENGTH+.6,hazardDilationS:2,lethalDilationL:a.a.HALF_CAR_WIDTH+.3,hazardDilationL:1,obstacleHazardCost:10,laneWidth:3.7,laneShoulderCost:5,laneShoulderLatitude:1.85-a.a.HALF_CAR_WIDTH,laneCostSlope:.5,stationReachDiscount:-10,extraTimePenalty:10,speedLimit:25,speedLimitPenalty:25,hardAccelerationPenalty:10,hardDecelerationPenalty:10,lateralAccelerationLimit:3,softLateralAccelerationPenalty:10,linearLateralAccelerationPenalty:1,dCurvatureMax:a.a.MAX_STEER_SPEED/a.a.WHEEL_BASE};class x{constructor(){const t=[r.a.setUp(),l.a.setUp(),...c.a.setUp(),u.a.setUp(),...p.a.setUp(),h.a.setUp(),...d.a.setUp(),f.a.setUp()].map(t=>Object.assign({},t,{width:1,height:1}));this.gpgpu=new i.a(t)}plan(e,n){const i=e.sampleStations(0,Math.ceil(v.spatialHorizon/v.stationInterval)+1,v.stationInterval),a={pos:i[0].pos.clone().sub(i[1].pos).normalize().multiplyScalar(10).add(i[0].pos),rot:i[0].rot,curv:0,dCurv:0,ddCurv:0,speed:0},o=function({pos:e,rot:n}){const i=new t.Matrix3;i.set(1,0,-e.x,0,1,-e.y,0,0,1);const a=Math.cos(n),o=Math.sin(n),s=new t.Matrix3;return s.set(a,o,0,-o,a,0,0,0,1),s.multiply(i)}(a),s=i.map(t=>({pos:t.pos.clone().applyMatrix3(o),rot:t.rot-a.rot,curv:t.curv})),x=new Float32Array(3*s.length),_=new t.Vector2(0,0),S=new t.Vector2(0,0);for(let t=0;t<s.length;t++){const e=s[t],n=e.pos;x[3*t+0]=n.x,x[3*t+1]=n.y,x[3*t+2]=e.rot,_.max(n),S.min(n)}const T=_.clone().sub(S),E=S.clone().add(_).divideScalar(2),A=Math.ceil((T.x+2*v.gridMargin)/v.xyGridCellSize),P=Math.ceil((T.y+2*v.gridMargin)/v.xyGridCellSize),L=new t.Vector2(v.spatialHorizon/2,0),R=Math.ceil(v.spatialHorizon/v.slGridCellSize),b=Math.ceil((v.laneWidth+2*v.gridMargin)/v.slGridCellSize);for(const[t,e]of[r.a.update(v,A,P,E,o,n),l.a.update(v,R,b,L,E),...c.a.update(v,R,b),u.a.update(v,A,P,E),...p.a.update(v,a),h.a.update(v,a),...d.a.update(v,a,E,L),f.a.update(v,a,E,L)].entries())this.gpgpu.updateProgram(t,e);const C=this._buildLattice(e,a.rot,o);this.gpgpu.updateSharedTextures({centerline:{width:s.length,height:1,channels:3,filter:\"linear\",data:x},lattice:{width:v.lattice.numLatitudes,height:v.lattice.numStations,channels:4,data:C},costTable:{width:m*y*g,height:v.lattice.numLatitudes,depth:v.lattice.numStations,channels:4,textureType:\"2DArray\"}});let G=performance.now();const I=this.gpgpu.run();console.log(`Planner GPU time: ${(performance.now()-G)/1e3}s`);const O=this.gpgpu._graphSearchCostTable,w=I[5],D=I[6],N=I[7];let V,F=[Number.POSITIVE_INFINITY];const M=O.length/4;for(let t=0;t<M;t++){const e=this._unpackCostTableIndex(t),n=[O[4*t],O[4*t+1],O[4*t+2],O[4*t+3]];n[0]<0||(n[0]+=this._terminalCost(e,n),n[0]<F[0]&&(V=t,F=n))}const z=(new t.Matrix3).getInverse(o),B=this._reconstructTrajectory(V,O,w,D,N,a.curv,C).map(t=>({pos:t.pos.applyMatrix3(z),rot:t.rot+a.rot,curv:t.curv}));return{xysl:I[4],width:A,height:P,center:E.applyMatrix3(z),rot:a.rot,path:B,vehiclePose:a}}_buildLattice(e,n,i){const a=v.spatialHorizon/v.lattice.numStations,o=e.sampleStations(a,v.lattice.numStations,a),s=Math.floor(v.lattice.numLatitudes/2),r=new Float32Array(v.lattice.numStations*v.lattice.numLatitudes*4);let l=0;for(let e=0;e<v.lattice.numStations;e++){const a=o[e];for(let e=0;e<v.lattice.numLatitudes;e++){const o=(e-s)/s*v.laneWidth/2,c=a.rot-n,u=t.Vector2.fromAngle(c+Math.PI/2).multiplyScalar(o).add(a.pos.clone().applyMatrix3(i)),p=0==a.curv?0:1/(1/a.curv-o);r[l++]=u.x,r[l++]=u.y,r[l++]=c,r[l++]=p}}return r}_terminalCost([t,e,n,i,a],[o,s,r,l]){if(t!=v.lattice.numStations-1&&s>.05)return Number.POSITIVE_INFINITY;const c=v.spatialHorizon/v.lattice.numStations*(t+1);return v.stationReachDiscount*c+v.extraTimePenalty*r}_unpackCostTableIndex(t){if(t<0)return[-1,t+2,null,null,null];const e=m*y,n=e*g,i=v.lattice.numLatitudes*n,a=Math.floor(t/i);t-=a*i;const o=Math.floor(t/n);t-=o*n;const s=Math.floor(t/e);return t-=s*e,[a,o,s,Math.floor(t/m),t%m]}_reconstructTrajectory(e,n,i,a,r,l,c){let u=this._unpackCostTableIndex(e);const p=[u];let h=0;for(;u[0]>=0&&h++<100;)e=n[4*e+3],u=this._unpackCostTableIndex(e),p.unshift(u);if(h>=100)throw new Error(\"Infinite loop encountered while reconstructing trajectory.\");const d=[];for(let e=0;e<p.length-1;e++){const[n,u]=p[e],[h,f]=p[e+1];let m,y;if(n<0){const e={pos:new t.Vector2(0,0),rot:0,curv:l},n=4*(h*v.lattice.numLatitudes+f),i={pos:new t.Vector2(c[n],c[n+1]),rot:c[n+2],curv:c[n+3]};0==u?(m=a[n+2],y=new o.a(e,i,{p1:a[n],p2:a[n+1],sG:m})):(m=r[n+2],y=new s.a(e,i,{p3:r[n],p4:r[n+1],sG:m}))}else{const e=4*(n*v.lattice.numLatitudes+u),a=4*(h*v.lattice.numLatitudes+f),s={pos:new t.Vector2(c[e],c[e+1]),rot:c[e+2],curv:c[e+3]},r={pos:new t.Vector2(c[a],c[a+1]),rot:c[a+2],curv:c[a+3]},l=h*v.lattice.numLatitudes+f,p=4*(((n-h+v.lattice.stationConnectivity)*v.lattice.latitudeConnectivity+u-f+Math.floor(v.lattice.latitudeConnectivity/2))*v.lattice.numStations*v.lattice.numLatitudes+l);m=i[p+2],y=new o.a(s,r,{p1:i[p],p2:i[p+1],sG:m})}const g=y.buildPath(Math.ceil(m/v.pathSamplingStep));e<p.length-2&&g.pop(),d.push(...g)}return d}}x.config=v}).call(this,n(!function(){var t=new Error('Cannot find module \"../js/vendor/three.js\"');throw t.code=\"MODULE_NOT_FOUND\",t}()))},function(t,e,n){\"use strict\";n.r(e);var i=n(13);console.log(\"WEB WORKER!\"),console.log(i.a)}]);","extractedComments":[]}