{"map":"{\"version\":3,\"sources\":[\"webpack/bootstrap\",\"/Users/matt/code/self_driving_car/dash/js/physics/Car.js\",\"/Users/matt/code/self_driving_car/dash/js/autonomy/path-planning/CubicPath.js\",\"/Users/matt/code/self_driving_car/dash/js/GPGPU.js\",\"/Users/matt/code/self_driving_car/dash/js/physics/simple/Car.js\",\"/Users/matt/code/self_driving_car/dash/js/autonomy/LanePath.js\",\"/Users/matt/code/self_driving_car/dash/js/autonomy/path-planning/StaticObstacle.js\",\"/Users/matt/code/self_driving_car/dash/js/autonomy/path-planning/QuinticPath.js\",\"/Users/matt/code/self_driving_car/dash/js/autonomy/path-planning/gpgpu-programs/xyObstacleGrid.js\",\"/Users/matt/code/self_driving_car/dash/js/autonomy/path-planning/gpgpu-programs/slObstacleGrid.js\",\"/Users/matt/code/self_driving_car/dash/js/autonomy/path-planning/gpgpu-programs/slObstacleGridDilation.js\",\"/Users/matt/code/self_driving_car/dash/js/autonomy/path-planning/gpgpu-programs/xyslMap.js\",\"/Users/matt/code/self_driving_car/dash/js/autonomy/path-planning/gpgpu-programs/optimizeCubicPaths.js\",\"/Users/matt/code/self_driving_car/dash/js/autonomy/path-planning/gpgpu-programs/optimizeQuinticPaths.js\",\"/Users/matt/code/self_driving_car/dash/js/autonomy/path-planning/gpgpu-programs/graphSearchShared.js\",\"/Users/matt/code/self_driving_car/dash/js/autonomy/path-planning/gpgpu-programs/pathFromVehicleCosts.js\",\"/Users/matt/code/self_driving_car/dash/js/autonomy/path-planning/gpgpu-programs/graphSearch.js\",\"/Users/matt/code/self_driving_car/dash/js/autonomy/path-planning/PathPlanner.js\",\"/Users/matt/code/self_driving_car/dash/js/physics/simple/Physics.js\",\"/Users/matt/code/self_driving_car/dash/js/autonomy/Path.js\",\"/Users/matt/code/self_driving_car/dash/js/autonomy/control/FollowController.js\",\"/Users/matt/code/self_driving_car/dash/js/autonomy/control/ManualController.js\",\"/Users/matt/code/self_driving_car/dash/js/objects/MapObject.js\",\"/Users/matt/code/self_driving_car/dash/js/objects/CarObject.js\",\"/Users/matt/code/self_driving_car/dash/js/simulator/Editor.js\",\"/Users/matt/code/self_driving_car/dash/js/simulator/OrbitControls.js\",\"/Users/matt/code/self_driving_car/dash/js/simulator/TopDownCameraControls.js\",\"/Users/matt/code/self_driving_car/dash/js/simulator/Dashboard.js\",\"/Users/matt/code/self_driving_car/dash/js/autonomy/path-planning/RoadLattice.js\",\"/Users/matt/code/self_driving_car/dash/js/autonomy/MovingAverage.js\",\"/Users/matt/code/self_driving_car/dash/js/simulator/PathPlannerConfigEditor.js\",\"/Users/matt/code/self_driving_car/dash/js/Simulator.js\",\"/Users/matt/code/self_driving_car/dash/js/Dash.js\"],\"names\":[\"installedModules\",\"__webpack_require__\",\"moduleId\",\"exports\",\"module\",\"i\",\"l\",\"modules\",\"call\",\"m\",\"c\",\"d\",\"name\",\"getter\",\"o\",\"Object\",\"defineProperty\",\"configurable\",\"enumerable\",\"get\",\"r\",\"value\",\"n\",\"__esModule\",\"object\",\"property\",\"prototype\",\"hasOwnProperty\",\"p\",\"s\",\"__webpack_exports__\",\"_simple_Car_js__WEBPACK_IMPORTED_MODULE_0__\",\"CubicPath\",\"SIMPSONS_INTERVALS\",\"NEWTON_ITERATIONS\",\"RELAXATION_ITERATIONS\",\"CONVERGENCE_ERROR\",\"jacobian\",\"THREE\",\"Matrix3\",\"invJacobian\",\"[object Object]\",\"start\",\"end\",\"params\",\"this\",\"assign\",\"pos\",\"x\",\"y\",\"diffX\",\"diffY\",\"sinRot\",\"Math\",\"sin\",\"rot\",\"cosRot\",\"cos\",\"goal\",\"wrapAngle\",\"curv\",\"p0\",\"p3\",\"guessInitialParams\",\"converged\",\"originalGoal\",\"dStartCurv\",\"dGoalY\",\"dGoalRot\",\"dGoalCurv\",\"p1\",\"p2\",\"sG\",\"iterate\",\"ds\",\"sG_2\",\"sG_3\",\"theta\",\"cosTheta\",\"sinTheta\",\"dT_p1\",\"dT_p2\",\"dT_sG\",\"dX_p1\",\"dX_p2\",\"dX_sG\",\"dY_p1\",\"dY_p2\",\"dY_sG\",\"guessX\",\"guessY\",\"coeff\",\"s_sG\",\"hOver3\",\"deltaX\",\"deltaY\",\"deltaRot\",\"abs\",\"set\",\"m11\",\"m21\",\"m31\",\"m12\",\"m22\",\"m32\",\"m13\",\"m23\",\"m33\",\"getInverse\",\"elements\",\"num\",\"a\",\"b\",\"path\",\"Vector2\",\"dx\",\"dy\",\"prevCosRot\",\"prevSinRot\",\"push\",\"vertexShaderCode\",\"size\",\"stride\",\"Number\",\"isInteger\",\"Error\",\"squareSize\",\"pow\",\"ceil\",\"sqrt\",\"data\",\"Float32Array\",\"gpgpuSize\",\"gpgpuStride\",\"configs\",\"shared\",\"_setUpGL\",\"outputTextures\",\"sharedTextures\",\"programs\",\"map\",\"_prepareProgram\",\"width\",\"height\",\"channels\",\"options\",\"_createTexture\",\"programOrProgramIndex\",\"config\",\"program\",\"inputs\",\"meta\",\"undefined\",\"updateProgramSize\",\"updateProgramUniforms\",\"uniforms\",\"programIndex\",\"inputTextures\",\"length\",\"previousInputWidth\",\"inputWidth\",\"previousInputHeight\",\"inputHeight\",\"inputDataSize\",\"_prepareProgramInputs\",\"gl\",\"useProgram\",\"glProgram\",\"uniform2i\",\"kernelSizeLocation\",\"_prepareProgramOutput\",\"uniformName\",\"uniform\",\"_setUniform\",\"type\",\"location\",\"uniformTextures\",\"texture\",\"outputs\",\"viewport\",\"bindFramebuffer\",\"FRAMEBUFFER\",\"frameBuffer\",\"index\",\"inputTexture\",\"entries\",\"activeTexture\",\"TEXTURE0\",\"bindTexture\",\"TEXTURE_2D\",\"uniformTexture\",\"target\",\"draw\",\"bindBuffer\",\"ARRAY_BUFFER\",\"textureBuffer\",\"enableVertexAttribArray\",\"textureLocation\",\"vertexAttribPointer\",\"FLOAT\",\"positionBuffer\",\"positionLocation\",\"ELEMENT_ARRAY_BUFFER\",\"indexBuffer\",\"drawProxy\",\"drawElements\",\"TRIANGLES\",\"UNSIGNED_SHORT\",\"bind\",\"output\",\"read\",\"readPixels\",\"RGBA\",\"subarray\",\"canvas\",\"self\",\"document\",\"createElement\",\"OffscreenCanvas\",\"attr\",\"alpha\",\"antialias\",\"getContext\",\"getExtension\",\"_newBuffer\",\"Uint16Array\",\"kernel\",\"fragmentShaderConfig\",\"Array\",\"isArray\",\"textureType\",\"TEXTURE_3D\",\"TEXTURE_2D_ARRAY\",\"vertexShader\",\"createShader\",\"VERTEX_SHADER\",\"shaderSource\",\"compileShader\",\"getShaderParameter\",\"COMPILE_STATUS\",\"getShaderInfoLog\",\"fragmentShaderMain\",\"keys\",\"join\",\"fragmentShader\",\"FRAGMENT_SHADER\",\"fragmentShaderSource\",\"source\",\"split\",\"dbgMsg\",\"createProgram\",\"attachShader\",\"linkProgram\",\"getProgramParameter\",\"LINK_STATUS\",\"textureIndex\",\"input\",\"getUniformLocation\",\"uniform1i\",\"getAttribLocation\",\"createFramebuffer\",\"outputTexture\",\"framebufferTexture2D\",\"COLOR_ATTACHMENT0\",\"checkFramebufferStatus\",\"FRAMEBUFFER_COMPLETE\",\"uniform1fv\",\"uniform1f\",\"uniform2fv\",\"uniform3fv\",\"uniform4fv\",\"uniformMatrix3fv\",\"klass\",\"buf\",\"createBuffer\",\"bufferData\",\"STATIC_DRAW\",\"createTexture\",\"internalFormat\",\"format\",\"R32F\",\"RED\",\"RG32F\",\"RG\",\"RGB32F\",\"RGB\",\"RGBA32F\",\"texParameteri\",\"TEXTURE_WRAP_S\",\"CLAMP_TO_EDGE\",\"TEXTURE_WRAP_T\",\"TEXTURE_MIN_FILTER\",\"filter\",\"LINEAR\",\"NEAREST\",\"TEXTURE_MAG_FILTER\",\"texImage3D\",\"depth\",\"texImage2D\",\"Car\",\"rotation\",\"setPose\",\"fromAngle\",\"multiplyScalar\",\"WHEEL_BASE\",\"add\",\"frontToRearAxlePosition\",\"REAR_AXLE_POS\",\"pose\",\"rearAxlePosition\",\"velocity\",\"curvature\",\"dCurv\",\"ddCurv\",\"tan\",\"wheelAngle\",\"position\",\"frontAxlePosition\",\"FRONT_AXLE_POS\",\"acceleration\",\"wheelAngularVelocity\",\"dt\",\"curvPrev\",\"dCurvPrev\",\"drag\",\"DRAG_COEFF\",\"FRONTAL_AREA\",\"DENSITY_OF_AIR\",\"ROLL_RESIST\",\"MASS\",\"velocitySq\",\"maxWheelAngle\",\"clamp\",\"atan\",\"MAX_LATERAL_ACCEL\",\"MAX_WHEEL_ANGLE\",\"angularVelocity\",\"dist\",\"controls\",\"gas\",\"brake\",\"steer\",\"sign\",\"MAX_BRAKE_DECEL\",\"newVelocity\",\"MAX_GAS_ACCEL\",\"MAX_STEER_SPEED\",\"HALF_CAR_LENGTH\",\"HALF_CAR_WIDTH\",\"HALF_WHEEL_LENGTH\",\"HALF_WHEEL_WIDTH\",\"PI\",\"WHEEL_LATERAL_POS\",\"Geometry\",\"catmullRom\",\"t\",\"v0\",\"v1\",\"t2\",\"catmullRomVec\",\"tangentAt\",\"t1\",\"prev\",\"sub\",\"normalize\",\"curvatureAt\",\"t3\",\"pt1\",\"pt2\",\"pt3\",\"atan2\",\"distanceTo\",\"anchors\",\"centerlines\",\"sampleLengths\",\"arcLengths\",\"rotations\",\"leftBoundaries\",\"rightBoundaries\",\"centerline\",\"concat\",\"centerlineRotations\",\"centerlineLengths\",\"arclengths\",\"leftBoundary\",\"rightBoundary\",\"startStation\",\"interval\",\"samples\",\"anchorIndex\",\"sampleIndex\",\"totalLength\",\"nextStation\",\"anchorsForSplineIndex\",\"weight\",\"tangent\",\"aroundAnchorIndex\",\"sampleStation\",\"prevSampleStation\",\"_findClosestSample\",\"prevPoint\",\"nextPoint\",\"prevStation\",\"possibleNext\",\"clone\",\"dot\",\"distanceToSquared\",\"progress\",\"projectedPosition\",\"bestAnchorIndex\",\"bestSampleIndex\",\"bestStation\",\"bestPrevStation\",\"closest\",\"POSITIVE_INFINITY\",\"currStation\",\"startAnchorIndex\",\"endAnchorIndex\",\"max\",\"min\",\"distSq\",\"resample\",\"points\",\"lengths\",\"pointRotations\",\"pointsPerSegment\",\"numPoints\",\"point\",\"normal\",\"reduce\",\"sum\",\"slice\",\"updateVertices\",\"vertices\",\"halfWidth\",\"halfHeight\",\"hWcR\",\"hWsR\",\"hHcR\",\"hHsR\",\"v2\",\"v3\",\"v4\",\"QuinticPath\",\"p5\",\"p4\",\"e\",\"f\",\"obstacleVertices\",\"obstacleXform\",\"xyObstacleGrid\",\"setUp\",\"clearColor\",\"clear\",\"COLOR_BUFFER_BIT\",\"xformLocation\",\"drawArrays\",\"xyWidth\",\"xyHeight\",\"xyCenterPoint\",\"vehicleXform\",\"obstacles\",\"apply\",\"translate\",\"scale\",\"xyGridCellSize\",\"multiply\",\"slObstacleGrid\",\"slGridCellSize\",\"slCenterPoint\",\"centerlineStationInterval\",\"update\",\"slWidth\",\"slHeight\",\"SL_OBSTACLE_DILATION_KERNEL\",\"slObstacleGridDilation\",\"delta\",\"lethalDilation\",\"hazardDilation\",\"lethalDilationS\",\"hazardDilationS\",\"lethalDilationL\",\"hazardDilationL\",\"xyslMap\",\"optimizeCubicPaths\",\"OPTIMIZE_CUBIC_SHARED\",\"lattice\",\"numStations\",\"numLatitudes\",\"stationConnectivity\",\"latitudeConnectivity\",\"curvVehicle\",\"optimizeQuinticPaths\",\"dCurvVehicle\",\"ddCurvVehicle\",\"SHARED_SHADER\",\"SAMPLE_CUBIC_PATH_FN\",\"SAMPLE_QUINTIC_PATH_FN\",\"SHARED_UNIFORMS\",\"accelerationProfiles\",\"finalVelocityProfiles\",\"laneCostSlope\",\"laneShoulderCost\",\"laneShoulderLatitude\",\"obstacleHazardCost\",\"speedLimit\",\"speedLimitPenalty\",\"hardAccelerationPenalty\",\"hardDecelerationPenalty\",\"lateralAccelerationLimit\",\"softLateralAccelerationPenalty\",\"linearLateralAccelerationPenalty\",\"dCurvatureMax\",\"pathSamplingStep\",\"rearAxleToCenter\",\"buildUniformValues\",\"fromVehiclePathCostsKernel\",\"pathType\",\"pathFromVehicleCosts\",\"pathsFromVehicle\",\"firstLatticePoint\",\"secondLatticePoint\",\"velocityVehicle\",\"numAccelerations\",\"cubicPathPenalty\",\"hysteresisDiscount\",\"accelerationChangePenalty\",\"SOLVE_STATION_KERNEL\",\"graphSearch\",\"costTable\",\"cubicPaths\",\"cubicPathFromVehicleCosts\",\"quinticPathFromVehicleCosts\",\"extraTimePenalty\",\"numVelocities\",\"numTimes\",\"velocityRanges\",\"NUM_VELOCITY_RANGES\",\"timeRanges\",\"NUM_TIME_RANGES\",\"station\",\"gpgpu\",\"NUM_ACCELERATION_PROFILES\",\"copyTexSubImage3D\",\"_graphSearchCostTable\",\"PathPlanner_NUM_ACCELERATION_PROFILES\",\"PathPlanner_NUM_VELOCITY_RANGES\",\"PathPlanner_NUM_TIME_RANGES\",\"PathPlanner_PathPlanner\",\"previousStartStation\",\"previousFirstLatticePoint\",\"previousSecondLatticePoint\",\"performance\",\"now\",\"GPGPU\",\"vehiclePose\",\"vehicleStation\",\"lanePath\",\"centerlineRaw\",\"sampleStations\",\"spatialHorizon\",\"rotate\",\"vehicleTransform\",\"applyMatrix3\",\"centerlineData\",\"maxPoint\",\"minPoint\",\"sample\",\"diff\",\"divideScalar\",\"gridMargin\",\"laneWidth\",\"latticeStationInterval\",\"_latticeStationInterval\",\"_buildLattice\",\"updateProgram\",\"updateSharedTextures\",\"run\",\"cubicPathParams\",\"cubicPathFromVehicleParams\",\"quinticPathFromVehicleParams\",\"bestEntryIndex\",\"bestEntry\",\"numEntries\",\"entryUnpacked\",\"_unpackCostTableIndex\",\"entry\",\"_terminalCost\",\"inverseVehicleXform\",\"bestTrajectory\",\"fromVehicleSegment\",\"fromVehicleParams\",\"isFinite\",\"_reconstructTrajectory\",\"forEach\",\"latticeStartStation\",\"vehicleRot\",\"offset\",\"floor\",\"latitude\",\"stationIndex\",\"latitudeIndex\",\"timeIndex\",\"velocityIndex\",\"accelerationIndex\",\"cost\",\"finalVelocity\",\"finalTime\",\"incomingIndex\",\"stationReachDiscount\",\"numPerTime\",\"numPerLatitude\",\"numPerStation\",\"unpacked\",\"nodes\",\"count\",\"unshift\",\"prevLatitude\",\"_pt\",\"_pv\",\"_pa\",\"prevVelocity\",\"_t\",\"_v\",\"_a\",\"pathBuilder\",\"endIndex\",\"startIndex\",\"slIndex\",\"cubicPathIndex\",\"buildPath\",\"prevVelocitySq\",\"accel\",\"shift\",\"Physics_Physics\",\"cars\",\"step\",\"newCar\",\"Path_Path\",\"poses\",\"startRotation\",\"goalRotation\",\"next\",\"frontPos\",\"physics_Car\",\"getFrontAxlePosition\",\"fakePos\",\"getFakeAxlePosition\",\"FollowController_FollowController\",\"car\",\"nextIndex\",\"prevAccel\",\"currentPose\",\"predictionTime\",\"pathPoses\",\"findNextIndex\",\"currentVelocity\",\"prevPose\",\"nextPose\",\"segmentDist\",\"distLeft\",\"sumV\",\"timeToNextIndex\",\"newProgress\",\"newRotation\",\"lockPath\",\"projection\",\"kp_a\",\"kd_a\",\"kff_a\",\"accelDamping\",\"currentAccel\",\"prevNextDist\",\"targetAccel\",\"dampedAccel\",\"wheelAngleError\",\"damping\",\"newPosition\",\"console\",\"log\",\"closestDistSqr\",\"closestIndex\",\"distSqr\",\"FollowController_projectPointOnSegment\",\"precedingProjection\",\"precedingProgress\",\"succeedingProjection\",\"succeedingProgress\",\"ManualController\",\"carKeys\",\"forward\",\"backward\",\"left\",\"right\",\"addEventListener\",\"event\",\"key\",\"MapObject\",\"Object3D\",\"geolocation\",\"super\",\"tilesGroup\",\"tileSize\",\"tileSizeInMeters\",\"grid\",\"GridHelper\",\"HALF_NUM_TILES\",\"renderOrder\",\"material\",\"depthTest\",\"Vector3\",\"drawTiles\",\"latlng\",\"latitudeRadians\",\"worldCoordinates\",\"SCALE\",\"tileGroup\",\"remove\",\"Group\",\"originTile\",\"worldToTile\",\"geoToWorld\",\"tileTexture\",\"TextureLoader\",\"load\",\"ZOOM\",\"anisotropy\",\"tileGeometry\",\"PlaneBufferGeometry\",\"tileMaterial\",\"MeshBasicMaterial\",\"color\",\"tile\",\"Mesh\",\"z\",\"EARTH_RADIUS\",\"TILE_PIXELS\",\"CarObject_CarObject\",\"carMesh\",\"PlaneGeometry\",\"transparent\",\"opacity\",\"wheelGeometry\",\"wheelMaterial\",\"lfWheel\",\"rfWheel\",\"lrWheel\",\"rrWheel\",\"updateCar\",\"updateMatrix\",\"carPosition\",\"GROUND_PLANE\",\"Plane\",\"Editor_Editor\",\"camera\",\"scene\",\"raycaster\",\"Raycaster\",\"mouse\",\"dragOffset\",\"draggingPoint\",\"pointIndex\",\"centerlineGeometry\",\"leftBoundaryGeometry\",\"rightBoundaryGeometry\",\"enabled\",\"group\",\"pointsGroup\",\"LanePath\",\"mouseDown\",\"mouseMove\",\"mouseUp\",\"preventDefault\",\"editorClearOptions\",\"getElementById\",\"stopPropagation\",\"classList\",\"toggle\",\"centerlineObject\",\"MeshLineMaterial\",\"Color\",\"lineWidth\",\"resolution\",\"clientWidth\",\"clientHeight\",\"leftBoundaryObject\",\"rightBoundaryObject\",\"setFromPoints\",\"MeshLine\",\"setGeometry\",\"geometry\",\"CircleGeometry\",\"userData\",\"addAnchor\",\"copy\",\"updateAnchor\",\"clearPoints\",\"addPoint\",\"redraw\",\"button\",\"offsetX\",\"offsetY\",\"setFromCamera\",\"picked\",\"intersectObjects\",\"stopImmediatePropagation\",\"intersection\",\"ray\",\"intersectPlane\",\"updatePoint\",\"OrbitControls\",\"domElement\",\"quat\",\"quatInverse\",\"lastPosition\",\"lastQuaternion\",\"minDistance\",\"maxDistance\",\"Infinity\",\"minZoom\",\"maxZoom\",\"minPolarAngle\",\"maxPolarAngle\",\"minAzimuthAngle\",\"maxAzimuthAngle\",\"enableDamping\",\"dampingFactor\",\"enableZoom\",\"zoomSpeed\",\"enableRotate\",\"rotateSpeed\",\"enablePan\",\"keyPanSpeed\",\"autoRotate\",\"autoRotateSpeed\",\"enableKeys\",\"LEFT\",\"UP\",\"RIGHT\",\"BOTTOM\",\"mouseButtons\",\"ORBIT\",\"MOUSE\",\"MIDDLE\",\"PAN\",\"target0\",\"position0\",\"zoom0\",\"zoom\",\"getPolarAngle\",\"spherical\",\"phi\",\"getAzimuthalAngle\",\"saveState\",\"scope\",\"reset\",\"updateProjectionMatrix\",\"dispatchEvent\",\"changeEvent\",\"state\",\"STATE\",\"NONE\",\"rotateLeft\",\"angle\",\"Quaternion\",\"setFromUnitVectors\",\"up\",\"inverse\",\"applyQuaternion\",\"setFromVector3\",\"sphericalDelta\",\"makeSafe\",\"radius\",\"panOffset\",\"setFromSpherical\",\"lookAt\",\"zoomChanged\",\"EPS\",\"quaternion\",\"dispose\",\"removeEventListener\",\"onContextMenu\",\"onMouseDown\",\"onMouseWheel\",\"onTouchStart\",\"onTouchEnd\",\"onTouchMove\",\"onMouseMove\",\"onMouseUp\",\"window\",\"onKeyDown\",\"startEvent\",\"endEvent\",\"ROTATE\",\"DOLLY\",\"TOUCH_ROTATE\",\"TOUCH_DOLLY\",\"TOUCH_PAN\",\"Spherical\",\"rotateStart\",\"rotateEnd\",\"rotateDelta\",\"panStart\",\"panEnd\",\"panDelta\",\"dollyStart\",\"dollyEnd\",\"dollyDelta\",\"getZoomScale\",\"rotateUp\",\"v\",\"panLeft\",\"distance\",\"objectMatrix\",\"setFromMatrixColumn\",\"panUp\",\"pan\",\"element\",\"body\",\"isPerspectiveCamera\",\"targetDistance\",\"fov\",\"matrix\",\"isOrthographicCamera\",\"top\",\"bottom\",\"warn\",\"dollyIn\",\"dollyScale\",\"dollyOut\",\"clientX\",\"clientY\",\"handleMouseDownRotate\",\"handleMouseDownDolly\",\"handleMouseDownPan\",\"subVectors\",\"handleMouseMoveRotate\",\"handleMouseMoveDolly\",\"handleMouseMovePan\",\"handleMouseWheel\",\"keyCode\",\"handleKeyDown\",\"touches\",\"pageX\",\"pageY\",\"handleTouchStartRotate\",\"handleTouchStartDolly\",\"handleTouchStartPan\",\"handleTouchMoveRotate\",\"handleTouchMoveDolly\",\"handleTouchMovePan\",\"create\",\"EventDispatcher\",\"constructor\",\"defineProperties\",\"center\",\"noZoom\",\"noRotate\",\"noPan\",\"noKeys\",\"staticMoving\",\"dynamicDampingFactor\",\"simulator_OrbitControls\",\"groundPlane\",\"panning\",\"TopDownCameraControls\",\"enablePanning\",\"wheel\",\"prevCamera\",\"Ray\",\"movementX\",\"movementY\",\"MPS_TO_MPH\",\"METERS_TO_FEET\",\"Dashboard_Dashboard\",\"units\",\"readyState\",\"fetchDomElements\",\"wheelDom\",\"wheelPieDom\",\"wheelPieLeftDom\",\"wheelPieRightDom\",\"gearDom\",\"gasDom\",\"brakeDom\",\"speedDom\",\"stationDom\",\"latitudeDom\",\"planTimeDom\",\"elapsedTimeDom\",\"speedUnitsDom\",\"stationUnitsDom\",\"latitudeUnitsDom\",\"el\",\"toggleUnits\",\"speedUnits\",\"distanceUnits\",\"innerHTML\",\"speed\",\"elapsedTime\",\"planTime\",\"wheelTurn\",\"style\",\"transform\",\"clipPath\",\"innerText\",\"toFixed\",\"mins\",\"seconds\",\"RoadLattice\",\"SPATIAL_HORIZON\",\"NUM_LATITUDES\",\"latitudes\",\"MovingAverage\",\"maxSamples\",\"numSamples\",\"average\",\"k\",\"curr\",\"newAverage\",\"LOCAL_STORAGE_KEY\",\"internalConfig\",\"defaultConfig\",\"PathPlannerConfigEditor\",\"_config\",\"showConfigBox\",\"configBox\",\"configForm\",\"_setUpButtons\",\"storedConfig\",\"JSON\",\"parse\",\"localStorage\",\"getItem\",\"sort\",\"appendChild\",\"_createConfigField\",\"_saveConfigFields\",\"_restoreDefaults\",\"html\",\"template\",\"content\",\"firstChild\",\"formData\",\"FormData\",\"parseFloat\",\"fieldDom\",\"setItem\",\"stringify\",\"removeItem\",\"removeChild\",\"FRAME_TIMESTEP\",\"simulator\",\"pathPlannerWorker\",\"Worker\",\"onmessage\",\"receivePlannedPath\",\"pathPlannerConfigEditor\",\"physics\",\"createCar\",\"renderer\",\"WebGLRenderer\",\"setPixelRatio\",\"devicePixelRatio\",\"setSize\",\"shadowMap\",\"lastPlanParams\",\"context\",\"_setUpCameras\",\"Scene\",\"sceneFog\",\"FogExp2\",\"fog\",\"background\",\"editor\",\"editorCamera\",\"carObject\",\"manualCarController\",\"autonomousCarController\",\"dashboard\",\"plannerReady\",\"plannerReset\",\"plannerEnabled\",\"plannedPathGroup\",\"paused\",\"prevTimestamp\",\"frameCounter\",\"fpsTime\",\"fps\",\"simulatedTime\",\"lastPlanTime\",\"averagePlanTime\",\"_updateCameraAspects\",\"manualModeButton\",\"enableManualMode\",\"autonomousModeButton\",\"enableAutonomousMode\",\"enableEditor\",\"finalizeEditor\",\"restartScenario\",\"simModeBoxes\",\"getElementsByClassName\",\"editModeBoxes\",\"fpsBox\",\"changeCamera\",\"requestAnimationFrame\",\"timestamp\",\"prevCarPosition\",\"prevCarRotation\",\"autonomousControls\",\"control\",\"carControllerMode\",\"manualControls\",\"carRotation\",\"carRearAxle\",\"carVelocity\",\"positionOffset\",\"chaseCamera\",\"chaseCameraControls\",\"topDownCamera\",\"setX\",\"setZ\",\"stationLatitudeFromPosition\",\"startPlanner\",\"render\",\"rotVec\",\"obstacle\",\"StaticObstacle\",\"obsGeom\",\"obsMat\",\"obsObj\",\"PerspectiveCamera\",\"_resetChaseCamera\",\"freeCamera\",\"freeCameraControls\",\"_resetFreeCamera\",\"topDownControls\",\"editorCameraControls\",\"cameraButtons\",\"cameraButton\",\"dirVector\",\"setY\",\"aspect\",\"previousCamera\",\"visible\",\"replaceCamera\",\"dir\",\"plannerRunning\",\"_resetTopDownCamera\",\"mode\",\"classes\",\"predictedPose\",\"predictPoseAfterTime\",\"postMessage\",\"addSample\",\"setPrototypeOf\",\"followPath\",\"replacePath\",\"circleGeom\",\"circleMat\",\"cells\",\"circle\",\"pathGeometry\",\"pathLine\",\"pathObject\",\"frontMaterial\",\"LineBasicMaterial\",\"frontGeometry\",\"Line\"],\"mappings\":\"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\",\"sourcesContent\":[\" \\t// The module cache\\n \\tvar installedModules = {};\\n\\n \\t// The require function\\n \\tfunction __webpack_require__(moduleId) {\\n\\n \\t\\t// Check if module is in cache\\n \\t\\tif(installedModules[moduleId]) {\\n \\t\\t\\treturn installedModules[moduleId].exports;\\n \\t\\t}\\n \\t\\t// Create a new module (and put it into the cache)\\n \\t\\tvar module = installedModules[moduleId] = {\\n \\t\\t\\ti: moduleId,\\n \\t\\t\\tl: false,\\n \\t\\t\\texports: {}\\n \\t\\t};\\n\\n \\t\\t// Execute the module function\\n \\t\\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\\n\\n \\t\\t// Flag the module as loaded\\n \\t\\tmodule.l = true;\\n\\n \\t\\t// Return the exports of the module\\n \\t\\treturn module.exports;\\n \\t}\\n\\n\\n \\t// expose the modules object (__webpack_modules__)\\n \\t__webpack_require__.m = modules;\\n\\n \\t// expose the module cache\\n \\t__webpack_require__.c = installedModules;\\n\\n \\t// define getter function for harmony exports\\n \\t__webpack_require__.d = function(exports, name, getter) {\\n \\t\\tif(!__webpack_require__.o(exports, name)) {\\n \\t\\t\\tObject.defineProperty(exports, name, {\\n \\t\\t\\t\\tconfigurable: false,\\n \\t\\t\\t\\tenumerable: true,\\n \\t\\t\\t\\tget: getter\\n \\t\\t\\t});\\n \\t\\t}\\n \\t};\\n\\n \\t// define __esModule on exports\\n \\t__webpack_require__.r = function(exports) {\\n \\t\\tObject.defineProperty(exports, '__esModule', { value: true });\\n \\t};\\n\\n \\t// getDefaultExport function for compatibility with non-harmony modules\\n \\t__webpack_require__.n = function(module) {\\n \\t\\tvar getter = module && module.__esModule ?\\n \\t\\t\\tfunction getDefault() { return module['default']; } :\\n \\t\\t\\tfunction getModuleExports() { return module; };\\n \\t\\t__webpack_require__.d(getter, 'a', getter);\\n \\t\\treturn getter;\\n \\t};\\n\\n \\t// Object.prototype.hasOwnProperty.call\\n \\t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\\n\\n \\t// __webpack_public_path__\\n \\t__webpack_require__.p = \\\"\\\";\\n\\n\\n \\t// Load entry module and return exports\\n \\treturn __webpack_require__(__webpack_require__.s = 8);\\n\",\"import Car from \\\"./simple/Car.js\\\";\\n\\nexport default Car;\\n\\n/*\\nexport default class Car {\\n  constructor(world, x = 0, y = 0, rotation = 0) {\\n    this.world = world;\\n    this.setPose(x, y, rotation);\\n  }\\n\\n  static getFrontAxlePosition(pos, rot) {\\n    return THREE.Vector2.fromAngle(rot).multiplyScalar(Car.WHEEL_BASE).add(pos);\\n  }\\n\\n  static getFakeAxlePosition(pos, rot) {\\n    return Car.frontToRearAxlePosition(pos, rot);\\n  }\\n\\n  static centerToRearAxlePosition(pos, rot) {\\n    return THREE.Vector2.fromAngle(rot).multiplyScalar(Car.REAR_AXLE_POS).add(pos);\\n  }\\n\\n  static frontToRearAxlePosition(pos, rot) {\\n    return THREE.Vector2.fromAngle(rot).multiplyScalar(-Car.WHEEL_BASE).add(pos);\\n  }\\n\\n  get pose() {\\n    return { pos: this.rearAxlePosition, rot: this.rotation, velocity: this.velocity, curv: this.curvature, dCurv: 0, ddCurv: 0 };\\n  }\\n\\n  get position() {\\n    const pos = this.body.GetPosition();\\n    return new THREE.Vector2(pos.get_x(), pos.get_y());\\n  }\\n\\n  get rearAxlePosition() {\\n    const { x, y } = this.position;\\n    const rot = this.rotation;\\n    return new THREE.Vector2(x + Math.cos(rot) * Car.REAR_AXLE_POS, y + Math.sin(rot) * Car.REAR_AXLE_POS);\\n  }\\n\\n  get frontAxlePosition() {\\n    const { x, y } = this.position;\\n    const rot = this.rotation;\\n    return new THREE.Vector2(x + Math.cos(rot) * Car.FRONT_AXLE_POS, y + Math.sin(rot) * Car.FRONT_AXLE_POS);\\n  }\\n\\n  get rotation() {\\n    return this.body.GetAngle();\\n  }\\n\\n  get velocity() {\\n    return this.body.GetLinearVelocity().Length();\\n  }\\n\\n  get wheelAngle() {\\n    return Math.wrapAngle(this.leftFrontWheel.joint.GetJointAngle());\\n  }\\n\\n  get curvature() {\\n    return Math.tan(this.wheelAngle) / Car.WHEEL_BASE;\\n  }\\n\\n  setPose(x, y, rotation) {\\n    this.destroyBodies();\\n\\n    // Translate so that x and y become the center of the vehicle (instead of the center of the rear axle)\\n    x -= Car.REAR_AXLE_POS * Math.cos(rotation);\\n    y -= Car.REAR_AXLE_POS * Math.sin(rotation);\\n\\n    const pos = new Box2D.b2Vec2(x, y);\\n    const bd = new Box2D.b2BodyDef();\\n    bd.set_type(Box2D.b2_dynamicBody);\\n    bd.set_position(pos);\\n    bd.set_angle(rotation);\\n    this.body = this.world.CreateBody(bd);\\n    this.body.SetAngularDamping(Car.ANGULAR_DAMPING);\\n\\n    const shape = new Box2D.b2PolygonShape();\\n    shape.SetAsBox(Car.HALF_CAR_LENGTH, Car.HALF_CAR_WIDTH);\\n\\n    const fd = new Box2D.b2FixtureDef();\\n    fd.set_shape(shape);\\n    fd.set_density(Car.CHASSIS_DENSITY);\\n    fd.set_friction(Car.FRICTION);\\n    fd.set_restitution(Car.RESTITUTION);\\n    this.body.CreateFixture(fd);\\n\\n    const lfPos = new Box2D.b2Vec2(Car.FRONT_AXLE_POS, Car.WHEEL_LATERAL_POS);\\n    const rfPos = new Box2D.b2Vec2(Car.FRONT_AXLE_POS, -Car.WHEEL_LATERAL_POS);\\n    const lrPos = new Box2D.b2Vec2(Car.REAR_AXLE_POS, Car.WHEEL_LATERAL_POS);\\n    const rrPos = new Box2D.b2Vec2(Car.REAR_AXLE_POS, -Car.WHEEL_LATERAL_POS);\\n\\n    this.leftFrontWheel = createFrontWheel.call(this, lfPos, pos, rotation);\\n    this.rightFrontWheel = createFrontWheel.call(this, rfPos, pos, rotation);\\n    this.leftRearWheel = createRearWheel.call(this, lrPos, pos, rotation);\\n    this.rightRearWheel = createRearWheel.call(this, rrPos, pos, rotation);\\n\\n    Box2D.destroy(pos);\\n    Box2D.destroy(bd);\\n    Box2D.destroy(shape);\\n    Box2D.destroy(fd);\\n    Box2D.destroy(lfPos);\\n    Box2D.destroy(rfPos);\\n    Box2D.destroy(lrPos);\\n    Box2D.destroy(rrPos);\\n  }\\n\\n  destroyBodies() {\\n    if (this.body) {\\n      this.world.DestroyBody(this.body);\\n      this.body = null;\\n\\n      this.world.DestroyBody(this.leftFrontWheel.body);\\n      this.leftFrontWheel = null;\\n\\n      this.world.DestroyBody(this.rightFrontWheel.body);\\n      this.rightFrontWheel = null;\\n\\n      this.world.DestroyBody(this.leftRearWheel.body);\\n      this.leftRearWheel = null;\\n\\n      this.world.DestroyBody(this.rightRearWheel.body);\\n      this.rightRearWheel = null;\\n    }\\n  }\\n\\n  update(controls, dt) {\\n    const gas = Math.clamp(controls.gas, -1, +1);\\n    const brake = Math.clamp(controls.brake, 0, 1);\\n    const steer = Math.clamp(controls.steer, -1, +1);\\n\\n    const mass = this.body.GetMass();\\n    const velocity = this.body.GetLinearVelocity();\\n    const rotation = this.body.GetAngle();\\n    let velocitySqr = velocity.LengthSquared();\\n    let velocityMag = velocity.Length();\\n    const drag = 0.5 * Car.DRAG_COEFF * Car.FRONTAL_AREA * Car.DENSITY_OF_AIR * velocityMag;\\n    let gasForce = new Box2D.b2Vec2(0, 0);\\n    let brakeForce = new Box2D.b2Vec2(0, 0);\\n\\n    if (brake > 0) {\\n      if (velocityMag > 0.1) {\\n        // brakeForce = MAX_BRAKE_DECEL * mass * brake * velocity / velocityMag\\n        brakeForce.op_add(velocity);\\n        brakeForce.op_mul(Car.MAX_BRAKE_DECEL * mass * brake);\\n        brakeForce.op_mul(1 / velocityMag);\\n      } else {\\n        const zero = new Box2D.b2Vec2(0, 0);\\n        this.body.SetLinearVelocity(zero);\\n        velocity.Set(0, 0);\\n        velocitySqr = 0;\\n        velocityMag = 0;\\n\\n        Box2D.destroy(zero);\\n      }\\n    } else {\\n      const f = Car.MAX_GAS_ACCEL * mass * gas;\\n      Box2D.destroy(gasForce);\\n      gasForce = new Box2D.b2Vec2(f * Math.cos(rotation), f * Math.sin(rotation));\\n    }\\n\\n    // totalForce = gasForce - brakeForce - velocity * (drag + Car.ROLL_RESIST)\\n    const totalForce = new Box2D.b2Vec2(0, 0);\\n    totalForce.op_sub(velocity);\\n    totalForce.op_mul(drag + Car.ROLL_RESIST);\\n    totalForce.op_add(gasForce);\\n    totalForce.op_sub(brakeForce);\\n\\n    this.body.ApplyForceToCenter(totalForce);\\n\\n    const maxWheelAngle = Math.clamp(Math.atan(Car.MAX_LATERAL_ACCEL * Car.WHEEL_BASE / this.body.GetLinearVelocity().LengthSquared()), 0.07, Car.MAX_WHEEL_ANGLE);\\n    this.leftFrontWheel.joint.SetLimits(-maxWheelAngle, maxWheelAngle);\\n    this.rightFrontWheel.joint.SetLimits(-maxWheelAngle, maxWheelAngle);\\n\\n    let motorSpeed;\\n    const wheelAngle = this.leftFrontWheel.joint.GetJointAngle();\\n    if (steer != 0) {\\n      motorSpeed = steer * Car.MAX_STEER_SPEED;\\n    } else {\\n      motorSpeed = Math.clamp(-wheelAngle / Car.MAX_WHEEL_ANGLE * velocitySqr * dt, -Car.MAX_STEER_SPEED, Car.MAX_STEER_SPEED);\\n    }\\n\\n    this.leftFrontWheel.joint.SetMotorSpeed(motorSpeed);\\n    this.rightFrontWheel.joint.SetMotorSpeed(motorSpeed);\\n\\n    ['leftFrontWheel', 'rightFrontWheel', 'leftRearWheel', 'rightRearWheel'].forEach(w => {\\n      const wheel = this[w].body;\\n      const v = wheel.GetLinearVelocity();\\n      const localV = wheel.GetLocalVector(v);\\n      const localDamping = new Box2D.b2Vec2(0, -Car.LATERAL_DAMPING * localV.get_y());\\n\\n      // newV = wheel.GetWorldVector(localDamping) * dt + v\\n      const newV = new Box2D.b2Vec2(0, 0);\\n      newV.op_add(wheel.GetWorldVector(localDamping));\\n      newV.op_mul(dt);\\n      newV.op_add(v);\\n      wheel.SetLinearVelocity(newV);\\n\\n      Box2D.destroy(localDamping);\\n      Box2D.destroy(newV);\\n    });\\n\\n    Box2D.destroy(gasForce);\\n    Box2D.destroy(brakeForce);\\n    Box2D.destroy(totalForce);\\n  }\\n}\\n\\nfunction createWheel(offset, carPosition, rotation) {\\n  const cosRot = Math.cos(rotation);\\n  const sinRot = Math.sin(rotation);\\n  const position = new Box2D.b2Vec2(cosRot * offset.get_x() - sinRot * offset.get_y() + carPosition.get_x(), sinRot * offset.get_x() + cosRot * offset.get_y() + carPosition.get_y());\\n\\n  const bd = new Box2D.b2BodyDef();\\n  bd.set_type(Box2D.b2_dynamicBody);\\n  bd.set_position(position);\\n  bd.set_angle(rotation);\\n\\n  const body = this.world.CreateBody(bd);\\n  const shape = new Box2D.b2PolygonShape();\\n  shape.SetAsBox(Car.HALF_WHEEL_LENGTH, Car.HALF_WHEEL_WIDTH);\\n\\n  const fd = new Box2D.b2FixtureDef();\\n  fd.set_shape(shape);\\n  fd.set_density(Car.WHEEL_DENSITY);\\n  fd.set_friction(Car.FRICTION);\\n  fd.set_restitution(Car.RESTITUTION);\\n  body.CreateFixture(fd);\\n\\n  Box2D.destroy(position);\\n  Box2D.destroy(bd);\\n  Box2D.destroy(shape);\\n  Box2D.destroy(fd);\\n\\n  return body;\\n}\\n\\nfunction createRearWheel(offset, carPosition, rotation) {\\n  const body = createWheel.call(this, offset, carPosition, rotation);\\n  const zero = new Box2D.b2Vec2(0, 0);\\n\\n  const jd = new Box2D.b2WeldJointDef();\\n  jd.set_bodyA(this.body);\\n  jd.set_bodyB(body);\\n  jd.set_localAnchorA(offset);\\n  jd.set_localAnchorB(zero);\\n\\n  const joint = Box2D.castObject(this.world.CreateJoint(jd), Box2D.b2WeldJoint);\\n\\n  Box2D.destroy(zero);\\n  Box2D.destroy(jd);\\n\\n  return { body, joint };\\n}\\n\\nfunction createFrontWheel(offset, carPosition, rotation) {\\n  const body = createWheel.call(this, offset, carPosition, rotation);\\n  const zero = new Box2D.b2Vec2(0, 0);\\n\\n  const jd = new Box2D.b2RevoluteJointDef();\\n  jd.set_bodyA(this.body);\\n  jd.set_bodyB(body);\\n  jd.set_localAnchorA(offset);\\n  jd.set_localAnchorB(zero);\\n  jd.set_enableMotor(true);\\n  jd.set_motorSpeed(0);\\n  jd.set_maxMotorTorque(Car.MAX_WHEEL_MOTOR_TORQUE);\\n  jd.set_enableLimit(true);\\n  jd.set_lowerAngle(-Car.MAX_WHEEL_ANGLE);\\n  jd.set_upperAngle(Car.MAX_WHEEL_ANGLE);\\n\\n  const joint = Box2D.castObject(this.world.CreateJoint(jd), Box2D.b2RevoluteJoint);\\n\\n  Box2D.destroy(zero);\\n  Box2D.destroy(jd);\\n\\n  return { body, joint };\\n}\\n\\nCar.HALF_CAR_LENGTH = 2.5; // meters\\nCar.HALF_CAR_WIDTH = 1; // meters\\nCar.CHASSIS_DENSITY = 1600 / 9.2; // kg / m^3\\nCar.HALF_WHEEL_LENGTH = 0.33; // meters\\nCar.HALF_WHEEL_WIDTH = 0.12; // meters\\nCar.WHEEL_DENSITY = 250; // kg / m^3\\nCar.MAX_WHEEL_MOTOR_TORQUE = 1000; // N * m\\nCar.MAX_WHEEL_ANGLE = 32 / 180 * Math.PI; // radians\\nCar.ANGULAR_DAMPING = 0.3;\\nCar.FRICTION = 0.9;\\nCar.RESTITUTION = 0.1;\\nCar.DRAG_COEFF = 0.7;\\nCar.DENSITY_OF_AIR = 1.8580608; // (kg/m^3)\\nCar.FRONTAL_AREA = 1.85; // m^2\\nCar.ROLL_RESIST = 30;\\nCar.MAX_STEER_SPEED = 0.8;//1.2; // Radians per second\\nCar.MAX_GAS_ACCEL = 3.5; // m / s^2\\nCar.MAX_BRAKE_DECEL = 6.5; // m / s^2\\nCar.LATERAL_DAMPING = 1000;\\nCar.WHEEL_LATERAL_POS = 0.843; // meters\\nCar.FRONT_AXLE_POS = 1.56; // meters\\nCar.REAR_AXLE_POS = -1.37; // meters\\nCar.WHEEL_BASE = Car.FRONT_AXLE_POS - Car.REAR_AXLE_POS; // meters\\nCar.MAX_LATERAL_ACCEL = 9.81; // m / s^2\\n*/\\n\",\"const SIMPSONS_INTERVALS = 8;\\nconst NEWTON_ITERATIONS = 16;\\nconst RELAXATION_ITERATIONS = 32;\\nconst CONVERGENCE_ERROR = 0.01;\\n\\nconst jacobian = new THREE.Matrix3();\\nconst invJacobian = new THREE.Matrix3();\\n\\n// Alternate reference implementation: https://github.com/ApolloAuto/apollo/blob/master/modules/planning/math/spiral_curve/cubic_spiral_curve.cc\\nexport default class CubicPath {\\n  constructor(start, end, params = null) {\\n    this.start = Object.assign({}, start);\\n    this.end = Object.assign({}, end);\\n\\n    if (start.pos) {\\n      this.start.x = start.pos.x;\\n      this.start.y = start.pos.y\\n    }\\n\\n    if (end.pos) {\\n      this.end.x = end.pos.x;\\n      this.end.y = end.pos.y\\n    }\\n\\n    const diffX = this.end.x - this.start.x;\\n    const diffY = this.end.y - this.start.y;\\n    const sinRot = Math.sin(this.start.rot);\\n    const cosRot = Math.cos(this.start.rot);\\n\\n    this.goal = {\\n      x: cosRot * diffX + sinRot * diffY,\\n      y: -sinRot * diffX + cosRot * diffY,\\n      rot: Math.wrapAngle(this.end.rot - this.start.rot),\\n      curv: this.end.curv\\n    };\\n\\n    if (params)\\n      this.params = Object.assign({}, params, { p0: this.start.curv, p3: this.end.curv });\\n    else\\n      this.guessInitialParams();\\n\\n    this.converged = false;\\n  }\\n\\n  guessInitialParams() {\\n    const originalGoal = this.goal;\\n    const dStartCurv = this.start.curv / RELAXATION_ITERATIONS;\\n    const dGoalY = originalGoal.y / RELAXATION_ITERATIONS;\\n    const dGoalRot = originalGoal.rot / RELAXATION_ITERATIONS;\\n    const dGoalCurv = originalGoal.curv / RELAXATION_ITERATIONS;\\n\\n    this.goal = {\\n      x: originalGoal.x,\\n      y: 0,\\n      rot: 0,\\n      curv: 0\\n    };\\n\\n    this.params = {\\n      p0: 0,\\n      p1: 0,\\n      p2: 0,\\n      p3: 0,\\n      sG: originalGoal.x\\n    };\\n\\n    for (let i = 0; i < RELAXATION_ITERATIONS; i++) {\\n      this.params.p0 += dStartCurv;\\n      this.params.p3 += dGoalCurv;\\n      this.goal.y += dGoalY;\\n      this.goal.rot += dGoalRot;\\n      this.goal.curv += dGoalCurv;\\n\\n      this.iterate();\\n    }\\n\\n    this.goal = originalGoal;\\n  }\\n\\n  optimize() {\\n    for (let i = 0; i < NEWTON_ITERATIONS; i++) {\\n      if (this.iterate()) {\\n        this.converged = true;\\n        return true;\\n      }\\n    }\\n\\n    this.converged = false;\\n    return false;\\n  }\\n\\n  iterate() {\\n    const { p0, p1, p2, p3, sG } = this.params;\\n\\n    const ds = sG / SIMPSONS_INTERVALS;\\n    const sG_2 = sG * sG;\\n    const sG_3 = sG_2 * sG;\\n\\n    let dX_p1 = 0;\\n    let dX_p2 = 0;\\n    let dX_sG = 0;\\n    let dY_p1 = 0;\\n    let dY_p2 = 0;\\n    let dY_sG = 0;\\n    let guessX = 0;\\n    let guessY = 0;\\n\\n    let theta, cosTheta, sinTheta, dT_p1, dT_p2, dT_sG;\\n\\n    for (let i = 0, s = 0; i <= SIMPSONS_INTERVALS; i++, s += ds) {\\n      const coeff = i == 0 || i == SIMPSONS_INTERVALS ? 1 : i % 2 == 0 ? 2 : 4;\\n\\n      const a = p0;\\n      const b = (-5.5 * p0 + 9 * p1 - 4.5 * p2 + p3) / sG;\\n      const c = (9 * p0 - 22.5 * p1 + 18 * p2 - 4.5 * p3) / sG_2;\\n      const d = (-4.5 * (p0 - 3 * p1 + 3 * p2 - p3)) / sG_3;\\n\\n      theta = (((d * s / 4 + c / 3) * s + b / 2) * s + a) * s;\\n      cosTheta = Math.cos(theta);\\n      sinTheta = Math.sin(theta);\\n\\n      const s_sG = s / sG;\\n      dT_p1 = ((3.375 * s_sG - 7.5) * s_sG + 4.5) * s_sG * s;\\n      dT_p2 = ((-3.375 * s_sG + 6) * s_sG - 2.25) * s_sG * s;\\n      dT_sG = ((3.375 * (p0 - 3 * p1 + 3 * p2 - p3) * s_sG - 3 * (2 * p0 - 5 * p1 + 4 * p2 - p3)) * s_sG + 0.25 * (11 * p0 - 18 * p1 + 9 * p2 - 2 * p3)) * s_sG * s_sG;\\n\\n      dX_p1 -= coeff * sinTheta * dT_p1;\\n      dX_p2 -= coeff * sinTheta * dT_p2;\\n      dX_sG -= coeff * sinTheta * dT_sG;\\n\\n      dY_p1 += coeff * cosTheta * dT_p1;\\n      dY_p2 += coeff * cosTheta * dT_p2;\\n      dY_sG += coeff * cosTheta * dT_sG;\\n\\n      guessX += coeff * cosTheta;\\n      guessY += coeff * sinTheta;\\n    }\\n\\n    // After the Simpson's integration loop, `theta`, `cosTheta`, `sinTheta`,\\n    // `dT_p1`, `dT_p2`, and `dT_sG` hold the appropriate values for `sG`.\\n\\n    const hOver3 = sG / SIMPSONS_INTERVALS / 3;\\n\\n    const deltaX = this.goal.x - guessX * hOver3;\\n    const deltaY = this.goal.y - guessY * hOver3;\\n    const deltaRot = Math.wrapAngle(this.goal.rot - theta);\\n\\n    if (Math.abs(deltaX) + Math.abs(deltaY) + Math.abs(deltaRot) < CONVERGENCE_ERROR)\\n      return true;\\n\\n    jacobian.set(\\n      dX_p1 * hOver3, dX_p2 * hOver3, cosTheta + dX_sG * hOver3,\\n      dY_p1 * hOver3, dY_p2 * hOver3, sinTheta + dY_sG * hOver3,\\n      dT_p1, dT_p2, dT_sG\\n    );\\n\\n    const [m11, m21, m31, m12, m22, m32, m13, m23, m33] = invJacobian.getInverse(jacobian).elements;\\n\\n    this.params.p1 += m11 * deltaX + m12 * deltaY + m13 * deltaRot;\\n    this.params.p2 += m21 * deltaX + m22 * deltaY + m23 * deltaRot;\\n    this.params.sG += m31 * deltaX + m32 * deltaY + m33 * deltaRot;\\n\\n    return false;\\n  }\\n\\n  buildPath(num) {\\n    const { p0, p1, p2, p3, sG } = this.params;\\n\\n    const sG_2 = sG * sG;\\n    const sG_3 = sG_2 * sG;\\n\\n    const a = p0;\\n    const b = (-5.5 * p0 + 9 * p1 - 4.5 * p2 + p3) / sG;\\n    const c = (9 * p0 - 22.5 * p1 + 18 * p2 - 4.5 * p3) / sG_2;\\n    const d = (-4.5 * (p0 - 3 * p1 + 3 * p2 - p3)) / sG_3;\\n\\n    const path = [{ pos: new THREE.Vector2(this.start.x, this.start.y), rot: this.start.rot, curv: this.start.curv }];\\n    const ds = sG / (num - 1);\\n    let s = ds;\\n    let dx = 0;\\n    let dy = 0;\\n    let prevCosRot = Math.cos(path[0].rot);\\n    let prevSinRot = Math.sin(path[0].rot);\\n\\n    for (let i = 1; i < num - 1; i++) {\\n      const rot = (((d * s / 4 + c / 3) * s + b / 2) * s + a) * s + this.start.rot;\\n      const curv = ((d * s + c) * s + b) * s + a;\\n      const cosRot = Math.cos(rot);\\n      const sinRot = Math.sin(rot);\\n\\n      dx = dx * (i - 1) / i + (cosRot + prevCosRot) / (2 * i);\\n      dy = dy * (i - 1) / i + (sinRot + prevSinRot) / (2 * i);\\n\\n      path.push({ pos: new THREE.Vector2(s * dx + this.start.x, s * dy + this.start.y), rot: rot, curv: curv });\\n\\n      s += ds;\\n      prevCosRot = cosRot;\\n      prevSinRot = sinRot;\\n    }\\n\\n    path.push({ pos: new THREE.Vector2(this.end.x, this.end.y), rot: this.end.rot, curv: this.end.curv });\\n\\n    return path;\\n  }\\n}\\n\",\"// Adapted from https://github.com/turbo/js/blob/master/turbo.js\\n\\nconst vertexShaderCode = `#version 300 es\\nin vec2 position;\\nin vec2 texture;\\nout vec2 kernelPosition;\\n\\nvoid main(void) {\\n  kernelPosition = texture;\\n  gl_Position = vec4(position.xy, 0.0, 1.0);\\n}\\n`;\\n\\nconst fragmentShaderHeader = `#version 300 es\\nprecision highp float;\\nprecision highp int;\\nprecision highp sampler2D;\\nprecision highp sampler2DArray;\\nprecision highp sampler3D;\\nprecision highp samplerCube;\\n\\nin vec2 kernelPosition;\\nout vec4 kernelOut;\\nuniform ivec2 kernelSize;\\n`;\\n\\nexport default class {\\n  static alloc(size, stride) {\\n    if (!Number.isInteger(stride) || stride < 1 || stride > 4)\\n      throw new Error(\\\"Data stride must be an integer between 1 and 4.\\\");\\n\\n    // Find the smallest perfect square greater than or equal to size\\n    const squareSize = Math.pow(Math.ceil(Math.sqrt(size)), 2);\\n\\n    const data = new Float32Array(squareSize * stride);\\n    data.gpgpuSize = size;\\n    data.gpgpuStride = stride;\\n    return data;\\n  }\\n\\n  constructor(configs, shared = {}) {\\n    this._setUpGL();\\n\\n    this.outputTextures = {};\\n    this.sharedTextures = {};\\n\\n    this.programs = configs.map(c => this._prepareProgram(c));\\n\\n    for (const name in shared) {\\n      const { width, height, channels, data, ...options } = shared[name];\\n      this.sharedTextures[name] = this._createTexture(data, width, height, channels, options);\\n    }\\n  }\\n\\n  updateSharedTextures(shared) {\\n    this.sharedTextures = {};\\n\\n    for (const name in shared) {\\n      const { width, height, channels, data, ...options } = shared[name];\\n      this.sharedTextures[name] = this._createTexture(data, width, height, channels, options);\\n    }\\n  }\\n\\n  updateProgram(programOrProgramIndex, config) {\\n    const program = typeof(programOrProgramIndex) == 'number' ? this.programs[programOrProgramIndex] : programOrProgramIndex;\\n\\n    if (!program)\\n      throw new Error(`Program with index ${programOrProgramIndex} does not exist.`);\\n\\n    if (config.inputs)\\n      throw new Error('The `updateProgram` function cannot be used to update inputs. Use `updateProgramInputs` instead.');\\n\\n    if (config.meta)\\n      program.meta = Object.assign(program.meta, config.meta);\\n\\n    if (config.width !== undefined && config.height !== undefined)\\n      this.updateProgramSize(program, config.width, config.height);\\n\\n    if (typeof(config.uniforms) == 'object')\\n      this.updateProgramUniforms(program, config.uniforms);\\n  }\\n\\n  updateProgramInputs(programIndex, inputs) {\\n    const program = this.programs[programIndex];\\n\\n    if (!program)\\n      throw new Error(`Program with index ${programIndex} does not exist.`);\\n\\n    if (program.inputTextures.length != inputs.length)\\n      throw new Error(`You must provide the same number of inputs as when the program was set up: got ${inputs.length} but expected ${program.inputTextures.length}.`);\\n\\n    const previousInputWidth = program.inputWidth;\\n    const previousInputHeight = program.inputHeight;\\n\\n    const config = program.config;\\n\\n    if (config.width === undefined || config.height === undefined) {\\n      program.inputWidth = undefined;\\n      program.inputHeight = undefined;\\n      program.inputDataSize = undefined;\\n    }\\n\\n    this._prepareProgramInputs(program, inputs);\\n\\n    if (program.inputWidth != previousInputWidth || program.inputHeight != previousInputHeight) {\\n      this.gl.useProgram(program.glProgram);\\n      this.gl.uniform2i(program.kernelSizeLocation, program.inputWidth, program.inputHeight);\\n      this._prepareProgramOutput(program);\\n    }\\n  }\\n\\n  updateProgramSize(programOrProgramIndex, width, height) {\\n    const program = typeof(programOrProgramIndex) == 'number' ? this.programs[programOrProgramIndex] : programOrProgramIndex;\\n\\n    if (!program)\\n      throw new Error(`Program with index ${programOrProgramIndex} does not exist.`);\\n\\n    if (program.inputTextures.length != 0)\\n      throw new Error(`Size can only be updated on programs with no inputs.`);\\n\\n    if (width == program.inputWidth && height == program.inputHeight) return;\\n\\n    program.inputWidth = width;\\n    program.inputHeight = height;\\n    program.inputDataSize = width * height;\\n\\n    this.gl.useProgram(program.glProgram);\\n    this.gl.uniform2i(program.kernelSizeLocation, program.inputWidth, program.inputHeight);\\n    this._prepareProgramOutput(program);\\n  }\\n\\n  updateProgramUniforms(programOrProgramIndex, uniforms) {\\n    const program = typeof(programOrProgramIndex) == 'number' ? this.programs[programOrProgramIndex] : programOrProgramIndex;\\n    this.gl.useProgram(program.glProgram);\\n\\n    if (!program)\\n      throw new Error(`Program with index ${programOrProgramIndex} does not exist.`);\\n\\n    for (const uniformName in uniforms) {\\n      const value = uniforms[uniformName];\\n      let uniform;\\n\\n      if (uniform = program.uniforms[uniformName]) {\\n        this._setUniform(uniform.type, uniform.location, value)\\n      } else if (uniform = program.uniformTextures[uniformName]) {\\n        if (typeof(value) != 'object' || value.type != 'texture')\\n          throw new Error(`Expected texture type for uniform ${uniformName}.`);\\n\\n        const { width, height, channels, data, ...options } = uniform;\\n        program.uniformTextures[uniformName].texture = this._createTexture(data, width, height, channels, options);\\n      } else {\\n        throw new Error(`The uniform ${uniformName} does not exist in this program.`);\\n      }\\n    }\\n  }\\n\\n  run() {\\n    const outputs = [];\\n\\n    for (const program of this.programs) {\\n      this.gl.useProgram(program.glProgram);\\n      this.gl.viewport(0, 0, program.inputWidth, program.inputHeight);\\n      this.gl.bindFramebuffer(this.gl.FRAMEBUFFER, program.frameBuffer);\\n\\n      for (const [index, inputTexture] of program.inputTextures.entries()) {\\n        this.gl.activeTexture(this.gl.TEXTURE0 + index);\\n        this.gl.bindTexture(this.gl.TEXTURE_2D, inputTexture);\\n      }\\n\\n      for (const uniformName in program.uniformTextures) {\\n        const uniformTexture = program.uniformTextures[uniformName];\\n        this.gl.activeTexture(this.gl.TEXTURE0 + uniformTexture.index);\\n        this.gl.bindTexture(uniformTexture.target, uniformTexture.texture || this.sharedTextures[uniformTexture.name] || this.outputTextures[uniformTexture.name]);\\n      }\\n\\n      if (typeof(program.draw) == 'function') {\\n        program.draw(this.gl, program);\\n      } else {\\n        this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.textureBuffer);\\n        this.gl.enableVertexAttribArray(program.textureLocation);\\n        this.gl.vertexAttribPointer(program.textureLocation, 2, this.gl.FLOAT, false, 0, 0);\\n        this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.positionBuffer);\\n        this.gl.enableVertexAttribArray(program.positionLocation);\\n        this.gl.vertexAttribPointer(program.positionLocation, 2, this.gl.FLOAT, false, 0, 0);\\n        this.gl.bindBuffer(this.gl.ELEMENT_ARRAY_BUFFER, this.indexBuffer);\\n\\n        if (program.drawProxy) {\\n          const draw = (() => this.gl.drawElements(this.gl.TRIANGLES, 6, this.gl.UNSIGNED_SHORT, 0)).bind(this);\\n          program.drawProxy(this, program, draw);\\n        } else {\\n          this.gl.drawElements(this.gl.TRIANGLES, 6, this.gl.UNSIGNED_SHORT, 0);\\n        }\\n      }\\n\\n      if (program.output && program.output.name && !program.output.read) {\\n        outputs.push(null);\\n      } else {\\n        const output = new Float32Array(program.inputWidth * program.inputHeight * 4);\\n        this.gl.readPixels(0, 0, program.inputWidth, program.inputHeight, this.gl.RGBA, this.gl.FLOAT, output);\\n        outputs.push(output.subarray(0, program.inputDataSize * 4));\\n      }\\n    }\\n\\n    return outputs;\\n  }\\n\\n  _setUpGL() {\\n    let canvas;\\n\\n    if (self.document)\\n      canvas = document.createElement('canvas');\\n    else if (self.OffscreenCanvas)\\n      canvas = new OffscreenCanvas(0, 0);\\n    else\\n      throw new Error('Could not create a canvas.');\\n\\n    const attr = { alpha: false, antialias: false };\\n    this.gl = canvas.getContext(\\\"webgl2\\\", attr) || canvas.getContext(\\\"experimental-webgl2\\\", attr);\\n\\n    if (!this.gl)\\n      throw new Error(\\\"Unable to initialize WebGL2. Your browser may not support it.\\\");\\n\\n    if (!this.gl.getExtension('EXT_color_buffer_float'))\\n      throw new Error('Required WebGL extension EXT_color_buffer_float not supported.');\\n\\n    if (!this.gl.getExtension('OES_texture_float_linear'))\\n      throw new Error('Required WebGL extension OES_texture_float_linear not supported.');\\n\\n    this.positionBuffer = this._newBuffer([-1, -1, 1, -1, 1, 1, -1, 1]);\\n    this.textureBuffer = this._newBuffer([0, 0, 1, 0, 1, 1, 0, 1]);\\n    this.indexBuffer = this._newBuffer([1, 2, 0, 3, 0, 2], Uint16Array, this.gl.ELEMENT_ARRAY_BUFFER);\\n  }\\n\\n  _prepareProgram(config) {\\n    const program = { config };\\n\\n    program.draw = config.draw;\\n    program.drawProxy = config.drawProxy;\\n    program.meta = Object.assign({}, config.meta);\\n\\n    if (config.width && config.height) {\\n      program.inputWidth = config.width;\\n      program.inputHeight = config.height;\\n      program.inputDataSize = config.width * config.height;\\n    }\\n\\n    program.output = config.output;\\n\\n    const kernel = config.kernel;\\n\\n    if (typeof(kernel) != 'string' || kernel.length == 0)\\n      throw new Error(\\\"Kernel code cannot be empty.\\\");\\n\\n    const inputs = config.inputs || [];\\n    const uniforms = config.uniforms || {};\\n\\n    this._prepareProgramInputs(program, inputs);\\n\\n    let fragmentShaderConfig = \\\"\\\";\\n    \\n    for (const index in inputs)\\n      fragmentShaderConfig += `uniform sampler2D _input${index};\\\\n`;\\n\\n    if (program.inputWidth === undefined || program.inputHeight === undefined)\\n      throw new Error(\\\"Unknown kernel size. You must provide either an input or the `width` and `height` parameters in the kernel config.\\\");\\n\\n    program.uniformTextures = {};\\n    program.uniforms = {};\\n\\n    for (const uniformName in uniforms) {\\n      const uniform = uniforms[uniformName];\\n\\n      if (typeof(uniform) == 'number') {\\n        program.uniforms[uniformName] = {\\n          type: 'float',\\n          value: uniform\\n        };\\n        fragmentShaderConfig += `uniform float ${uniformName};\\\\n`;\\n      } else if (Array.isArray(uniform)) {\\n        if (uniform.length < 2 || uniform.length > 4)\\n          throw new Error(`Array uniforms can only have lengths of 2, 3, or 4 elements (corresponding to vec2, vec3, and vec4).`);\\n\\n        const type = ['vec2', 'vec3', 'vec4'][uniform.length - 2];\\n        program.uniforms[uniformName] = {\\n          type: type,\\n          value: uniform\\n        };\\n        fragmentShaderConfig += `uniform ${type} ${uniformName};\\\\n`;\\n      } else {\\n        const { type, width, height, channels, data, value, length, name, ...options } = uniform;\\n\\n        if (type == 'texture' || type == 'outputTexture' || type == 'sharedTexture') {\\n          let target, type;\\n\\n          if (options.textureType == '3D') {\\n            target = this.gl.TEXTURE_3D;\\n            type = 'sampler3D';\\n          } else if (options.textureType == '2DArray') {\\n            target = this.gl.TEXTURE_2D_ARRAY;\\n            type = 'sampler2DArray';\\n          } else {\\n            target = this.gl.TEXTURE_2D;\\n            type = 'sampler2D';\\n          }\\n\\n          if (type == 'texture') {\\n            program.uniformTextures[uniformName] = { target, texture: data ? this._createTexture(data, width, height, channels, options) : null };\\n          } else {\\n            program.uniformTextures[uniformName] = { target, texture: null, name: name || uniformName };\\n          }\\n\\n          fragmentShaderConfig += `uniform ${type} ${uniformName};\\\\n`;\\n        } else {\\n          program.uniforms[uniformName] = { type, value };\\n          if (length !== undefined)\\n            fragmentShaderConfig += `uniform ${type} ${uniformName}[${length}];\\\\n`;\\n          else\\n            fragmentShaderConfig += `uniform ${type} ${uniformName};\\\\n`;\\n        }\\n      }\\n    }\\n\\n    const vertexShader = this.gl.createShader(this.gl.VERTEX_SHADER);\\n    this.gl.shaderSource(vertexShader, config.vertexShader || vertexShaderCode);\\n    this.gl.compileShader(vertexShader);\\n\\n    if (!this.gl.getShaderParameter(vertexShader, this.gl.COMPILE_STATUS)) {\\n      throw new Error(\\n        \\\"Could not build internal vertex shader (fatal).\\\\n\\\" + \\\"\\\\n\\\" +\\n        \\\"--- CODE DUMP ---\\\\n\\\" + vertexShaderCode + \\\"\\\\n\\\\n\\\" +\\n        \\\"--- ERROR LOG ---\\\\n\\\" + this.gl.getShaderInfoLog(vertexShader)\\n      );\\n    }\\n\\n    const fragmentShaderMain = `\\nvoid main() {\\n  kernelOut = vec4(kernel(${[...Array(inputs.length).keys()].map(i => `texture(_input${i}, kernelPosition)`).join(', ')}));\\n}\\n    `;\\n\\n    const fragmentShader = this.gl.createShader(this.gl.FRAGMENT_SHADER);\\n    const fragmentShaderSource = fragmentShaderHeader + fragmentShaderConfig + kernel + fragmentShaderMain;\\n    this.gl.shaderSource(fragmentShader, fragmentShaderSource);\\n    this.gl.compileShader(fragmentShader);\\n\\n    if (!this.gl.getShaderParameter(fragmentShader, this.gl.COMPILE_STATUS)) {\\n      const source = fragmentShaderSource.split('\\\\n');\\n      let dbgMsg = \\\"ERROR: Could not build shader (fatal).\\\\n\\\\n------------------ KERNEL CODE DUMP ------------------\\\\n\\\"\\n\\n      for (let l = 0; l < source.length; l++)\\n        dbgMsg += `${l + 1}> ${source[l]}\\\\n`;\\n\\n      dbgMsg += \\\"\\\\n--------------------- ERROR  LOG ---------------------\\\\n\\\" + this.gl.getShaderInfoLog(fragmentShader);\\n\\n      throw new Error(dbgMsg);\\n    }\\n\\n    program.glProgram = this.gl.createProgram();\\n    this.gl.attachShader(program.glProgram, vertexShader);\\n    this.gl.attachShader(program.glProgram, fragmentShader);\\n    this.gl.linkProgram(program.glProgram);\\n    this.gl.useProgram(program.glProgram);\\n\\n    if (!this.gl.getProgramParameter(program.glProgram, this.gl.LINK_STATUS))\\n      throw new Error('Failed to link GLSL program code.');\\n\\n    let textureIndex = 0;\\n\\n    for (const input of program.inputTextures) {\\n      const location = this.gl.getUniformLocation(program.glProgram, `_input${textureIndex}`);\\n      this.gl.uniform1i(location, textureIndex);\\n      textureIndex++;\\n    }\\n\\n    for (const uniformName in program.uniformTextures) {\\n      program.uniformTextures[uniformName].index = textureIndex;\\n      const location = this.gl.getUniformLocation(program.glProgram, uniformName);\\n      this.gl.uniform1i(location, textureIndex);\\n      textureIndex++;\\n    }\\n\\n    for (const uniformName in program.uniforms) {\\n      const { type, value } = program.uniforms[uniformName];\\n      const location = program.uniforms[uniformName].location = this.gl.getUniformLocation(program.glProgram, uniformName);\\n\\n      if (value !== undefined)\\n        this._setUniform(type, location, value);\\n\\n      delete program.uniforms[uniformName].value;\\n    }\\n\\n    program.kernelSizeLocation = this.gl.getUniformLocation(program.glProgram, 'kernelSize');\\n    this.gl.uniform2i(program.kernelSizeLocation, program.inputWidth, program.inputHeight);\\n\\n    program.positionLocation = this.gl.getAttribLocation(program.glProgram, 'position');\\n    program.textureLocation = this.gl.getAttribLocation(program.glProgram, 'texture');\\n\\n    program.frameBuffer = this.gl.createFramebuffer();\\n    this._prepareProgramOutput(program);\\n\\n    return program;\\n  }\\n\\n  _prepareProgramInputs(program, inputs) {\\n    program.inputTextures = [];\\n\\n    for (const [index, data] of inputs.entries()) {\\n      if (data.gpgpuSize === undefined || data.gpgpuStride === undefined)\\n        throw new Error('GPGPU inputs must be created by the `alloc` function.');\\n\\n      const size = Math.sqrt(data.length / data.gpgpuStride);\\n      if (size <= 0 || size % 1 != 0)\\n        throw new Error('GPGPU input size is expected to be a perfect square.');\\n\\n      if (program.inputWidth === undefined || program.inputHeight === undefined) {\\n        program.inputWidth = size;\\n        program.inputHeight = size;\\n        program.inputDataSize = data.gpgpuSize;\\n      } else if (size != program.inputWidth || size != program.inputHeight) {\\n        throw new Error(`All GPGPU inputs must be of the same size. Received ${data.gpgpuSize} (internal ${size * size}) but expected ${program.inputDataSize} (internal ${program.inputWidth * program.inputHeight}).`);\\n      }\\n\\n      program.inputTextures.push(this._createTexture(data, size, size, data.gpgpuStride));\\n    }\\n  }\\n\\n  _prepareProgramOutput(program) {\\n    this.gl.bindFramebuffer(this.gl.FRAMEBUFFER, program.frameBuffer);\\n\\n    const outputTexture = this._createTexture(null, program.inputWidth, program.inputHeight, 4, program.output);\\n    this.gl.framebufferTexture2D(this.gl.FRAMEBUFFER, this.gl.COLOR_ATTACHMENT0, this.gl.TEXTURE_2D, outputTexture, 0);\\n    const frameBufferStatus = (this.gl.checkFramebufferStatus(this.gl.FRAMEBUFFER) == this.gl.FRAMEBUFFER_COMPLETE);\\n    if (!frameBufferStatus)\\n      throw new Error('Error attaching float texture to framebuffer. Your device is probably incompatible.');\\n\\n    if (program.output && program.output.name)\\n      this.outputTextures[program.output.name] = outputTexture;\\n  }\\n\\n  _setUniform(type, location, value) {\\n    switch (type) {\\n      case 'int': this.gl.uniform1i(location, value); break;\\n      case 'float': Array.isArray(value) ? this.gl.uniform1fv(location, value) : this.gl.uniform1f(location, value); break;\\n      case 'vec2': this.gl.uniform2fv(location, value); break;\\n      case 'vec3': this.gl.uniform3fv(location, value); break;\\n      case 'vec4': this.gl.uniform4fv(location, value); break;\\n      case 'mat3': this.gl.uniformMatrix3fv(location, value); break;\\n      default: throw new Error(`Unknown uniform type ${type}.`);\\n    }\\n  }\\n\\n  _newBuffer(data, klass, target) {\\n    const buf = this.gl.createBuffer();\\n\\n    this.gl.bindBuffer((target || this.gl.ARRAY_BUFFER), buf);\\n    this.gl.bufferData((target || this.gl.ARRAY_BUFFER), new (klass || Float32Array)(data), this.gl.STATIC_DRAW);\\n\\n    return buf;\\n  }\\n\\n  _createTexture(data, width, height, channels, options = {}) {\\n    const texture = this.gl.createTexture();\\n\\n    let internalFormat, format;\\n\\n    switch (channels) {\\n      case 1:\\n        internalFormat = this.gl.R32F;\\n        format = this.gl.RED;\\n        break;\\n      case 2:\\n        internalFormat = this.gl.RG32F;\\n        format = this.gl.RG;\\n        break;\\n      case 3:\\n        internalFormat = this.gl.RGB32F;\\n        format = this.gl.RGB;\\n        break;\\n      case 4:\\n        internalFormat = this.gl.RGBA32F;\\n        format = this.gl.RGBA;\\n        break;\\n      default:\\n        throw(\\\"Texture channels must between 1 and 4.\\\");\\n    }\\n\\n    const target = options.textureType == '3D' ? this.gl.TEXTURE_3D : options.textureType == '2DArray' ? this.gl.TEXTURE_2D_ARRAY : this.gl.TEXTURE_2D;\\n\\n    this.gl.bindTexture(target, texture);\\n    this.gl.texParameteri(target, this.gl.TEXTURE_WRAP_S, this.gl.CLAMP_TO_EDGE);\\n    this.gl.texParameteri(target, this.gl.TEXTURE_WRAP_T, this.gl.CLAMP_TO_EDGE);\\n    this.gl.texParameteri(target, this.gl.TEXTURE_MIN_FILTER, options.filter == 'linear' ? this.gl.LINEAR : this.gl.NEAREST);\\n    this.gl.texParameteri(target, this.gl.TEXTURE_MAG_FILTER, options.filter == 'linear' ? this.gl.LINEAR : this.gl.NEAREST);\\n\\n    if (options.textureType == '3D' || options.textureType == '2DArray') {\\n      this.gl.texImage3D(target, 0, internalFormat, width, height, options.depth, 0, format, this.gl.FLOAT, data);\\n    } else {\\n      this.gl.texImage2D(target, 0, internalFormat, width, height, 0, format, this.gl.FLOAT, data);\\n    }\\n\\n    this.gl.bindTexture(target, null);\\n\\n    return texture;\\n  }\\n}\\n\",\"export default class Car {\\n  constructor(x = 0, y = 0, rotation = 0) {\\n    this.setPose(x, y, rotation);\\n  }\\n\\n  static getFrontAxlePosition(pos, rot) {\\n    return THREE.Vector2.fromAngle(rot).multiplyScalar(Car.WHEEL_BASE).add(pos);\\n  }\\n\\n  static getFakeAxlePosition(pos, rot) {\\n    return Car.frontToRearAxlePosition(pos, rot);\\n  }\\n\\n  static centerToRearAxlePosition(pos, rot) {\\n    return THREE.Vector2.fromAngle(rot).multiplyScalar(Car.REAR_AXLE_POS).add(pos);\\n  }\\n\\n  static frontToRearAxlePosition(pos, rot) {\\n    return THREE.Vector2.fromAngle(rot).multiplyScalar(-Car.WHEEL_BASE).add(pos);\\n  }\\n\\n  get pose() {\\n    return { pos: this.rearAxlePosition, rot: this.rotation, velocity: this.velocity, curv: this.curvature, dCurv: 0, ddCurv: 0 };\\n  }\\n\\n  get curvature() {\\n    return Math.tan(this.wheelAngle) / Car.WHEEL_BASE;\\n  }\\n\\n  get rearAxlePosition() {\\n    const { x, y } = this.position;\\n    const rot = this.rotation;\\n    return new THREE.Vector2(x + Math.cos(rot) * Car.REAR_AXLE_POS, y + Math.sin(rot) * Car.REAR_AXLE_POS);\\n  }\\n\\n  get frontAxlePosition() {\\n    const { x, y } = this.position;\\n    const rot = this.rotation;\\n    return new THREE.Vector2(x + Math.cos(rot) * Car.FRONT_AXLE_POS, y + Math.sin(rot) * Car.FRONT_AXLE_POS);\\n  }\\n\\n  setPose(x, y, rotation) {\\n    // Translate so that x and y become the center of the vehicle (instead of the center of the rear axle)\\n    x -= Car.REAR_AXLE_POS * Math.cos(rotation);\\n    y -= Car.REAR_AXLE_POS * Math.sin(rotation);\\n\\n    this.position = new THREE.Vector2(x, y);\\n    this.rotation = Math.wrapAngle(rotation);\\n    this.velocity = 0;\\n    this.acceleration = 0;\\n    this.wheelAngle = 0;\\n    this.wheelAngularVelocity = 0;\\n    this.dCurv = 0; // derivative with respect to arc length\\n    this.ddCurv = 0; // derivative with respect to arc length\\n  }\\n\\n  step(dt) {\\n    const curvPrev = this.curvature;\\n    const dCurvPrev = this.dCurv;\\n\\n    const drag = (0.5 * Car.DRAG_COEFF * Car.FRONTAL_AREA * Car.DENSITY_OF_AIR * Math.abs(this.velocity) + Car.ROLL_RESIST) * -this.velocity;\\n    this.velocity += (this.acceleration + drag / Car.MASS) * dt;\\n\\n    const velocitySq = this.velocity * this.velocity;\\n    const maxWheelAngle = Math.clamp(Math.atan(Car.MAX_LATERAL_ACCEL * Car.WHEEL_BASE / velocitySq), 0.07, Car.MAX_WHEEL_ANGLE);\\n    this.wheelAngle = Math.clamp(Math.wrapAngle(this.wheelAngle + this.wheelAngularVelocity * dt), -maxWheelAngle, maxWheelAngle);\\n\\n    const angularVelocity = this.velocity * this.curvature;\\n    this.rotation = Math.wrapAngle(this.rotation + angularVelocity * dt);\\n\\n    const dist = this.velocity * dt;\\n    this.position = THREE.Vector2.fromAngle(this.rotation).multiplyScalar(dist).add(this.position);\\n\\n    this.dCurv = (this.curvature - curvPrev) / dist;\\n    this.ddCurv = (this.dCurv - dCurvPrev) / dist;\\n  }\\n\\n  update(controls, dt) {\\n    const gas = Math.clamp(controls.gas, -1, +1);\\n    const brake = Math.clamp(controls.brake, 0, 1);\\n    const steer = Math.clamp(controls.steer, -1, +1);\\n\\n    if (brake > 0) {\\n      this.acceleration = -Math.sign(this.velocity) * Car.MAX_BRAKE_DECEL * brake;\\n      const newVelocity = this.velocity + this.acceleration * dt;\\n\\n      // If applying the braking deceleration at the next step would cause the velocity\\n      // to change directions, then just set the car as stopped.\\n      if (Math.sign(newVelocity) != Math.sign(this.velocity)) {\\n        this.velocity = 0;\\n        this.acceleration = 0;\\n      }\\n    } else {\\n      this.acceleration = Car.MAX_GAS_ACCEL * gas;\\n    }\\n\\n    if (steer != 0) {\\n      this.wheelAngularVelocity = steer * Car.MAX_STEER_SPEED;\\n    } else {\\n      this.wheelAngularVelocity = Math.clamp(-this.wheelAngle / Car.MAX_WHEEL_ANGLE * this.velocity * this.velocity * dt, -Car.MAX_STEER_SPEED, Car.MAX_STEER_SPEED);\\n    }\\n  }\\n}\\n\\nCar.HALF_CAR_LENGTH = 2.5; // meters\\nCar.HALF_CAR_WIDTH = 1; // meters\\nCar.HALF_WHEEL_LENGTH = 0.33; // meters\\nCar.HALF_WHEEL_WIDTH = 0.12; // meters\\nCar.MAX_WHEEL_ANGLE = 32 / 180 * Math.PI; // radians\\nCar.MASS = 1600; // kg\\nCar.DRAG_COEFF = 0.7;\\nCar.DENSITY_OF_AIR = 1.8580608; // (kg/m^3)\\nCar.FRONTAL_AREA = 1.85; // m^2\\nCar.ROLL_RESIST = 0;\\nCar.MAX_STEER_SPEED = 0.8;//1.2; // Radians per second\\nCar.MAX_GAS_ACCEL = 3.5; // m / s^2\\nCar.MAX_BRAKE_DECEL = 6.5; // m / s^2\\nCar.WHEEL_LATERAL_POS = 0.843; // meters\\nCar.FRONT_AXLE_POS = 1.56; // meters\\nCar.REAR_AXLE_POS = -1.37; // meters\\nCar.WHEEL_BASE = Car.FRONT_AXLE_POS - Car.REAR_AXLE_POS; // meters\\nCar.MAX_LATERAL_ACCEL = 9.81; // m / s^2\\n\",\"//const pointsPerSegment = 20;\\nconst halfLaneWidth = 3.7 / 2;\\n\\nconst centerlineGeometry = new THREE.Geometry();\\nconst leftBoundaryGeometry = new THREE.Geometry();\\nconst rightBoundaryGeometry = new THREE.Geometry();\\n\\nexport default class {\\n  constructor() {\\n    //if (pointsPerSegment < 3) throw new Error('There must be at least 2 points per LanePath segment.');\\n\\n    this.anchors = [];\\n    this.centerlines = [];\\n    this.sampleLengths = [];\\n    this.arcLengths = [];\\n    this.rotations = [];\\n    this.leftBoundaries = [];\\n    this.rightBoundaries = [];\\n  }\\n\\n  get centerline() {\\n    return [].concat(...this.centerlines);\\n  }\\n\\n  // TODO: this probably isn't needed (along with this.rotations)\\n  get centerlineRotations() {\\n    return [].concat(...this.rotations);\\n  }\\n\\n  get centerlineLengths() {\\n    return [].concat(...this.arclengths);\\n  }\\n\\n  get leftBoundary() {\\n    return [].concat(...this.leftBoundaries);\\n  }\\n\\n  get rightBoundary() {\\n    return [].concat(...this.rightBoundaries);\\n  }\\n\\n  sampleStations(startStation, num, interval) {\\n    const samples = [];\\n    let anchorIndex = 0;\\n    let sampleIndex = 0;\\n    let totalLength = 0;\\n    let nextStation = startStation;\\n\\n    while (totalLength + this.arcLengths[anchorIndex] < nextStation) {\\n      totalLength += this.arcLengths[anchorIndex];\\n\\n      if (++anchorIndex >= this.arcLengths.length)\\n        throw new Error(`Exhausted lane path before reaching ${num} centerline samples at ${interval}m intervals.`);\\n    }\\n\\n    for (let i = 0; i < num; i++) {\\n      let length = this.sampleLengths[anchorIndex][sampleIndex];\\n      while (totalLength + length < nextStation) {\\n        totalLength += length;\\n\\n        if (++sampleIndex >= this.sampleLengths[anchorIndex].length) {\\n          sampleIndex = 0;\\n\\n          if (++anchorIndex >= this.sampleLengths.length)\\n            throw new Error(`Exhausted lane path before reaching ${num} centerline samples at ${interval}m intervals.`);\\n        }\\n\\n        length = this.sampleLengths[anchorIndex][sampleIndex];\\n      }\\n\\n      const [p0, p1, p2, p3] = this.anchorsForSplineIndex(anchorIndex);\\n      const weight = (sampleIndex + (nextStation - totalLength) / length) / this.sampleLengths[anchorIndex].length;\\n      const pos = catmullRomVec(weight, p0, p1, p2, p3);\\n      const tangent = tangentAt(weight, p0, p1, p2, p3);\\n      const rot = Math.atan2(tangent.y, tangent.x);\\n      const curv = curvatureAt(weight, p0, p1, p2, p3);\\n\\n      samples.push({ pos, rot, curv });\\n      nextStation += interval;\\n    }\\n\\n    return samples;\\n  }\\n\\n  stationLatitudeFromPosition(position, aroundAnchorIndex = null) {\\n    const [anchorIndex, sampleIndex, sampleStation, prevSampleStation] = this._findClosestSample(position, aroundAnchorIndex);\\n\\n    let prevPoint;\\n    let nextPoint;\\n    let prevStation;\\n    let nextStation;\\n\\n    if (anchorIndex == 0 && sampleIndex == 0) {\\n      prevPoint = this.centerlines[anchorIndex][sampleIndex];\\n      nextPoint = this.centerlines[anchorIndex][sampleIndex + 1];\\n      prevStation = 0;\\n      nextStation = this.sampleLengths[anchorIndex][sampleIndex];\\n    } else if (anchorIndex == this.centerlines.length - 1 && sampleIndex == this.centerlines[anchorIndex].length - 1) {\\n      prevPoint = this.centerlines[anchorIndex][sampleIndex - 1];\\n      nextPoint = this.centerlines[anchorIndex][sampleIndex];\\n      prevStation = prevSampleStation;\\n      nextStation = sampleStation;\\n    } else {\\n      prevPoint = sampleIndex == 0 ? this.centerlines[anchorIndex - 1][this.centerlines[anchorIndex - 1].length - 1] : this.centerlines[anchorIndex][sampleIndex - 1];\\n      nextPoint = sampleIndex == this.centerlines[anchorIndex].length - 1 ? this.centerlines[anchorIndex + 1][0] : this.centerlines[anchorIndex][sampleIndex + 1];\\n\\n      const possibleNext = this.centerlines[anchorIndex][sampleIndex];\\n      const possibleProgress = position.clone().sub(prevPoint).dot(possibleNext.clone().sub(prevPoint)) / prevPoint.distanceToSquared(possibleNext);\\n\\n      if (possibleProgress < 1) {\\n        nextPoint = possibleNext;\\n        prevStation = prevSampleStation;\\n        nextStation = sampleStation;\\n      } else {\\n        prevPoint = possibleNext;\\n        prevStation = sampleStation;\\n        nextStation = sampleStation + this.sampleLengths[anchorIndex][sampleIndex];\\n      }\\n    }\\n\\n    const progress = Math.clamp(position.clone().sub(prevPoint).dot(nextPoint.clone().sub(prevPoint)) / prevPoint.distanceToSquared(nextPoint), 0, 1);\\n    const projectedPosition = nextPoint.clone().sub(prevPoint).multiplyScalar(progress).add(prevPoint);\\n\\n    const station = prevStation + (nextStation - prevStation) * progress;\\n    const latitude = Math.sign((nextPoint.x - prevPoint.x) * (position.y - prevPoint.y) - (nextPoint.y - prevPoint.y) * (position.x - prevPoint.x)) * position.distanceTo(projectedPosition);\\n\\n    return [station, latitude, anchorIndex];\\n  }\\n\\n  _findClosestSample(position, aroundAnchorIndex = null) {\\n    let closest = Number.POSITIVE_INFINITY;\\n    let bestAnchorIndex;\\n    let bestSampleIndex;\\n    let bestStation;\\n    let bestPrevStation;\\n\\n    let currStation = 0;\\n    let prevStation = 0;\\n\\n    let startAnchorIndex = 0;\\n    let endAnchorIndex = this.centerlines.length - 1;\\n\\n    if (aroundAnchorIndex !== null) {\\n      startAnchorIndex = Math.max(0, aroundAnchorIndex - 1);\\n      endAnchorIndex = Math.min(this.centerlines.length - 1, aroundAnchorIndex + 1);\\n    }\\n\\n    if (startAnchorIndex > 0) {\\n      for (let anchorIndex = 0; anchorIndex < startAnchorIndex; anchorIndex++) {\\n        currStation += this.arcLengths[anchorIndex];\\n      }\\n\\n      prevStation = currStation - this.sampleLengths[startAnchorIndex - 1][this.sampleLengths[startAnchorIndex - 1].length - 1];\\n    }\\n\\n    for (let anchorIndex = startAnchorIndex; anchorIndex <= endAnchorIndex; anchorIndex++) {\\n      const centerline = this.centerlines[anchorIndex];\\n      for (let sampleIndex = 0; sampleIndex < centerline.length; sampleIndex++) {\\n        const distSq = position.distanceToSquared(centerline[sampleIndex]);\\n        if (distSq < closest) {\\n          closest = distSq;\\n          bestAnchorIndex = anchorIndex;\\n          bestSampleIndex = sampleIndex;\\n          bestStation = currStation;\\n          bestPrevStation = prevStation;\\n        }\\n\\n        prevStation = currStation;\\n        currStation += this.sampleLengths[anchorIndex][sampleIndex];\\n      }\\n    }\\n\\n    return [bestAnchorIndex, bestSampleIndex, bestStation, bestPrevStation];\\n  }\\n\\n  addAnchor(position) {\\n    const index = this.anchors.push(position) - 1;\\n\\n    for (let i = index - 2; i < index; i++)\\n      this.resample(i);\\n  }\\n\\n  updateAnchor(index, position) {\\n    this.anchors[index] = position;\\n\\n    for (let i = index - 2; i <= index + 1; i++)\\n      this.resample(i);\\n  }\\n\\n  resample(index) {\\n    if (index < 0 || index > this.anchors.length - 2) return;\\n\\n    const [p0, p1, p2, p3] = this.anchorsForSplineIndex(index);\\n    const points = [];\\n    const lengths = [];\\n    const pointRotations = [];\\n    const leftBoundary = [];\\n    const rightBoundary = [];\\n    let prevPoint = null;\\n\\n    const pointsPerSegment = Math.ceil(p1.distanceTo(p2) / 1);\\n    const numPoints = index == this.anchors.length - 2 ? pointsPerSegment + 1 : pointsPerSegment;\\n\\n    for (let i = 0; i < numPoints; i++) {\\n      const t = i / pointsPerSegment;\\n      const point = catmullRomVec(t, p0, p1, p2, p3);\\n      points.push(point);\\n\\n      if (prevPoint != null)\\n        lengths.push(prevPoint.distanceTo(point));\\n      prevPoint = point;\\n\\n      const tangent = tangentAt(t, p0, p1, p2, p3);\\n      pointRotations.push(Math.atan2(tangent.y, tangent.x));\\n\\n      const normal = new THREE.Vector2(-tangent.y, tangent.x);\\n\\n      leftBoundary.push(normal.clone().multiplyScalar(-halfLaneWidth).add(point));\\n      rightBoundary.push(normal.clone().multiplyScalar(halfLaneWidth).add(point));\\n    }\\n\\n    lengths.push(prevPoint.distanceTo(p2));\\n\\n    this.centerlines[index] = points;\\n    this.sampleLengths[index] = lengths;\\n    this.rotations[index] = pointRotations;\\n    this.leftBoundaries[index] = leftBoundary;\\n    this.rightBoundaries[index] = rightBoundary;\\n    this.arcLengths[index] = lengths.reduce((sum, l) => sum + l);\\n  }\\n\\n  anchorsForSplineIndex(index) {\\n    let p;\\n    if (index == 0)\\n      p = [this.anchors[0]].concat(this.anchors.slice(0, 3));\\n    else\\n      p = this.anchors.slice(index - 1, index + 3);\\n\\n    if (p[3] === undefined)\\n      p[3] = p[2];\\n\\n    return p;\\n  }\\n}\\n\\nfunction catmullRom(t, p0, p1, p2, p3) {\\n  const v0 = (p2 - p0) * 0.5;\\n  const v1 = (p3 - p1) * 0.5;\\n  const t2 = t * t;\\n  const t3 = t * t2;\\n  return (2 * p1 - 2 * p2 + v0 + v1) * t3 + (-3 * p1 + 3 * p2 - 2 * v0 - v1) * t2 + v0 * t + p1;\\n}\\n\\nfunction catmullRomVec(t, p0, p1, p2, p3) {\\n  return new THREE.Vector2(catmullRom(t, p0.x, p1.x, p2.x, p3.x), catmullRom(t, p0.y, p1.y, p2.y, p3.y));\\n}\\n\\nfunction tangentAt(t, p0, p1, p2, p3) {\\n  const delta = 0.0001;\\n  let t1 = t - delta;\\n  let t2 = t + delta;\\n\\n  if (t1 < 0) t1 = 0;\\n  if (t2 > 1) t2 = 1;\\n\\n  const prev = catmullRomVec(t1, p0, p1, p2, p3);\\n  const next = catmullRomVec(t2, p0, p1, p2, p3);\\n\\n  return next.sub(prev).normalize();\\n}\\n\\nfunction curvatureAt(t2, p0, p1, p2, p3) {\\n  const delta = 0.0001;\\n\\n  // If we're estimating curvature at one of the endpoints of the spline,\\n  // slightly shift it inwards to avoid infinite curvature.\\n  if (t2 == 0) t2 = delta;\\n  if (t2 == 1) t2 = 1 - delta;\\n\\n  let t1 = t2 - delta;\\n  let t3 = t2 + delta;\\n\\n  if (t1 < 0) t1 = 0;\\n  if (t3 > 1) t3 = 1;\\n\\n  const pt1 = catmullRomVec(t1, p0, p1, p2, p3);\\n  const pt2 = catmullRomVec(t2, p0, p1, p2, p3);\\n  const pt3 = catmullRomVec(t3, p0, p1, p2, p3);\\n\\n  return (Math.atan2(pt3.y - pt2.y, pt3.x - pt2.x) - Math.atan2(pt2.y - pt1.y, pt2.x - pt1.x)) / pt2.distanceTo(pt1);\\n}\\n\",\"export default class {\\n  constructor(pos, rot, width, height) {\\n    this.pos = pos;\\n    this.rot = rot;\\n    this.width = width;\\n    this.height = height;\\n\\n    this.updateVertices();\\n  }\\n\\n  updateVertices() {\\n    this.vertices = [];\\n\\n    const cosRot = Math.cos(this.rot);\\n    const sinRot = Math.sin(this.rot);\\n    const halfWidth = this.width / 2;\\n    const halfHeight = this.height / 2;\\n\\n    const hWcR = halfWidth * cosRot;\\n    const hWsR = halfWidth * sinRot;\\n    const hHcR = halfHeight * cosRot;\\n    const hHsR = halfHeight * sinRot;\\n\\n    const v1 = [-hWcR - hHsR + this.pos.x, -hWsR + hHcR + this.pos.y];\\n    const v2 = [-hWcR + hHsR + this.pos.x, -hWsR - hHcR + this.pos.y];\\n    const v3 = [hWcR + hHsR + this.pos.x, hWsR - hHcR + this.pos.y];\\n    const v4 = [hWcR - hHsR + this.pos.x, hWsR + hHcR + this.pos.y];\\n\\n    this.vertices = [\\n      v1[0], v1[1],\\n      v2[0], v2[1],\\n      v3[0], v3[1],\\n      v3[0], v3[1],\\n      v4[0], v4[1],\\n      v1[0], v1[1]\\n    ];\\n  }\\n}\\n\",\"export default class QuinticPath {\\n  constructor(start, end, params) {\\n    this.start = Object.assign({}, start);\\n    this.end = Object.assign({}, end);\\n\\n    if (start.pos) {\\n      this.start.x = start.pos.x;\\n      this.start.y = start.pos.y\\n    }\\n\\n    if (end.pos) {\\n      this.end.x = end.pos.x;\\n      this.end.y = end.pos.y\\n    }\\n\\n    const diffX = this.end.x - this.start.x;\\n    const diffY = this.end.y - this.start.y;\\n    const sinRot = Math.sin(this.start.rot);\\n    const cosRot = Math.cos(this.start.rot);\\n\\n    this.goal = {\\n      x: cosRot * diffX + sinRot * diffY,\\n      y: -sinRot * diffX + cosRot * diffY,\\n      rot: Math.wrapAngle(this.end.rot - this.start.rot),\\n      curv: this.end.curv\\n    };\\n\\n    this.params = Object.assign({}, params, { p0: this.start.curv, p1: this.start.dCurv || 0, p2: this.start.ddCurv || 0, p5: this.end.curv });\\n  }\\n\\n  buildPath(num) {\\n    const { p0, p1, p2, p3, p4, p5, sG } = this.params;\\n\\n    const sG_2 = sG * sG;\\n    const sG_3 = sG_2 * sG;\\n\\n    const a = p0;\\n    const b = p1;\\n    const c = p2 / 2.0;\\n    const d = (-71.875 * p0 + 81.0 * p3 - 10.125 * p4 + p5 - 21.25 * p1 * sG - 2.75 * p2 * sG_2) / sG_3;\\n    const e = (166.5 * p0 - 202.5 * p3 + 40.5 * p4 - 4.5 * p5 + 45.0 * p1 * sG + 4.5 * p2 * sG_2) / (sG_2 * sG_2);\\n    const f = (-95.625 * p0 + 121.5 * p3 - 30.375 * p4 + 4.5 * p5 - 24.75 * p1 * sG - 2.25 * p2 * sG_2) / (sG_2 * sG_3);\\n\\n    const path = [{ pos: new THREE.Vector2(this.start.x, this.start.y), rot: this.start.rot, curv: this.start.curv }];\\n    const ds = sG / (num - 1);\\n    let s = ds;\\n    let dx = 0;\\n    let dy = 0;\\n    let prevCosRot = Math.cos(path[0].rot);\\n    let prevSinRot = Math.sin(path[0].rot);\\n\\n    for (let i = 1; i < num - 1; i++) {\\n      const rot = (((((f * s / 6.0 + e / 5.0) * s + d / 4.0) * s + c / 3.0) * s + b / 2.0) * s + a) * s + this.start.rot;\\n      const curv = ((((f * s + e) * s + d) * s + c) * s + b) * s + a;\\n      const cosRot = Math.cos(rot);\\n      const sinRot = Math.sin(rot);\\n\\n      dx = dx * (i - 1) / i + (cosRot + prevCosRot) / (2 * i);\\n      dy = dy * (i - 1) / i + (sinRot + prevSinRot) / (2 * i);\\n\\n      path.push({ pos: new THREE.Vector2(s * dx + this.start.x, s * dy + this.start.y), rot: rot, curv: curv });\\n\\n      s += ds;\\n      prevCosRot = cosRot;\\n      prevSinRot = sinRot;\\n    }\\n\\n    path.push({ pos: new THREE.Vector2(this.end.x, this.end.y), rot: this.end.rot, curv: this.end.curv });\\n\\n    return path;\\n  }\\n}\\n\",\"const OBSTACLE_VERTEX_SHADER = `#version 300 es\\nuniform mat3 xform;\\nin vec2 position;\\n\\nvoid main(void) {\\n  gl_Position = vec4((xform * vec3(position, 1)).xy, 0, 1);\\n}\\n`;\\n\\nconst OBSTACLE_KERNEL = `\\n  vec4 kernel() {\\n    return vec4(1, 0, 0, 1);\\n  }\\n`;\\n\\nlet obstacleVertices;\\nlet obstacleXform;\\n\\n// Draw obstacle triangles to XY-space obstacle grid\\nexport default {\\n  setUp() {\\n    return {\\n      kernel: OBSTACLE_KERNEL,\\n      vertexShader: OBSTACLE_VERTEX_SHADER,\\n      output: { name: 'xyObstacleGrid' },\\n      draw: (gl, program) => {\\n        gl.clearColor(0, 0, 0, 0);\\n        gl.clear(gl.COLOR_BUFFER_BIT);\\n\\n        if (obstacleVertices.length > 0) {\\n          gl.bindBuffer(gl.ARRAY_BUFFER, gl.createBuffer());\\n          gl.bufferData(gl.ARRAY_BUFFER, obstacleVertices, gl.STATIC_DRAW);\\n          gl.enableVertexAttribArray(program.positionLocation);\\n          gl.vertexAttribPointer(program.positionLocation, 2, gl.FLOAT, false, 0, 0);\\n\\n          const xformLocation = gl.getUniformLocation(program.glProgram, 'xform');\\n          gl.uniformMatrix3fv(xformLocation, false, obstacleXform.elements);\\n\\n          gl.drawArrays(gl.TRIANGLES, 0, obstacleVertices.length / 2);\\n        }\\n      }\\n    };\\n  },\\n\\n  update(config, xyWidth, xyHeight, xyCenterPoint, vehicleXform, obstacles) {\\n    obstacleVertices = new Float32Array(Array.prototype.concat.apply([], obstacles.map(o => o.vertices)));\\n\\n    const translate = new THREE.Matrix3();\\n    translate.set(\\n      1, 0, -xyCenterPoint.x,\\n      0, 1, -xyCenterPoint.y,\\n      0, 0, 1\\n    );\\n\\n    const scale = new THREE.Matrix3();\\n    scale.set(\\n      2 / (xyWidth * config.xyGridCellSize), 0, 0,\\n      0, 2 / (xyHeight * config.xyGridCellSize), 0,\\n      0, 0, 1\\n    );\\n\\n    obstacleXform = scale.multiply(translate).multiply(vehicleXform);\\n\\n    return {\\n      width: xyWidth,\\n      height: xyHeight\\n    }\\n  }\\n}\\n\",\"const SL_OBSTACLE_KERNEL = `\\n\\nvec4 kernel() {\\n  float centerlineWidth = float(textureSize(centerline, 0).x);\\n\\n  vec2 sl = (kernelPosition - 0.5) * vec2(kernelSize) * vec2(slGridCellSize) + slCenterPoint;\\n  float centerlineCoord = sl.x / centerlineStationInterval / centerlineWidth * (centerlineWidth - 1.0) / centerlineWidth + (0.5 / centerlineWidth);\\n  if (centerlineCoord < 0.0 || centerlineCoord > 1.0) return vec4(0);\\n\\n  vec3 centerlineSample = texture(centerline, vec2(centerlineCoord, 0)).xyz;\\n  float perpindicular = centerlineSample.z + radians(90.0);\\n  vec2 xy = centerlineSample.xy + sl.yy * vec2(cos(perpindicular), sin(perpindicular));\\n\\n  vec2 xyTexCoords = (xy - xyCenterPoint) / vec2(textureSize(xyObstacleGrid, 0)) / vec2(xyGridCellSize) + 0.5;\\n  return texture(xyObstacleGrid, xyTexCoords);\\n}\\n\\n`;\\n\\n// Convert XY-space obstacle grid to SL-space obstacle grid\\nexport default {\\n  setUp() {\\n    return {\\n      kernel: SL_OBSTACLE_KERNEL,\\n      output: { name: 'slObstacleGrid' },\\n      uniforms: {\\n        xyObstacleGrid: { type: 'outputTexture' },\\n        slGridCellSize: { type: 'float' },\\n        xyGridCellSize: { type: 'float' },\\n        slCenterPoint: { type: 'vec2' },\\n        xyCenterPoint: { type: 'vec2' },\\n        centerlineStationInterval: { type: 'float' },\\n        centerline: { type: 'sharedTexture' }\\n      }\\n    }\\n  },\\n\\n  update(config, slWidth, slHeight, slCenterPoint, xyCenterPoint) {\\n    return {\\n      width: slWidth,\\n      height: slHeight,\\n      uniforms: {\\n        slGridCellSize: config.slGridCellSize,\\n        xyGridCellSize: config.xyGridCellSize,\\n        slCenterPoint: [slCenterPoint.x, slCenterPoint.y],\\n        xyCenterPoint: [xyCenterPoint.x, xyCenterPoint.y],\\n        centerlineStationInterval: config.centerlineStationInterval\\n      }\\n    }\\n  }\\n}\\n\",\"const SL_OBSTACLE_DILATION_KERNEL = `\\n\\n// TODO: test performance of returning early if non-zero pixel found\\nvec4 kernel() {\\n  float val = 0.0;\\n\\n  for (int d = 0; d <= lethalDilation; d++) {\\n    val = max(val, texture(slObstacleGrid, kernelPosition + delta * vec2(d)).r);\\n    val = max(val, texture(slObstacleGrid, kernelPosition + delta * vec2(-d)).r);\\n  }\\n\\n  for (int d = lethalDilation + 1; d <= lethalDilation + hazardDilation; d++) {\\n    val = max(val, texture(slObstacleGrid, kernelPosition + delta * vec2(d)).r * 0.5);\\n    val = max(val, texture(slObstacleGrid, kernelPosition + delta * vec2(-d)).r * 0.5);\\n  }\\n\\n  val = max(val, step(0.1, val) * 0.5);\\n\\n  return vec4(val, 0, 0, 1);\\n}\\n\\n`;\\n\\nexport default {\\n  setUp() {\\n    return [\\n      { // SL-space obstacle grid S dilation\\n        kernel: SL_OBSTACLE_DILATION_KERNEL,\\n        output: { name: 'slObstacleGridStationDilated' },\\n        uniforms: {\\n          slObstacleGrid: { type: 'outputTexture' },\\n          delta: { type: 'vec2' },\\n          lethalDilation: { type: 'int' },\\n          hazardDilation: { type: 'int' }\\n        }\\n      },\\n      { // SL-space obstacle grid L dilation\\n        kernel: SL_OBSTACLE_DILATION_KERNEL,\\n        output: { name: 'slObstacleGridDilated' },\\n        uniforms: {\\n          slObstacleGrid: { type: 'outputTexture', name: 'slObstacleGridStationDilated' },\\n          delta: { type: 'vec2' },\\n          lethalDilation: { type: 'int' },\\n          hazardDilation: { type: 'int' }\\n        }\\n      }\\n    ];\\n  },\\n\\n  update(config, slWidth, slHeight) {\\n    return [\\n      { // SL-space obstacle grid S dilation\\n        width: slWidth,\\n        height: slHeight,\\n        uniforms: {\\n          delta: [1 / slWidth, 0],\\n          lethalDilation: Math.ceil(config.lethalDilationS / config.slGridCellSize),\\n          hazardDilation: Math.ceil(config.hazardDilationS / config.slGridCellSize)\\n        }\\n      },\\n      { // SL-space obstacle grid L dilation\\n        width: slWidth,\\n        height: slHeight,\\n        uniforms: {\\n          delta: [0, 1 / slHeight],\\n          lethalDilation: Math.ceil(config.lethalDilationL / config.slGridCellSize),\\n          hazardDilation: Math.ceil(config.hazardDilationL / config.slGridCellSize)\\n        }\\n      }\\n    ];\\n  }\\n}\\n\",\"const XYSL_MAP_KERNEL = `\\n\\nvec4 kernel() {\\n  vec2 xy = (kernelPosition - 0.5) * vec2(kernelSize) * vec2(xyGridCellSize) + xyCenterPoint;\\n\\n  int numSamples = textureSize(centerline, 0).x;\\n  int closest = 0;\\n  float closestDist = distance(xy, texelFetch(centerline, ivec2(0, 0), 0).xy);\\n  for (int i = 1; i < numSamples; i++) {\\n    float dist = distance(xy, texelFetch(centerline, ivec2(i, 0), 0).xy);\\n    if (dist < closestDist) {\\n      closestDist = dist;\\n      closest = i;\\n    }\\n  }\\n\\n  vec2 closestPos = texelFetch(centerline, ivec2(closest, 0), 0).xy;\\n  vec2 prev, next;\\n  int prevIndex, nextIndex;\\n\\n  if (closest == 0) {\\n    prevIndex = 0;\\n    nextIndex = 1;\\n    prev = closestPos;\\n    next = texelFetch(centerline, ivec2(1, 0), 0).xy;\\n  } else if (closest == numSamples - 1) {\\n    prevIndex = closest - 1;\\n    nextIndex = closest;\\n    prev = texelFetch(centerline, ivec2(prevIndex, 0), 0).xy;\\n    next = closestPos;\\n  } else {\\n    vec2 before = texelFetch(centerline, ivec2(closest - 1, 0), 0).xy;\\n    vec2 after = texelFetch(centerline, ivec2(closest + 1, 0), 0).xy;\\n\\n    if (distance(before, xy) < distance(after, xy)) {\\n      prevIndex = closest - 1;\\n      nextIndex = closest;\\n      prev = before;\\n      next = closestPos;\\n    } else {\\n      prevIndex = closest;\\n      nextIndex = closest + 1;\\n      prev = closestPos;\\n      next = after;\\n    }\\n  }\\n\\n  float dist = distance(prev, next);\\n  float progress = clamp(dot(xy - prev, next - prev) / dist / dist, 0.0, 1.0);\\n  vec2 projectedPos = (next - prev) * vec2(progress) + prev;\\n\\n  return vec4(\\n    (float(prevIndex) + progress) * centerlineStationInterval,\\n    sign(determinant(mat2(next - prev, xy - prev))) * distance(xy, projectedPos),\\n    0,\\n    0\\n  );\\n}\\n\\n`;\\n\\n// Build XY-SL map\\nexport default {\\n  setUp() {\\n    return {\\n      kernel: XYSL_MAP_KERNEL,\\n      output: { name: 'xyslMap', filter: 'linear' },\\n      uniforms: {\\n        centerline: { type: 'sharedTexture' },\\n        xyCenterPoint: { type: 'vec2' },\\n        xyGridCellSize: { type: 'float'},\\n        centerlineStationInterval: { type: 'float'}\\n      }\\n    };\\n  },\\n\\n  update(config, xyWidth, xyHeight, xyCenterPoint) {\\n    return {\\n      width: xyWidth,\\n      height: xyHeight,\\n      uniforms: {\\n        xyCenterPoint: [xyCenterPoint.x, xyCenterPoint.y],\\n        xyGridCellSize: config.xyGridCellSize,\\n        centerlineStationInterval: config.centerlineStationInterval\\n      }\\n    };\\n  }\\n}\\n\",\"// Config:\\n// num stations\\n// num latitudes\\n// station connectivity\\n// latitude connectivity\\n//\\n// Shared:\\n// lattice\\n\\nconst OPTIMIZE_CUBIC_SHARED = `\\n\\nconst int NEWTON_ITERATIONS = 16;\\nconst int RELAXATION_ITERATIONS = 16;\\nconst float CONVERGENCE_ERROR = 0.01;\\n\\n// These two consts must stay in sync.\\nconst int SIMPSONS_INTERVALS = 8;\\n//const float SIMPSONS_COEFFS[SIMPSONS_INTERVALS + 1] = float[](1.0, 4.0, 2.0, 4.0, 2.0, 4.0, 2.0, 4.0, 2.0, 4.0, 2.0, 4.0, 2.0, 4.0, 2.0, 4.0, 1.0);\\nconst float SIMPSONS_COEFFS[SIMPSONS_INTERVALS + 1] = float[](1.0, 4.0, 2.0, 4.0, 2.0, 4.0, 2.0, 4.0, 1.0);\\n\\nconst float PI = 3.1415926535897932384626433832795;\\nconst float TWO_PI = PI + PI;\\n\\nconst float RELAXATION_ITERATIONS_F = float(RELAXATION_ITERATIONS);\\nconst float SIMPSONS_INTERVALS_F = float(SIMPSONS_INTERVALS);\\n\\nfloat wrapAngle(float angle) {\\n  angle = mod(angle, TWO_PI);\\n  if (angle <= -PI) return angle + TWO_PI;\\n  else if (angle > PI) return angle - TWO_PI;\\n  return angle;\\n}\\n\\nvec4 iterate(vec4 goal, float p0, float p1, float p2, float p3, float sG) {\\n  float ds = sG / SIMPSONS_INTERVALS_F;\\n  float sG_2 = sG * sG;\\n  float sG_3 = sG_2 * sG;\\n\\n  vec3 dX_p = vec3(0.0);\\n  vec3 dY_p = vec3(0.0);\\n  vec2 guess = vec2(0.0);\\n  float s = 0.0;\\n\\n  float theta, cosTheta, sinTheta;\\n  vec3 dT_p;\\n\\n  for (int i = 0; i <= SIMPSONS_INTERVALS; i++) {\\n    float coeff = SIMPSONS_COEFFS[i];\\n\\n    float a = p0;\\n    float b = (-5.5 * p0 + 9.0 * p1 - 4.5 * p2 + p3) / sG;\\n    float c = (9.0 * p0 - 22.5 * p1 + 18.0 * p2 - 4.5 * p3) / sG_2;\\n    float d = (-4.5 * (p0 - 3.0 * p1 + 3.0 * p2 - p3)) / sG_3;\\n\\n    theta = (((d * s / 4.0 + c / 3.0) * s + b / 2.0) * s + a) * s;\\n    cosTheta = cos(theta);\\n    sinTheta = sin(theta);\\n\\n    float s_sG = s / sG;\\n\\n    dT_p = vec3(\\n      // p1\\n      ((3.375 * s_sG - 7.5) * s_sG + 4.5) * s_sG * s,\\n\\n      // p2\\n      ((-3.375 * s_sG + 6.0) * s_sG - 2.25) * s_sG * s,\\n\\n      // sG\\n      ((3.375 * (p0 - 3.0 * p1 + 3.0 * p2 - p3) * s_sG - 3.0 * (2.0 * p0 - 5.0 * p1 + 4.0 * p2 - p3)) * s_sG + 0.25 * (11.0 * p0 - 18.0 * p1 + 9.0 * p2 - 2.0 * p3)) * s_sG * s_sG\\n    );\\n\\n    dX_p -= coeff * sinTheta * dT_p;\\n    dY_p += coeff * cosTheta * dT_p;\\n\\n    guess += coeff * vec2(cosTheta, sinTheta);\\n\\n    s += ds;\\n  }\\n\\n  float hOver3 = sG / SIMPSONS_INTERVALS_F / 3.0;\\n\\n  vec3 delta;\\n  delta.xy = goal.xy - guess * hOver3;\\n  delta.z = wrapAngle(goal.z - theta);\\n\\n  if (abs(delta.x) + abs(delta.y) + abs(delta.z) < CONVERGENCE_ERROR)\\n    return vec4(p1, p2, sG, 1.0);\\n\\n  dX_p.xyz *= hOver3;\\n  dY_p.xyz *= hOver3;\\n  dX_p.z += cosTheta;\\n  dY_p.z += sinTheta;\\n\\n  mat3 invJacobian = inverse(transpose(mat3(dX_p, dY_p, dT_p)));\\n\\n  vec3 deltaP = invJacobian * delta;\\n  vec4 params = vec4(p1, p2, sG, 0.0);\\n  params.xyz += deltaP;\\n\\n  return params;\\n}\\n\\n/* Input:\\n *   start: (vec4)\\n *     x: x position,\\n *     y: y position,\\n *     z: theta rotation,\\n *     w: k curvature\\n *   end: (vec4)\\n *     x: x position,\\n *     y: y position,\\n *     z: theta rotation,\\n *     w: k curvature\\n *\\n * Output: (vec4)\\n *   x: p1,\\n *   y: p2,\\n *   z: sG,\\n *   w: 1 if converged, 0 if not\\n */\\n\\nvec4 optimize(vec4 start, vec4 end) {\\n  // Translate and rotate start and end so that start is at the origin\\n  float sinRot = sin(start.z);\\n  float cosRot = cos(start.z);\\n\\n  vec4 diff = end - start;\\n  vec4 goal;\\n  goal.xy = mat2(cosRot, -sinRot, sinRot, cosRot) * diff.xy;\\n  goal.z = wrapAngle(diff.z);\\n  goal.w = end.w;\\n\\n  vec4 originalGoal = goal;\\n  vec4 dGoal;\\n  dGoal.x = 0.0;\\n  dGoal.yzw = goal.yzw / RELAXATION_ITERATIONS_F;\\n  float dK0 = start.w / RELAXATION_ITERATIONS_F;\\n\\n  // Relax the goal to (x, 0, 0, 0)\\n  goal.yzw = vec3(0, 0, 0);\\n\\n  // Relax the params to (0, 0, 0, 0, goal.x)\\n  float p0 = 0.0;\\n  float p1 = 0.0;\\n  float p2 = 0.0;\\n  float p3 = 0.0;\\n  float sG = goal.x;\\n\\n  if (sG < 0.1) return vec4(0.0);\\n\\n  for (int i = 0; i < RELAXATION_ITERATIONS; i++) {\\n    p0 += dK0;\\n    p3 += dGoal.w;\\n    goal += dGoal;\\n    \\n    vec4 result = iterate(goal, p0, p1, p2, p3, sG);\\n    p1 = result.x;\\n    p2 = result.y;\\n    sG = result.z;\\n  }\\n\\n  goal = originalGoal;\\n\\n  for (int i = 0; i < NEWTON_ITERATIONS; i++) {\\n    vec4 result = iterate(goal, p0, p1, p2, p3, sG);\\n    if (result.w == 1.0) {\\n      result.w = step(0.0, result.z);\\n      return result;\\n    }\\n\\n    p1 = result.x;\\n    p2 = result.y;\\n    sG = result.z;\\n  }\\n\\n  return vec4(p1, p2, sG, 0.0);\\n}\\n\\n`;\\n\\nconst OPTIMIZE_CUBIC_KERNEL = OPTIMIZE_CUBIC_SHARED + `\\n\\n// width: station * latitude index\\n// height: station_conn * lattice_conn\\n//\\n// lattice:\\n// width: latitudes\\n// height: stations\\n\\nvec4 kernel() {\\n  ivec2 indexes = ivec2(kernelPosition * vec2(kernelSize));\\n\\n  int endStation = indexes.x / numLatitudes;\\n  int endLatitude = int(mod(float(indexes.x), float(numLatitudes)));\\n\\n  int startStation = endStation - stationConnectivity + indexes.y / latitudeConnectivity;\\n  int startLatitude = endLatitude - latitudeConnectivity / 2 + int(mod(float(indexes.y), float(latitudeConnectivity)));\\n\\n  if (startStation < 0 || startStation >= numStations || startLatitude < 0 || startLatitude >= numLatitudes)\\n    return vec4(0.0);\\n\\n  vec4 start = texelFetch(lattice, ivec2(startLatitude, startStation), 0);\\n  vec4 end = texelFetch(lattice, ivec2(endLatitude, endStation), 0);\\n\\n  return optimize(start, end);\\n}\\n\\n`;\\n\\nconst OPTIMIZE_CUBIC_FROM_VEHICLE_KERNEL = OPTIMIZE_CUBIC_SHARED + `\\n\\nvec4 kernel() {\\n  ivec2 indexes = ivec2(kernelPosition * vec2(kernelSize));\\n\\n  vec4 start = vec4(0, 0, 0, curvVehicle);\\n  vec4 end = texelFetch(lattice, indexes, 0);\\n\\n  return optimize(start, end);\\n}\\n\\n`;\\n\\nexport default {\\n  setUp() {\\n    return [\\n      { // Cubic paths between lattice nodes\\n        kernel: OPTIMIZE_CUBIC_KERNEL,\\n        output: { name: 'cubicPaths', read: true },\\n        uniforms: {\\n          lattice: { type: 'sharedTexture' },\\n          numStations: { type: 'int' },\\n          numLatitudes: { type: 'int' },\\n          stationConnectivity: { type: 'int' },\\n          latitudeConnectivity: { type: 'int' }\\n        }\\n      },\\n      { // Cubic paths from vehicle to lattice nodes\\n        kernel: OPTIMIZE_CUBIC_FROM_VEHICLE_KERNEL,\\n        output: { name: 'cubicPathsFromVehicle', read: true },\\n        uniforms: {\\n          lattice: { type: 'sharedTexture' },\\n          curvVehicle: { type: 'float' }\\n        }\\n      }\\n    ]\\n  },\\n\\n  update(config, pose) {\\n    return [\\n      { // Cubic paths between lattice nodes\\n        width: config.lattice.numStations * config.lattice.numLatitudes,\\n        height: config.lattice.stationConnectivity * config.lattice.latitudeConnectivity,\\n        uniforms: {\\n          numStations: config.lattice.numStations,\\n          numLatitudes: config.lattice.numLatitudes,\\n          stationConnectivity: config.lattice.stationConnectivity,\\n          latitudeConnectivity: config.lattice.latitudeConnectivity,\\n        }\\n      },\\n      { // Cubic paths from vehicle to lattice nodes\\n        width: config.lattice.numLatitudes,\\n        height: config.lattice.stationConnectivity,\\n        uniforms: {\\n          curvVehicle: pose.curv\\n        }\\n      }\\n    ];\\n  }\\n}\\n\",\"const OPTIMIZE_KERNEL = `\\n\\nconst int NEWTON_ITERATIONS = 32;\\nconst int RELAXATION_ITERATIONS = 32;\\nconst float CONVERGENCE_ERROR = 0.01;\\n\\n// These two consts must stay in sync.\\nconst int SIMPSONS_INTERVALS = 8;\\nconst float SIMPSONS_COEFFS[SIMPSONS_INTERVALS + 1] = float[](1.0, 4.0, 2.0, 4.0, 2.0, 4.0, 2.0, 4.0, 1.0);\\n\\nconst float PI = 3.1415926535897932384626433832795;\\nconst float TWO_PI = PI + PI;\\n\\nconst float RELAXATION_ITERATIONS_F = float(RELAXATION_ITERATIONS);\\nconst float SIMPSONS_INTERVALS_F = float(SIMPSONS_INTERVALS);\\n\\nfloat wrapAngle(float angle) {\\n  angle = mod(angle, TWO_PI);\\n  if (angle <= -PI) return angle + TWO_PI;\\n  else if (angle > PI) return angle - TWO_PI;\\n  return angle;\\n}\\n\\nvec4 iterate(vec4 goal, float p0, float p1, float p2, float p3, float p4, float p5, float sG) {\\n  float ds = sG / SIMPSONS_INTERVALS_F;\\n  float sG_2 = sG * sG;\\n  float sG_3 = sG_2 * sG;\\n\\n  vec3 dX_p = vec3(0.0);\\n  vec3 dY_p = vec3(0.0);\\n  vec2 guess = vec2(0.0);\\n  float s = 0.0;\\n\\n  float theta, cosTheta, sinTheta;\\n  vec3 dT_p;\\n\\n  for (int i = 0; i <= SIMPSONS_INTERVALS; i++) {\\n    float coeff = SIMPSONS_COEFFS[i];\\n\\n    float a = p0;\\n    float b = p1;\\n    float c = p2 / 2.0;\\n    float d = (-71.875 * p0 + 81.0 * p3 - 10.125 * p4 + p5 - 21.25 * p1 * sG - 2.75 * p2 * sG_2) / sG_3;\\n    float e = (166.5 * p0 - 202.5 * p3 + 40.5 * p4 - 4.5 * p5 + 45.0 * p1 * sG + 4.5 * p2 * sG_2) / (sG_2 * sG_2);\\n    float f = (-95.625 * p0 + 121.5 * p3 - 30.375 * p4 + 4.5 * p5 - 24.75 * p1 * sG - 2.25 * p2 * sG_2) / (sG_2 * sG_3);\\n\\n    theta = (((((f * s / 6.0 + e / 5.0) * s + d / 4.0) * s + c / 3.0) * s + b / 2.0) * s + a) * s;\\n    cosTheta = cos(theta);\\n    sinTheta = sin(theta);\\n\\n    float s_2 = s * s;\\n    float s_sG = s / sG;\\n    float s_sG_2 = s_sG * s_sG;\\n    float s_sG_3 = s_sG_2 * s_sG;\\n    float s_sG_4 = s_sG_3 * s_sG;\\n    float s_sG_5 = s_sG_4 * s_sG;\\n\\n    dT_p = vec3(\\n      // p3\\n      ((20.25 * s_sG - 40.5) * s_sG + 20.25) * s_sG_3 * s,\\n\\n      // p4\\n      ((-5.0625 * s_sG + 8.1) * s_sG - 2.53125) * s_sG_3 * s,\\n\\n      // sG\\n      (53.90625 * p0 - 60.75 * p3 + 7.59375 * p4 - 0.75 * p5) * s_sG_4 + 10.625 * p1 * s * s_sG_3 + 0.6875 * p2 * s_2 * s_sG_2 + (-133.2 * p0 + 162.0 * p3 - 32.4 * p4 + 3.6 * p5) * s_sG_5 + (-27.0) * p1 * s * s_sG_4 - 1.8 * p2 * s_2 * s_sG_3 + (79.6875 * p0 - 101.25 * p3 + 25.3125 * p4 - 3.75 * p5) * s_sG_5 * s_sG + 16.5 * p1 * s * s_sG_5 + 1.125 * p2 * s_2 * s_sG_4\\n    );\\n\\n    dX_p -= coeff * sinTheta * dT_p;\\n    dY_p += coeff * cosTheta * dT_p;\\n\\n    guess += coeff * vec2(cosTheta, sinTheta);\\n\\n    s += ds;\\n  }\\n\\n  float hOver3 = sG / SIMPSONS_INTERVALS_F / 3.0;\\n\\n  vec3 delta;\\n  delta.xy = goal.xy - guess * hOver3;\\n  delta.z = wrapAngle(goal.z - theta);\\n\\n  if (abs(delta.x) + abs(delta.y) + abs(delta.z) < CONVERGENCE_ERROR)\\n    return vec4(p3, p4, sG, 1.0);\\n\\n  dX_p.xyz *= hOver3;\\n  dY_p.xyz *= hOver3;\\n  dX_p.z += cosTheta;\\n  dY_p.z += sinTheta;\\n\\n  mat3 invJacobian = inverse(transpose(mat3(dX_p, dY_p, dT_p)));\\n\\n  vec3 deltaP = invJacobian * delta;\\n  vec4 params = vec4(p3, p4, sG, 0.0);\\n  params.xyz += deltaP;\\n\\n  return params;\\n}\\n\\nvec4 optimize(vec4 start, vec4 end) {\\n  // Translate and rotate start and end so that start is at the origin\\n  float sinRot = sin(start.z);\\n  float cosRot = cos(start.z);\\n\\n  vec4 diff = end - start;\\n  vec4 goal;\\n  goal.xy = mat2(cosRot, -sinRot, sinRot, cosRot) * diff.xy;\\n  goal.z = wrapAngle(diff.z);\\n  goal.w = end.w;\\n\\n  vec4 originalGoal = goal;\\n  vec4 dGoal;\\n  dGoal.x = 0.0;\\n  dGoal.yzw = goal.yzw / RELAXATION_ITERATIONS_F;\\n  float d_K0 = start.w / RELAXATION_ITERATIONS_F;\\n  float d_dK0 = dCurvVehicle / RELAXATION_ITERATIONS_F;\\n  float d_ddK0 = ddCurvVehicle / RELAXATION_ITERATIONS_F;\\n\\n  // Relax the goal to (x, 0, 0, 0)\\n  goal.yzw = vec3(0, 0, 0);\\n\\n  // Relax the params to (0, 0, 0, 0, goal.x)\\n  float p0 = 0.0;\\n  float p1 = 0.0;\\n  float p2 = 0.0;\\n  float p3 = 0.0;\\n  float p4 = 0.0;\\n  float p5 = 0.0;\\n  float sG = goal.x;\\n\\n  if (sG < 0.1) return vec4(0.0);\\n\\n  for (int i = 0; i < RELAXATION_ITERATIONS; i++) {\\n    p0 += d_K0;\\n    p1 += d_dK0;\\n    p2 += d_ddK0;\\n    p5 += dGoal.w;\\n    goal += dGoal;\\n    \\n    vec4 result = iterate(goal, p0, p1, p2, p3, p4, p5, sG);\\n    p3 = result.x;\\n    p4 = result.y;\\n    sG = result.z;\\n  }\\n\\n  goal = originalGoal;\\n\\n  for (int i = 0; i < NEWTON_ITERATIONS; i++) {\\n    vec4 result = iterate(goal, p0, p1, p2, p3, p4, p5, sG);\\n    if (result.w == 1.0) {\\n      result.w = step(0.0, result.z);\\n      return result;\\n    }\\n\\n    p3 = result.x;\\n    p4 = result.y;\\n    sG = result.z;\\n  }\\n\\n  return vec4(p3, p4, sG, 0.0);\\n}\\n\\nvec4 kernel() {\\n  ivec2 latticeIndexes = ivec2(kernelPosition * vec2(kernelSize));\\n\\n  vec4 start = vec4(0, 0, 0, curvVehicle);\\n  vec4 end = texelFetch(lattice, latticeIndexes, 0);\\n\\n  return optimize(start, end);\\n}\\n\\n`;\\n\\n// Quintic spiral path optimizer\\n//   * Start of paths is the vehicle pose\\n//     * x-pos, y-pos, and rotation aren't needed, since the lattice origin is the vehicle pose\\n//     * So assume position and rotation are 0\\n//   * Ends of paths are all latitudes within the first (stationConnectivity) stations\\nexport default {\\n  setUp() {\\n    return {\\n      kernel: OPTIMIZE_KERNEL,\\n      output: { name: 'quinticPathsFromVehicle', read: true },\\n      uniforms: {\\n        lattice: { type: 'sharedTexture' },\\n        curvVehicle: { type: 'float' },\\n        dCurvVehicle: { type: 'float' },\\n        ddCurvVehicle: { type: 'float' }\\n      }\\n    };\\n  },\\n\\n  update(config, pose) {\\n    return {\\n      width: config.lattice.numLatitudes,\\n      height: config.lattice.stationConnectivity,\\n      uniforms: {\\n        curvVehicle: pose.curv,\\n        dCurvVehicle: pose.dCurv,\\n        ddCurvVehicle: pose.ddCurv\\n      }\\n    };\\n  }\\n}\\n\",\"const SHARED_SHADER = `\\n\\nconst float smallV = 0.01;\\nvec4 pathSamples[128];\\nfloat pathSampleCurvRates[128];\\n\\nfloat calculateAcceleration(int index, float initialVelocitySq, float distance) {\\n  if (index <= 4) {\\n    // [aMaxHard, aMinHard, aMaxSoft, aMinSoft, 0]\\n    return accelerationProfiles[index];\\n  } else {\\n    float finalVelocity = finalVelocityProfiles[index - 5];\\n    if (distance < 0.001) return 0.0;\\n    return clamp((finalVelocity * finalVelocity - initialVelocitySq) / (2.0 * distance), accelerationProfiles[1], accelerationProfiles[0]);\\n  }\\n}\\n\\nfloat sampleStaticCost(vec4 xytk) {\\n  vec2 xyTexCoords = (xytk.xy - xyCenterPoint) / vec2(textureSize(xyslMap, 0)) / vec2(xyGridCellSize) + 0.5;\\n  vec2 sl = texture(xyslMap, xyTexCoords).xy;\\n\\n  vec2 slTexCoords = (sl - slCenterPoint) / vec2(textureSize(slObstacleGrid, 0)) / vec2(slGridCellSize) + 0.5;\\n  float obstacleCost = texture(slObstacleGrid, slTexCoords).r;\\n\\n  if (obstacleCost >= 0.75) return -1.0; // Infinite cost\\n  obstacleCost = step(0.25, obstacleCost) * obstacleHazardCost;\\n\\n  float absLatitude = abs(sl.y);\\n  float laneCost = max(absLatitude * laneCostSlope, step(laneShoulderLatitude, absLatitude) * laneShoulderCost);\\n\\n  return obstacleCost + laneCost;\\n}\\n\\nfloat sampleDynamicCost(vec4 xytk, float time, float velocity, float acceleration) {\\n  return 1.0;\\n}\\n\\nfloat calculateAverageStaticCost(int numSamples) {\\n  float averageStaticCost = 0.0;\\n\\n  for (int i = 0; i < numSamples; i++) {\\n    float cost = sampleStaticCost(pathSamples[i]);\\n\\n    if (cost < 0.0) return cost;\\n\\n    averageStaticCost += cost;\\n  }\\n\\n  averageStaticCost /= float(numSamples);\\n\\n  return averageStaticCost;\\n}\\n\\nfloat calculateAverageDynamicCost(int numSamples, float pathLength, float initialVelocity, float acceleration) {\\n  float s = 0.0;\\n  float ds = pathLength / float(numSamples - 1);\\n  float averageDynamicCost = 0.0;\\n  float maxVelocity = 0.0;\\n  float maxLateralAcceleration = 0.0;\\n\\n  for (int i = 0; i < numSamples; i++) {\\n    vec4 pathSample = pathSamples[i]; // vec4(x-pos, y-pos, theta (rotation), kappa (curvature))\\n\\n    float velocitySq = 2.0 * acceleration * s + initialVelocity * initialVelocity;\\n    float velocity = max(smallV, sqrt(max(0.0, velocitySq)));\\n    maxVelocity = max(maxVelocity, velocity);\\n    maxLateralAcceleration = max(maxLateralAcceleration, abs(pathSample.w * velocity * velocity));\\n\\n    float time = 2.0 * s / (initialVelocity + velocity);\\n\\n    float dCurv = pathSampleCurvRates[i] * velocity;\\n    if (dCurv > dCurvatureMax) return -1.0;\\n\\n    float cost = sampleDynamicCost(pathSample, time, velocity, acceleration);\\n    if (cost < 0.0) return cost;\\n\\n    averageDynamicCost += cost;\\n    s += ds;\\n  }\\n\\n  averageDynamicCost /= float(numSamples);\\n\\n  // Apply speeding penality if any velocity along the trajectory is over the speed limit\\n  averageDynamicCost += step(speedLimit, maxVelocity) * speedLimitPenalty;\\n\\n  // Apply hard acceleration/deceleration penalties if the acceleration/deceleration exceeds the soft limits\\n  averageDynamicCost += step(accelerationProfiles[2] + 0.0001, acceleration) * hardAccelerationPenalty;\\n  averageDynamicCost += (1.0 - step(accelerationProfiles[3], acceleration)) * hardDecelerationPenalty;\\n\\n  // Penalize lateral acceleration\\n  averageDynamicCost += step(lateralAccelerationLimit, maxLateralAcceleration) * softLateralAccelerationPenalty;\\n  averageDynamicCost += linearLateralAccelerationPenalty * maxLateralAcceleration;\\n\\n  return averageDynamicCost;\\n}\\n\\nvec3 calculateAVT(int accelerationIndex, float initialVelocity, float initialTime, float pathLength) {\\n  float initialVelocitySq = initialVelocity * initialVelocity;\\n  float acceleration = calculateAcceleration(accelerationIndex, initialVelocitySq, pathLength);\\n\\n  float finalVelocitySq = 2.0 * acceleration * pathLength + initialVelocitySq;\\n  float finalVelocity = max(smallV, sqrt(max(0.0, finalVelocitySq)));\\n\\n  float finalTime = initialTime;\\n\\n  if (acceleration == 0.0) {\\n    finalTime += pathLength / finalVelocity;\\n  } else if (finalVelocitySq <= 0.0) { // Calculate final time if the vehicle stops before the end of the trajectory\\n    float distanceLeft = pathLength - (smallV * smallV - initialVelocitySq) / (2.0 * acceleration);\\n    finalTime += (finalVelocity - initialVelocity) / acceleration + distanceLeft / smallV;\\n  } else {\\n    finalTime += 2.0 * pathLength / (finalVelocity + initialVelocity);\\n  }\\n\\n  return vec3(acceleration, finalVelocity, finalTime);\\n}\\n\\n`;\\n\\nconst SAMPLE_CUBIC_PATH_FN = `\\n\\nint sampleCubicPath(vec4 start, vec4 end, vec4 cubicPathParams) {\\n  float p0 = start.w;\\n  float p1 = cubicPathParams.x;\\n  float p2 = cubicPathParams.y;\\n  float p3 = end.w;\\n  float sG = cubicPathParams.z;\\n\\n  if (sG <= 0.0) return 0;\\n\\n  int numSamples = int(ceil(sG / pathSamplingStep)) + 1;\\n\\n  float sG_2 = sG * sG;\\n  float sG_3 = sG_2 * sG;\\n\\n  float a = p0;\\n  float b = (-5.5 * p0 + 9.0 * p1 - 4.5 * p2 + p3) / sG;\\n  float c = (9.0 * p0 - 22.5 * p1 + 18.0 * p2 - 4.5 * p3) / sG_2;\\n  float d = (-4.5 * (p0 - 3.0 * p1 + 3.0 * p2 - p3)) / sG_3;\\n\\n  pathSamples[0] = start;\\n\\n  float ds = sG / float(numSamples - 1);\\n  float s = ds;\\n  vec2 dxy = vec2(0);\\n  vec2 prevCosSin = vec2(cos(start.z), sin(start.z));\\n\\n  for (int i = 1; i < numSamples; i++) {\\n    float rot = (((d * s / 4.0 + c / 3.0) * s + b / 2.0) * s + a) * s + start.z;\\n    float curv = ((d * s + c) * s + b) * s + a;\\n\\n    vec2 cosSin = vec2(cos(rot), sin(rot));\\n    dxy = dxy * vec2(float(i - 1) / float(i)) + (cosSin + prevCosSin) / vec2(2 * i);\\n\\n    pathSamples[i] = vec4(dxy * vec2(s) + start.xy, rot, curv);\\n    pathSampleCurvRates[i] = b + s * (2.0 * c + 3.0 * d * s);\\n\\n    s += ds;\\n    prevCosSin = cosSin;\\n  }\\n\\n  return numSamples;\\n}\\n\\n`;\\n\\nconst SAMPLE_QUINTIC_PATH_FN = `\\n\\nint sampleQuinticPath(vec4 start, vec4 end, vec4 quinticPathParams) {\\n  float p0 = start.w;\\n  float p1 = dCurvVehicle;\\n  float p2 = ddCurvVehicle;\\n  float p3 = quinticPathParams.x;\\n  float p4 = quinticPathParams.y;\\n  float p5 = end.w;\\n  float sG = quinticPathParams.z;\\n\\n  if (sG <= 0.0) return 0;\\n\\n  int numSamples = int(ceil(sG / pathSamplingStep)) + 1;\\n\\n  float sG_2 = sG * sG;\\n  float sG_3 = sG_2 * sG;\\n\\n  float a = p0;\\n  float b = p1;\\n  float c = p2 / 2.0;\\n  float d = (-71.875 * p0 + 81.0 * p3 - 10.125 * p4 + p5 - 21.25 * p1 * sG - 2.75 * p2 * sG_2) / sG_3;\\n  float e = (166.5 * p0 - 202.5 * p3 + 40.5 * p4 - 4.5 * p5 + 45.0 * p1 * sG + 4.5 * p2 * sG_2) / (sG_2 * sG_2);\\n  float f = (-95.625 * p0 + 121.5 * p3 - 30.375 * p4 + 4.5 * p5 - 24.75 * p1 * sG - 2.25 * p2 * sG_2) / (sG_2 * sG_3);\\n\\n  pathSamples[0] = start;\\n\\n  float ds = sG / float(numSamples - 1);\\n  float s = ds;\\n  vec2 dxy = vec2(0);\\n  vec2 prevCosSin = vec2(cos(start.z), sin(start.z));\\n\\n  for (int i = 1; i < numSamples; i++) {\\n    float rot = (((((f * s / 6.0 + e / 5.0) * s + d / 4.0) * s + c / 3.0) * s + b / 2.0) * s + a) * s + start.z;\\n    float curv = ((((f * s + e) * s + d) * s + c) * s + b) * s + a;\\n\\n    vec2 cosSin = vec2(cos(rot), sin(rot));\\n    dxy = dxy * vec2(float(i - 1) / float(i)) + (cosSin + prevCosSin) / vec2(2 * i);\\n\\n    pathSamples[i] = vec4(dxy * vec2(s) + start.xy, rot, curv);\\n    pathSampleCurvRates[i] = b + s * (2.0 * c + s * (3.0 * d + s * (4.0 * e + 5.0 * f * s)));\\n\\n    s += ds;\\n    prevCosSin = cosSin;\\n  }\\n\\n  return numSamples;\\n}\\n\\n`;\\n\\nconst NUM_ACCELERATION_PROFILES = 8;\\nconst NUM_VELOCITY_RANGES = 4;\\nconst NUM_TIME_RANGES = 2;\\n\\nconst SHARED_UNIFORMS = {\\n  xyslMap: { type: 'outputTexture' },\\n  slObstacleGrid: { type: 'outputTexture', name: 'slObstacleGridDilated' },\\n  accelerationProfiles: { type: 'float', length: 5 },\\n  finalVelocityProfiles: { type: 'float', length: 3 },\\n  xyCenterPoint: { type: 'vec2' },\\n  xyGridCellSize: { type: 'float' },\\n  slCenterPoint: { type: 'vec2' },\\n  slGridCellSize: { type: 'float'},\\n  laneCostSlope: { type: 'float'},\\n  laneShoulderCost: { type: 'float'},\\n  laneShoulderLatitude: { type: 'float'},\\n  obstacleHazardCost: { type: 'float' },\\n  speedLimit: { type: 'float' },\\n  speedLimitPenalty: { type: 'float' },\\n  hardAccelerationPenalty: { type: 'float' },\\n  hardDecelerationPenalty: { type: 'float' },\\n  lateralAccelerationLimit: { type: 'float' },\\n  softLateralAccelerationPenalty: { type: 'float' },\\n  linearLateralAccelerationPenalty: { type: 'float' },\\n  dCurvatureMax: { type: 'float' },\\n  pathSamplingStep: { type: 'float' },\\n  rearAxleToCenter: { type: 'float' }\\n};\\n\\nfunction buildUniformValues(config, xyCenterPoint, slCenterPoint) {\\n  return {\\n    accelerationProfiles: [3.5, -6.5, 2.0, -3.0, 0],\\n    finalVelocityProfiles: [0.999 * config.speedLimit, 1.0, 0.01],\\n    xyCenterPoint: [xyCenterPoint.x, xyCenterPoint.y],\\n    xyGridCellSize: config.xyGridCellSize,\\n    slCenterPoint: [slCenterPoint.x, slCenterPoint.y],\\n    slGridCellSize: config.slGridCellSize,\\n    laneCostSlope: config.laneCostSlope,\\n    laneShoulderCost: config.laneShoulderCost,\\n    laneShoulderLatitude: config.laneShoulderLatitude,\\n    obstacleHazardCost: config.obstacleHazardCost,\\n    speedLimit: config.speedLimit,\\n    speedLimitPenalty: config.speedLimitPenalty,\\n    hardAccelerationPenalty: config.hardAccelerationPenalty,\\n    hardDecelerationPenalty: config.hardDecelerationPenalty,\\n    lateralAccelerationLimit: config.lateralAccelerationLimit,\\n    softLateralAccelerationPenalty: config.softLateralAccelerationPenalty,\\n    linearLateralAccelerationPenalty: config.linearLateralAccelerationPenalty,\\n    dCurvatureMax: config.dCurvatureMax,\\n    pathSamplingStep: config.pathSamplingStep,\\n    rearAxleToCenter: config.rearAxleToCenter\\n  };\\n}\\n\\nexport {\\n  SHARED_SHADER,\\n  SAMPLE_CUBIC_PATH_FN,\\n  SAMPLE_QUINTIC_PATH_FN,\\n\\n  NUM_ACCELERATION_PROFILES,\\n  NUM_VELOCITY_RANGES,\\n  NUM_TIME_RANGES,\\n\\n  SHARED_UNIFORMS,\\n  buildUniformValues\\n}\\n\",\"import { SHARED_SHADER, SAMPLE_CUBIC_PATH_FN, SAMPLE_QUINTIC_PATH_FN, NUM_ACCELERATION_PROFILES, SHARED_UNIFORMS, buildUniformValues } from \\\"./graphSearchShared.js\\\";\\n\\nfunction fromVehiclePathCostsKernel(pathType) {\\n  return SHARED_SHADER + (pathType == 'cubic' ? SAMPLE_CUBIC_PATH_FN : SAMPLE_QUINTIC_PATH_FN) +\\n\\n`\\n\\n/* Calculate cost of a {cubic|quintic} path from vehicle to (stationConnectivity * numLatitudes * numAccelerations) nodes\\n *   width: numLatitudes\\n *   height: station * numAccelerations\\n */\\nvec4 kernel() {\\n  ivec2 indexes = ivec2(kernelPosition * vec2(kernelSize));\\n\\n  int latitude = indexes.x;\\n  int station = indexes.y / numAccelerations;\\n  int accelerationIndex = int(mod(float(indexes.y), float(numAccelerations)));\\n\\n  vec4 pathStart = vec4(0, 0, 0, curvVehicle);\\n  vec4 pathEnd = texelFetch(lattice, ivec2(latitude, station), 0);\\n\\n  vec4 pathParams = texelFetch(pathsFromVehicle, ivec2(latitude, station), 0);\\n\\n  // If the path didn't converge\\n  if (pathParams.w == 0.0) return vec4(-1);\\n\\n  int numSamples = ${pathType == 'cubic' ? 'sampleCubicPath' : 'sampleQuinticPath'}(pathStart, pathEnd, pathParams);\\n  float pathLength = pathParams.z;\\n\\n  if (numSamples < 2) return vec4(-1);\\n\\n  float averageStaticCost = calculateAverageStaticCost(numSamples);\\n  if (averageStaticCost < 0.0) return vec4(-1);\\n\\n  int slIndex = station * kernelSize.x + latitude;\\n  float hysteresisAdjustment = (slIndex == firstLatticePoint || slIndex == secondLatticePoint) ?  0.0 : hysteresisDiscount;\\n  averageStaticCost += hysteresisAdjustment;\\n\\n  vec3 avt = calculateAVT(accelerationIndex, velocityVehicle, 0.0, pathLength);\\n  float acceleration = avt.x;\\n  float finalVelocity = avt.y;\\n  float finalTime = avt.z;\\n\\n  float averageDynamicCost = calculateAverageDynamicCost(numSamples, pathLength, velocityVehicle, acceleration);\\n  if (averageDynamicCost < 0.0) return vec4(-1);\\n\\n  averageDynamicCost += accelerationChangePenalty;\\n\\n  // The cost of a trajectory is the average sample cost scaled by the path length\\n  float totalCost = (averageStaticCost + averageDynamicCost + ${pathType == 'cubic' ? '(cubicPathPenalty * velocityVehicle * velocityVehicle)' : '0.0'}) * pathLength;\\n\\n  return vec4(totalCost, finalVelocity, finalTime, ${pathType == 'cubic' ? '-2' : '-1'});\\n}\\n\\n`;\\n}\\n\\nexport default {\\n  setUp() {\\n    return [\\n      {\\n        kernel: fromVehiclePathCostsKernel('cubic'),\\n        output: { name: 'cubicPathFromVehicleCosts' },\\n        uniforms: {\\n          ...SHARED_UNIFORMS,\\n          lattice: { type: 'sharedTexture' },\\n          pathsFromVehicle: { type: 'outputTexture', name: 'cubicPathsFromVehicle' },\\n          firstLatticePoint: { type: 'int' },\\n          secondLatticePoint: { type: 'int' },\\n          velocityVehicle: { type: 'float' },\\n          curvVehicle: { type: 'float' },\\n          numAccelerations: { type: 'int' },\\n          cubicPathPenalty: { type: 'float' },\\n          hysteresisDiscount: { type: 'float' },\\n          accelerationChangePenalty: { type: 'float' }\\n        }\\n      },\\n      {\\n        kernel: fromVehiclePathCostsKernel('quintic'),\\n        output: { name: 'quinticPathFromVehicleCosts' },\\n        uniforms: {\\n          ...SHARED_UNIFORMS,\\n          lattice: { type: 'sharedTexture' },\\n          pathsFromVehicle: { type: 'outputTexture', name: 'quinticPathsFromVehicle' },\\n          firstLatticePoint: { type: 'int' },\\n          secondLatticePoint: { type: 'int' },\\n          velocityVehicle: { type: 'float' },\\n          curvVehicle: { type: 'float' },\\n          dCurvVehicle: { type: 'float' },\\n          ddCurvVehicle: { type: 'float' },\\n          numAccelerations: { type: 'int' },\\n          hysteresisDiscount: { type: 'float' },\\n          accelerationChangePenalty: { type: 'float' }\\n        }\\n      }\\n    ];\\n  },\\n\\n  update(config, pose, xyCenterPoint, slCenterPoint, firstLatticePoint, secondLatticePoint) {\\n    return [\\n      {\\n        width: config.lattice.numLatitudes,\\n        height: config.lattice.stationConnectivity * NUM_ACCELERATION_PROFILES,\\n        uniforms: {\\n          ...buildUniformValues(config, xyCenterPoint, slCenterPoint),\\n          firstLatticePoint: firstLatticePoint,\\n          secondLatticePoint: secondLatticePoint,\\n          velocityVehicle: pose.velocity,\\n          curvVehicle: pose.curv,\\n          numAccelerations: NUM_ACCELERATION_PROFILES,\\n          cubicPathPenalty: config.cubicPathPenalty,\\n          hysteresisDiscount: config.hysteresisDiscount,\\n          accelerationChangePenalty: config.accelerationChangePenalty\\n        }\\n      },\\n      {\\n        width: config.lattice.numLatitudes,\\n        height: config.lattice.stationConnectivity * NUM_ACCELERATION_PROFILES,\\n        uniforms: {\\n          ...buildUniformValues(config, xyCenterPoint, slCenterPoint),\\n          firstLatticePoint: firstLatticePoint,\\n          secondLatticePoint: secondLatticePoint,\\n          velocityVehicle: pose.velocity,\\n          curvVehicle: pose.curv,\\n          dCurvVehicle: pose.dCurv,\\n          ddCurvVehicle: pose.ddCurv,\\n          numAccelerations: NUM_ACCELERATION_PROFILES,\\n          hysteresisDiscount: config.hysteresisDiscount,\\n          accelerationChangePenalty: config.accelerationChangePenalty\\n        }\\n      }\\n    ];\\n  }\\n}\\n\",\"/* State Lattice Cost Map\\n * \\n * 5-dimensional node: station, latitude, acceleration profile, velocity, time\\n *\\n * A draw call per station s\\n *   * Input to kernel: latitude l, acceleration profile a, velocity range v, time range t\\n *   * Find all SL vertices that can connect to this node\\n *   * For each of those vertices, check if any terminate in this specific velocity and time range\\n *     * Based on initial velocity, initial time, and acceleration\\n *     * Each connected SL vertex should have a * v * t nodes that could possibly terminate at this node\\n *   * For all valid edges, find the one with the lowest cost\\n *\\n * Input:\\n *   * 2D texture array cost map\\n *     * Height: num of latitudes (~20)\\n *     * Width: num of acceleration profiles * num of time ranges * num of velocity ranges (8 * 2 * 4 = ~64)\\n *       * A flattened 3D array:\\n *         d1: acceleration\\n *         d2: velocity\\n *         d3: time\\n *     * Layer: num of stations (~10)\\n *   \\n * Output:\\n *   * 2D texture slice of the next station in the input 2D texture array cost map\\n *\\n * Cost Map Elements:\\n *   * Traversal cost so far\\n *   * Ending velocity\\n *   * Ending time\\n *   * Index of parent node\\n *\\n * Since one cubic path can be shared between multiple trajectories, they need to be pre-optimized.\\n *\\n * Quintic Paths:\\n *   Stations 0 through (numStations - 1) correspond to the stations on the lattice; however,\\n *   a new station (station -1) will be used to signifiy the single vehicle pose node. Either\\n *   a cubic path or quintic path can be used to connect this single node to the lattice\\n *   (depending on vehicle velocity). At station -1, latitude 0 will correspond to a cubic path,\\n *   and latitude 1 will correspond to a quintic path. All other latitudes will be skipped.\\n */\\n\\n// TODO: penalty when acceleration changes from one vertex to another\\n\\nimport { SHARED_SHADER, SAMPLE_CUBIC_PATH_FN, SAMPLE_QUINTIC_PATH_FN, NUM_ACCELERATION_PROFILES, NUM_VELOCITY_RANGES, NUM_TIME_RANGES, SHARED_UNIFORMS, buildUniformValues } from \\\"./graphSearchShared.js\\\";\\n\\nconst SOLVE_STATION_KERNEL =\\n  SHARED_SHADER +\\n  SAMPLE_CUBIC_PATH_FN +\\n  SAMPLE_QUINTIC_PATH_FN +\\n\\n`\\n\\nvec4 kernel() {\\n  ivec2 indexes = ivec2(kernelPosition * vec2(kernelSize));\\n\\n  int latitude = indexes.y;\\n\\n  int numPerTime = numAccelerations * numVelocities;\\n  int timeIndex = indexes.x / numPerTime;\\n  indexes.x -= timeIndex * numPerTime;\\n  int velocityIndex = indexes.x / numAccelerations;\\n  int accelerationIndex = int(mod(float(indexes.x), float(numAccelerations)));\\n\\n  int minLatitude = max(latitude - latitudeConnectivity / 2, 0);\\n  int maxLatitude = min(latitude + latitudeConnectivity / 2, numLatitudes - 1);\\n\\n  int slIndex = station * numLatitudes + latitude;\\n\\n  vec4 pathEnd = texelFetch(lattice, ivec2(latitude, station), 0);\\n\\n  float minVelocity = velocityRanges[velocityIndex];\\n  float maxVelocity = velocityRanges[velocityIndex + 1];\\n\\n  float minTime = timeRanges[timeIndex];\\n  float maxTime = timeRanges[timeIndex + 1];\\n\\n  vec4 bestTrajectory = vec4(-1); // -1 means infinite cost\\n  float bestCost = 1000000000.0;\\n\\n  float hysteresisAdjustment = (slIndex == firstLatticePoint || slIndex == secondLatticePoint) ?  0.0 : hysteresisDiscount;\\n\\n  for (int prevStation = max(station - stationConnectivity, 0); prevStation < station; prevStation++) {\\n    int stationConnectivityIndex = prevStation - station + stationConnectivity;\\n\\n    for (int prevLatitude = minLatitude; prevLatitude <= maxLatitude; prevLatitude++) {\\n      int latitudeConnectivityIndex = prevLatitude - latitude + latitudeConnectivity / 2;\\n      int connectivityIndex = stationConnectivityIndex * latitudeConnectivity + latitudeConnectivityIndex;\\n\\n      vec4 pathStart = texelFetch(lattice, ivec2(prevLatitude, prevStation), 0);\\n      vec4 cubicPathParams = texelFetch(cubicPaths, ivec2(slIndex, connectivityIndex), 0);\\n\\n      // If the path didn't converge\\n      if (cubicPathParams.w == 0.0) continue;\\n\\n      int numSamples = sampleCubicPath(pathStart, pathEnd, cubicPathParams);\\n      float pathLength = cubicPathParams.z;\\n\\n      if (numSamples < 2) continue;\\n\\n      float averageStaticCost = calculateAverageStaticCost(numSamples);\\n      if (averageStaticCost < 0.0) continue;\\n\\n      averageStaticCost += hysteresisAdjustment;\\n\\n      for (int prevVelocity = 0; prevVelocity < numVelocities; prevVelocity++) {\\n        for (int prevTime = 0; prevTime < numTimes; prevTime++) {\\n          for (int prevAccel = 0; prevAccel < numAccelerations; prevAccel++) {\\n            int avtIndex = prevTime * numPerTime + prevVelocity * numAccelerations + prevAccel;\\n\\n            // Cost table entry:\\n            //   x: cost so far\\n            //   y: end velocity\\n            //   z: end time\\n            //   w: parent index\\n            vec4 costTableEntry = texelFetch(costTable, ivec3(avtIndex, prevLatitude, prevStation), 0);\\n\\n            // If cost entry is infinity\\n            if (costTableEntry.x < 0.0) continue;\\n\\n            vec3 avt = calculateAVT(accelerationIndex, costTableEntry.y, costTableEntry.z, pathLength);\\n            float acceleration = avt.x;\\n            float finalVelocity = avt.y;\\n            float finalTime = avt.z;\\n\\n            // If the calculated final velocity does not match this fragment's velocity range, then skip this trajectory\\n            if (finalVelocity < minVelocity || finalVelocity >= maxVelocity) continue;\\n\\n            // If the calculated final time does not match this fragment's time range, then skip this trajectory\\n            if (finalTime < minTime || finalTime >= maxTime) continue;\\n\\n            float averageDynamicCost = calculateAverageDynamicCost(numSamples, pathLength, costTableEntry.y, acceleration);\\n            if (averageDynamicCost < 0.0) continue;\\n\\n            if (accelerationIndex != prevAccel)\\n              averageDynamicCost += accelerationChangePenalty;\\n\\n            // The cost of a trajectory is the average sample cost scaled by the path length\\n            float totalCost = (averageStaticCost + averageDynamicCost) * pathLength + costTableEntry.x;\\n\\n            float terminalCost = totalCost + extraTimePenalty * finalTime;\\n            if (terminalCost >= bestCost) continue;\\n            bestCost = terminalCost;\\n\\n            int incomingIndex = avtIndex + numPerTime * numTimes * (prevLatitude + numLatitudes * prevStation);\\n            bestTrajectory = vec4(totalCost, finalVelocity, finalTime, incomingIndex);\\n          }\\n        }\\n      }\\n    }\\n  }\\n\\n  if (station < stationConnectivity) {\\n    ivec2 slaIndex = ivec2(latitude, station * numAccelerations + accelerationIndex);\\n\\n    vec4 costTableEntry = texelFetch(cubicPathFromVehicleCosts, slaIndex, 0);\\n    float terminalCost;\\n\\n    if (costTableEntry.x >= 0.0) {\\n      terminalCost = costTableEntry.x + extraTimePenalty * costTableEntry.z;\\n\\n      if (terminalCost < bestCost) {\\n        bestCost = terminalCost;\\n        bestTrajectory = costTableEntry;\\n      }\\n    }\\n\\n    costTableEntry = texelFetch(quinticPathFromVehicleCosts, slaIndex, 0);\\n\\n    if (costTableEntry.x >= 0.0) {\\n      terminalCost = costTableEntry.x + extraTimePenalty * costTableEntry.z;\\n\\n      if (terminalCost < bestCost) {\\n        bestCost = terminalCost;\\n        bestTrajectory = costTableEntry;\\n      }\\n    }\\n  }\\n\\n  return bestTrajectory;\\n}\\n\\n`;\\n\\nexport default {\\n  setUp() {\\n    return {\\n      kernel: SOLVE_STATION_KERNEL,\\n      output: { name: 'graphSearch' },\\n      uniforms: {\\n        ...SHARED_UNIFORMS,\\n        lattice: { type: 'sharedTexture' },\\n        costTable: { type: 'sharedTexture', textureType: '2DArray' },\\n        cubicPaths: { type: 'outputTexture' },\\n        cubicPathFromVehicleCosts: { type: 'outputTexture' },\\n        quinticPathFromVehicleCosts: { type: 'outputTexture' },\\n        firstLatticePoint: { type: 'int' },\\n        secondLatticePoint: { type: 'int' },\\n        velocityVehicle: { type: 'float' },\\n        curvVehicle: { type: 'float' },\\n        dCurvVehicle: { type: 'float' },\\n        ddCurvVehicle: { type: 'float' },\\n        extraTimePenalty: { type: 'float' },\\n        hysteresisDiscount: { type: 'float' },\\n        accelerationChangePenalty: { type: 'float' },\\n        numStations: { type: 'int' },\\n        numLatitudes: { type: 'int' },\\n        numAccelerations: { type: 'int' },\\n        numVelocities: { type: 'int' },\\n        numTimes: { type: 'int' },\\n        stationConnectivity: { type: 'int' },\\n        latitudeConnectivity: { type: 'int' },\\n        velocityRanges: { type: 'float', length: NUM_VELOCITY_RANGES + 1 },\\n        timeRanges: { type: 'float', length: NUM_TIME_RANGES + 1 },\\n        station: { type: 'int' } // Updated in `drawProxy`\\n      },\\n      drawProxy: (gpgpu, program, draw) => {\\n        const width = NUM_ACCELERATION_PROFILES * NUM_VELOCITY_RANGES * NUM_TIME_RANGES;\\n        const height = program.meta.lattice.numLatitudes;\\n        const costTable = new Float32Array(width * height * program.meta.lattice.numStations * 4);\\n\\n        for (let s = 0; s < program.meta.lattice.numStations; s++) {\\n          gpgpu.updateProgramUniforms(program, { station: s });\\n          draw();\\n\\n          gpgpu.gl.readPixels(0, 0, width, height, gpgpu.gl.RGBA, gpgpu.gl.FLOAT, costTable, s * width * height * 4);\\n\\n          gpgpu.gl.bindTexture(gpgpu.gl.TEXTURE_2D_ARRAY, gpgpu.sharedTextures.costTable);\\n          gpgpu.gl.copyTexSubImage3D(gpgpu.gl.TEXTURE_2D_ARRAY, 0, 0, 0, s, 0, 0, width, height);\\n        }\\n\\n        gpgpu._graphSearchCostTable = costTable;\\n      }\\n    };\\n  },\\n\\n  update(config, pose, xyCenterPoint, slCenterPoint, firstLatticePoint, secondLatticePoint) {\\n    return {\\n      width: NUM_ACCELERATION_PROFILES * NUM_VELOCITY_RANGES * NUM_TIME_RANGES,\\n      height: config.lattice.numLatitudes,\\n      meta: {\\n        lattice: config.lattice\\n      },\\n      uniforms: {\\n        ...buildUniformValues(config, xyCenterPoint, slCenterPoint),\\n        firstLatticePoint: firstLatticePoint,\\n        secondLatticePoint: secondLatticePoint,\\n        velocityVehicle: pose.velocity,\\n        curvVehicle: pose.curv,\\n        dCurvVehicle: pose.dCurv,\\n        ddCurvVehicle: pose.ddCurv,\\n        extraTimePenalty: config.extraTimePenalty,\\n        hysteresisDiscount: config.hysteresisDiscount,\\n        accelerationChangePenalty: config.accelerationChangePenalty,\\n        numStations: config.lattice.numStations,\\n        numLatitudes: config.lattice.numLatitudes,\\n        numAccelerations: NUM_ACCELERATION_PROFILES,\\n        numVelocities: NUM_VELOCITY_RANGES,\\n        numTimes: NUM_TIME_RANGES,\\n        stationConnectivity: config.lattice.stationConnectivity,\\n        latitudeConnectivity: config.lattice.latitudeConnectivity,\\n        velocityRanges: [0, config.speedLimit / 3, config.speedLimit * 2 / 3, config.speedLimit, 1000000],\\n        timeRanges: [0, 10, 1000000]\\n      }\\n    };\\n  }\\n}\\n\",\"import GPGPU from \\\"../../GPGPU.js\\\";\\nimport Car from \\\"../../physics/Car.js\\\";\\nimport CubicPath from \\\"./CubicPath.js\\\";\\nimport QuinticPath from \\\"./QuinticPath.js\\\";\\nimport xyObstacleGrid from \\\"./gpgpu-programs/xyObstacleGrid.js\\\";\\nimport slObstacleGrid from \\\"./gpgpu-programs/slObstacleGrid.js\\\";\\nimport slObstacleGridDilation from \\\"./gpgpu-programs/slObstacleGridDilation.js\\\";\\nimport xyslMap from \\\"./gpgpu-programs/xyslMap.js\\\";\\nimport optimizeCubicPaths from \\\"./gpgpu-programs/optimizeCubicPaths.js\\\";\\nimport optimizeQuinticPaths from \\\"./gpgpu-programs/optimizeQuinticPaths.js\\\";\\nimport pathFromVehicleCosts from \\\"./gpgpu-programs/pathFromVehicleCosts.js\\\";\\nimport graphSearch from \\\"./gpgpu-programs/graphSearch.js\\\";\\nimport xyObstacleCostGrid from \\\"./gpgpu-programs/xyObstacleCostGrid.js\\\";\\n\\nconst NUM_ACCELERATION_PROFILES = 8;\\nconst NUM_VELOCITY_RANGES = 4;\\nconst NUM_TIME_RANGES = 2;\\n\\n/* Obstacle cost map:\\n *\\n * 1. Rasterize triangles from polygonal obstacles into XY-space occupancy grid\\n * 2. Convert occupancy grid to SL-space\\n *    * Width is spatial horizon of the state lattice\\n *    * Height is lane width\\n *    * Resolution should be higher than XY-grid\\n *    * Get XY position from centerline texture\\n *    * Lookup XY in XY occupancy grid (nearest)\\n * 3. Dilate SL-space grid using two passes (along station, then along latitude)\\n *    * lethal area: half car size + 0.3m\\n *    * high cost area: 1 meter\\n * 4. Convert back to XY-space using XYSL map\\n */\\n\\nexport default class PathPlanner {\\n  constructor() {\\n    this.previousStartStation = null;\\n    this.previousFirstLatticePoint = -1;\\n    this.previousSecondLatticePoint = -1;\\n\\n    let start = performance.now();\\n    const programs = [\\n      xyObstacleGrid.setUp(),\\n      slObstacleGrid.setUp(),\\n      ...slObstacleGridDilation.setUp(),\\n      xyslMap.setUp(),\\n      ...optimizeCubicPaths.setUp(),\\n      optimizeQuinticPaths.setUp(),\\n      ...pathFromVehicleCosts.setUp(),\\n      graphSearch.setUp(),\\n    ].map(p => Object.assign({}, p, { width: 1, height: 1 }));\\n\\n    this.gpgpu = new GPGPU(programs);\\n  }\\n\\n  reset() {\\n    this.previousStartStation = null;\\n    this.previousFirstLatticePoint = -1;\\n    this.previousSecondLatticePoint = -1;\\n  }\\n\\n  plan(vehiclePose, vehicleStation, lanePath, obstacles) {\\n    const centerlineRaw = lanePath.sampleStations(vehicleStation, Math.ceil(this.config.spatialHorizon / this.config.centerlineStationInterval) + 1, this.config.centerlineStationInterval);\\n\\n    // Transform all centerline points into vehicle frame\\n    const vehicleXform = vehicleTransform(vehiclePose);\\n    const centerline = centerlineRaw.map(c => { return { pos: c.pos.clone().applyMatrix3(vehicleXform), rot: c.rot - vehiclePose.rot, curv: c.curv } });\\n\\n    const centerlineData = new Float32Array(centerline.length * 3);\\n    const maxPoint = new THREE.Vector2(0, 0);\\n    const minPoint = new THREE.Vector2(0, 0);\\n\\n    for (let i = 0; i < centerline.length; i++) {\\n      const sample = centerline[i];\\n      const pos = sample.pos;\\n      centerlineData[i * 3 + 0] = pos.x;\\n      centerlineData[i * 3 + 1] = pos.y;\\n      centerlineData[i * 3 + 2] = sample.rot;\\n\\n      maxPoint.max(pos);\\n      minPoint.min(pos);\\n    }\\n\\n    const diff = maxPoint.clone().sub(minPoint);\\n    const xyCenterPoint = minPoint.clone().add(maxPoint).divideScalar(2);\\n    const xyWidth = Math.ceil((diff.x + this.config.gridMargin * 2) / this.config.xyGridCellSize);\\n    const xyHeight = Math.ceil((diff.y + this.config.gridMargin * 2) / this.config.xyGridCellSize);\\n\\n    const slCenterPoint = new THREE.Vector2(this.config.spatialHorizon / 2, 0);\\n    const slWidth = Math.ceil(this.config.spatialHorizon / this.config.slGridCellSize);\\n    const slHeight = Math.ceil((this.config.laneWidth + this.config.gridMargin * 2) / this.config.slGridCellSize);\\n\\n    const latticeStationInterval = this._latticeStationInterval();\\n    let startStation;\\n\\n    // TODO: if the number of latitudes changes, then the first and second lattice points are invalidated\\n    if (this.previousStartStation === null || vehicleStation + latticeStationInterval / 2 > this.previousStartStation) {\\n      startStation = (this.previousStartStation === null ? vehicleStation : this.previousStartStation) + latticeStationInterval;\\n      this.previousStartStation = startStation;\\n      this.previousFirstLatticePoint -= this.config.lattice.numLatitudes;\\n      this.previousSecondLatticePoint -= this.config.lattice.numLatitudes;\\n    } else {\\n      startStation = this.previousStartStation;\\n    }\\n\\n    const lattice = this._buildLattice(lanePath, startStation, vehiclePose.rot, vehicleXform);\\n\\n    for (const [i, p] of [\\n      xyObstacleGrid.update(this.config, xyWidth, xyHeight, xyCenterPoint, vehicleXform, obstacles),\\n      slObstacleGrid.update(this.config, slWidth, slHeight, slCenterPoint, xyCenterPoint),\\n      ...slObstacleGridDilation.update(this.config, slWidth, slHeight),\\n      xyslMap.update(this.config, xyWidth, xyHeight, xyCenterPoint),\\n      ...optimizeCubicPaths.update(this.config, vehiclePose),\\n      optimizeQuinticPaths.update(this.config, vehiclePose),\\n      ...pathFromVehicleCosts.update(this.config, vehiclePose, xyCenterPoint, slCenterPoint, this.previousFirstLatticePoint, this.previousSecondLatticePoint),\\n      graphSearch.update(this.config, vehiclePose, xyCenterPoint, slCenterPoint, this.previousFirstLatticePoint, this.previousSecondLatticePoint)\\n    ].entries()) {\\n      this.gpgpu.updateProgram(i, p);\\n    }\\n\\n    this.gpgpu.updateSharedTextures({\\n      centerline: {\\n        width: centerline.length,\\n        height: 1,\\n        channels: 3,\\n        filter: 'linear',\\n        data: centerlineData\\n      },\\n      costTable: {\\n        width: NUM_ACCELERATION_PROFILES * NUM_VELOCITY_RANGES * NUM_TIME_RANGES,\\n        height: this.config.lattice.numLatitudes,\\n        depth: this.config.lattice.numStations,\\n        channels: 4,\\n        textureType: '2DArray'\\n      },\\n      lattice: {\\n        width: this.config.lattice.numLatitudes,\\n        height: this.config.lattice.numStations,\\n        channels: 4,\\n        data: lattice\\n      }\\n    });\\n\\n    let start = performance.now();\\n    const outputs = this.gpgpu.run();\\n    const costTable = this.gpgpu._graphSearchCostTable;\\n    const cubicPathParams = outputs[5];\\n    const cubicPathFromVehicleParams = outputs[6];\\n    const quinticPathFromVehicleParams = outputs[7];\\n\\n    let bestEntry = [Number.POSITIVE_INFINITY];\\n    let bestEntryIndex;\\n    const numEntries = costTable.length / 4;\\n\\n    for (let i = 0; i < numEntries; i++) {\\n      const entryUnpacked = this._unpackCostTableIndex(i);\\n      const entry = [\\n        costTable[i * 4],\\n        costTable[i * 4 + 1],\\n        costTable[i * 4 + 2],\\n        costTable[i * 4 + 3]\\n      ];\\n\\n      if (entry[0] < 0) continue;\\n\\n      entry[0] += this._terminalCost(entryUnpacked, entry);\\n\\n      if (entry[0] < bestEntry[0]) {\\n        bestEntryIndex = i;\\n        bestEntry = entry;\\n      }\\n    }\\n\\n    const inverseVehicleXform = (new THREE.Matrix3()).getInverse(vehicleXform);\\n    let bestTrajectory = null;\\n    let fromVehicleSegment = null;\\n    let fromVehicleParams = null;\\n    let firstLatticePoint = -1;\\n    let secondLatticePoint = -1;\\n    \\n    if (isFinite(bestEntry[0])) {\\n      [bestTrajectory, fromVehicleSegment, fromVehicleParams, firstLatticePoint, secondLatticePoint] = this._reconstructTrajectory(\\n        bestEntryIndex,\\n        costTable,\\n        cubicPathParams,\\n        cubicPathFromVehicleParams,\\n        quinticPathFromVehicleParams,\\n        vehiclePose,\\n        lattice\\n      );\\n\\n      if (firstLatticePoint == this.previousFirstLatticePoint && secondLatticePoint == this.previousSecondLatticePoint) {\\n        bestTrajectory = null;\\n        fromVehicleSegment = null;\\n        fromVehicleParams = null;\\n      } else {\\n        fromVehicleSegment.forEach(p => {\\n          p.pos = p.pos.applyMatrix3(inverseVehicleXform);\\n          p.rot += vehiclePose.rot;\\n        });\\n\\n        bestTrajectory.forEach(p => {\\n          p.pos = p.pos.applyMatrix3(inverseVehicleXform);\\n          p.rot += vehiclePose.rot;\\n        });\\n      }\\n    }\\n\\n    this.previousFirstLatticePoint = firstLatticePoint;\\n    this.previousSecondLatticePoint = secondLatticePoint;\\n\\n    return { path: bestTrajectory, fromVehicleSegment: fromVehicleSegment, fromVehicleParams: fromVehicleParams, latticeStartStation: this.previousStartStation };\\n  }\\n\\n  _buildLattice(lanePath, startStation, vehicleRot, vehicleXform) {\\n    const centerline = lanePath.sampleStations(startStation, this.config.lattice.numStations, this._latticeStationInterval());\\n    const offset = Math.floor(this.config.lattice.numLatitudes / 2);\\n    const lattice = new Float32Array(this.config.lattice.numStations * this.config.lattice.numLatitudes * 4);\\n    let index = 0;\\n\\n    for (let s = 0; s < this.config.lattice.numStations; s++) {\\n      const sample = centerline[s];\\n\\n      for (let l = 0; l < this.config.lattice.numLatitudes; l++) {\\n        const latitude = (l - offset) / offset * this.config.laneWidth / 2;\\n        const rot = sample.rot - vehicleRot;\\n        const pos = THREE.Vector2.fromAngle(rot + Math.PI / 2).multiplyScalar(latitude).add(sample.pos.clone().applyMatrix3(vehicleXform));\\n        const curv = sample.curv == 0 ? 0 : 1 / (1 / sample.curv - latitude);\\n\\n        lattice[index++] = pos.x;\\n        lattice[index++] = pos.y;\\n        lattice[index++] = rot;\\n        lattice[index++] = curv;\\n      }\\n    }\\n\\n    return lattice;\\n  }\\n\\n  _latticeStationInterval() {\\n    return this.config.spatialHorizon / this.config.lattice.numStations;\\n  }\\n\\n  _terminalCost([stationIndex, latitudeIndex, timeIndex, velocityIndex, accelerationIndex], [cost, finalVelocity, finalTime, incomingIndex]) {\\n    // Only consider vertices that reach the end of the spatial or temporal horizon\\n    if (stationIndex != this.config.lattice.numStations - 1 && finalVelocity > 0.05)\\n      return Number.POSITIVE_INFINITY;\\n\\n    const station = (this.config.spatialHorizon / this.config.lattice.numStations) * (stationIndex + 1);\\n\\n    return station * -this.config.stationReachDiscount + finalTime * this.config.extraTimePenalty;\\n  }\\n\\n  _unpackCostTableIndex(index) {\\n    if (index < 0) return [-1, index + 2, null, null, null];\\n\\n    const numPerTime = NUM_ACCELERATION_PROFILES * NUM_VELOCITY_RANGES;\\n    const numPerLatitude = numPerTime * NUM_TIME_RANGES;\\n    const numPerStation = this.config.lattice.numLatitudes * numPerLatitude;\\n\\n    const stationIndex = Math.floor(index / numPerStation);\\n    index -= stationIndex * numPerStation;\\n\\n    const latitudeIndex = Math.floor(index / numPerLatitude);\\n    index -= latitudeIndex * numPerLatitude;\\n\\n    const timeIndex = Math.floor(index / numPerTime);\\n    index -= timeIndex * numPerTime;\\n\\n    const velocityIndex = Math.floor(index / NUM_ACCELERATION_PROFILES);\\n    const accelerationIndex = index % NUM_ACCELERATION_PROFILES;\\n\\n    return [stationIndex, latitudeIndex, timeIndex, velocityIndex, accelerationIndex];\\n  }\\n\\n  _reconstructTrajectory(index, costTable, cubicPathParams, cubicPathFromVehicleParams, quinticPathFromVehicleParams, vehiclePose, lattice) {\\n    let unpacked = this._unpackCostTableIndex(index);\\n    unpacked.push(costTable[index * 4 + 1]);\\n    const nodes = [unpacked];\\n\\n    let count = 0;\\n    while (unpacked[0] >= 0 && count++ < 100) {\\n      index = costTable[index * 4 + 3];\\n      unpacked = this._unpackCostTableIndex(index);\\n\\n      const finalVelocity = unpacked[0] >= 0 ? costTable[index * 4 + 1] : vehiclePose.velocity;\\n      unpacked.push(finalVelocity);\\n\\n      nodes.unshift(unpacked);\\n    }\\n    if (count >= 100) throw new Error('Infinite loop encountered while reconstructing trajectory.');\\n\\n    const points = [];\\n    let fromVehicleSegment = [];\\n    let fromVehicleParams = null;\\n\\n    for (let i = 0; i < nodes.length - 1; i++) {\\n      const [prevStation, prevLatitude, _pt, _pv, _pa, prevVelocity] = nodes[i];\\n      const [station, latitude, _t, _v, _a, velocity] = nodes[i + 1];\\n\\n      let length;\\n      let pathBuilder;\\n\\n      if (prevStation < 0) {\\n        const start = {\\n          pos: new THREE.Vector2(0, 0),\\n          rot: 0,\\n          curv: vehiclePose.curv\\n        };\\n\\n        const endIndex = (station * this.config.lattice.numLatitudes + latitude) * 4;\\n        const end = {\\n          pos: new THREE.Vector2(lattice[endIndex], lattice[endIndex + 1]),\\n          rot: lattice[endIndex + 2],\\n          curv: lattice[endIndex + 3]\\n        };\\n\\n        if (prevLatitude == 0) { // Cubic path from vehicle to lattice node\\n          length = cubicPathFromVehicleParams[endIndex + 2];\\n\\n          const params = {\\n            p1: cubicPathFromVehicleParams[endIndex],\\n            p2: cubicPathFromVehicleParams[endIndex + 1],\\n            sG: length\\n          };\\n\\n          pathBuilder = new CubicPath(start, end, params);\\n\\n          fromVehicleParams = { type: 'cubic', params: params };\\n        } else { // Quintic path from vehicle to lattice node\\n          length = quinticPathFromVehicleParams[endIndex + 2];\\n\\n          const params = {\\n            p3: quinticPathFromVehicleParams[endIndex],\\n            p4: quinticPathFromVehicleParams[endIndex + 1],\\n            sG: length\\n          };\\n\\n          pathBuilder = new QuinticPath(start, end, params);\\n\\n          fromVehicleParams = { type: 'quintic', params: params };\\n        }\\n      } else {\\n        const startIndex = (prevStation * this.config.lattice.numLatitudes + prevLatitude) * 4;\\n        const endIndex = (station * this.config.lattice.numLatitudes + latitude) * 4;\\n\\n        const start = {\\n          pos: new THREE.Vector2(lattice[startIndex], lattice[startIndex + 1]),\\n          rot: lattice[startIndex + 2],\\n          curv: lattice[startIndex + 3]\\n        };\\n\\n        const end = {\\n          pos: new THREE.Vector2(lattice[endIndex], lattice[endIndex + 1]),\\n          rot: lattice[endIndex + 2],\\n          curv: lattice[endIndex + 3]\\n        };\\n\\n        const slIndex = station * this.config.lattice.numLatitudes + latitude;\\n        const connectivityIndex = (prevStation - station + this.config.lattice.stationConnectivity) * this.config.lattice.latitudeConnectivity + prevLatitude - latitude + Math.floor(this.config.lattice.latitudeConnectivity / 2);\\n        const cubicPathIndex = (connectivityIndex * this.config.lattice.numStations * this.config.lattice.numLatitudes + slIndex) * 4;\\n\\n        length = cubicPathParams[cubicPathIndex + 2];\\n\\n        pathBuilder = new CubicPath(start, end, {\\n          p1: cubicPathParams[cubicPathIndex],\\n          p2: cubicPathParams[cubicPathIndex + 1],\\n          sG: length\\n        });\\n      }\\n\\n      const path = pathBuilder.buildPath(Math.ceil(length / this.config.pathSamplingStep));\\n\\n      const prevVelocitySq = prevVelocity * prevVelocity;\\n      const accel = (velocity * velocity - prevVelocitySq) / 2 / length;\\n      const ds = length / (path.length - 1);\\n      let s = 0;\\n\\n      for (let p = 0; p < path.length; p++) {\\n        path[p].velocity = Math.sqrt(2 * accel * s + prevVelocitySq);\\n        path[p].acceleration = accel;\\n        s += ds;\\n      }\\n\\n      if (prevStation < 0) {\\n        fromVehicleSegment = path;\\n      } else {\\n        if (i > 0) path.shift();\\n        points.push(...path);\\n      }\\n    }\\n\\n    let firstLatticePoint = null\\n    let secondLatticePoint = null;\\n\\n    if (nodes.length >= 2)\\n      firstLatticePoint = nodes[1][0] * this.config.lattice.numLatitudes + nodes[1][1];\\n\\n    if (nodes.length >= 3)\\n      secondLatticePoint = nodes[2][0] * this.config.lattice.numLatitudes + nodes[2][1];\\n\\n    return [points, fromVehicleSegment, fromVehicleParams, firstLatticePoint, secondLatticePoint];\\n  }\\n}\\n\\nfunction vehicleTransform({ pos, rot }) {\\n  const translate = new THREE.Matrix3();\\n  translate.set(\\n    1, 0, -pos.x,\\n    0, 1, -pos.y,\\n    0, 0, 1\\n  );\\n\\n  const cosRot = Math.cos(rot);\\n  const sinRot = Math.sin(rot);\\n\\n  const rotate = new THREE.Matrix3();\\n  rotate.set(\\n    cosRot, sinRot, 0,\\n    -sinRot, cosRot, 0,\\n    0, 0, 1\\n  );\\n\\n  return rotate.multiply(translate);\\n}\\n\\nfunction obstacleTransform(vehicleXform, xyCenterPoint, width, height) {\\n  const translate = new THREE.Matrix3();\\n  translate.set(\\n    1, 0, -xyCenterPoint.x,\\n    0, 1, -xyCenterPoint.y,\\n    0, 0, 1\\n  );\\n\\n  const scale = new THREE.Matrix3();\\n  scale.set(\\n    2 / width, 0, 0,\\n    0, 2 / height, 0,\\n    0, 0, 1\\n  );\\n\\n  return scale.multiply(translate).multiply(vehicleXform);\\n}\\n\",\"import Car from \\\"./Car.js\\\";\\n\\nexport default class Physics {\\n  constructor() {\\n    this.cars = [];\\n  }\\n\\n  step(dt) {\\n    this.cars.forEach(c => c.step(dt));\\n  }\\n\\n  createCar() {\\n    const newCar = new Car();\\n    this.cars.push(newCar);\\n\\n    return newCar;\\n  }\\n};\\n\",\"import Car from \\\"../physics/Car.js\\\"\\n\\n// input pose: { pos: Vector2 [, rot: radians] }\\n// pose: { pos: Vector2, frontPos: Vector2, fakePos: Vector2, rot: radians }\\nexport default class Path {\\n  constructor(poses, startRotation = 0, goalRotation = 0) {\\n    this.poses = poses;\\n\\n    for (let i = 0; i < poses.length; i++) {\\n      const pose = poses[i];\\n\\n      if (pose.rot === undefined) {\\n        let rot;\\n\\n        if (i == 0) {\\n          rot = startRotation;\\n        } else if (i == poses.length - 1) {\\n          rot = goalRotation;\\n        } else {\\n          const prev = poses[i - 1].pos;\\n          const next = poses[i + 1].pos;\\n          rot = Math.atan2(next.y - prev.y, next.x - prev.x);\\n        }\\n\\n        pose.rot = rot;\\n      }\\n\\n      pose.frontPos = Car.getFrontAxlePosition(pose.pos, pose.rot);\\n      pose.fakePos = Car.getFakeAxlePosition(pose.pos, pose.rot);\\n    }\\n  }\\n}\\n\",\"import Car from \\\"../../physics/Car.js\\\"\\n\\nexport default class FollowController {\\n  constructor(path, car) {\\n    this.path = path;\\n    this.car = car;\\n    this.nextIndex = 1;\\n    this.prevVelocity = 0;\\n    this.prevAccel = 0;\\n  }\\n\\n  reset() {\\n    this.prevVelocity = 0;\\n    this.prevAccel = 0;\\n  }\\n\\n  replacePath(path) {\\n    this.path = path;\\n    this.nextIndex = 1;\\n  }\\n\\n  predictPoseAfterTime(currentPose, predictionTime) {\\n    const pathPoses = this.path.poses;\\n    let [nextIndex, progress] = this.findNextIndex(currentPose.pos);\\n    let currentVelocity = currentPose.velocity;\\n\\n    if (currentVelocity <= 0.01) return currentPose;\\n\\n    while (predictionTime > 0) {\\n      const prevPose = pathPoses[nextIndex - 1];\\n      const nextPose = pathPoses[nextIndex];\\n\\n      const segmentDist = nextPose.pos.distanceTo(prevPose.pos);\\n      const distLeft = segmentDist * (1 - progress);\\n      const sumV = currentVelocity + nextPose.velocity;\\n      const timeToNextIndex = 2 * distLeft / (sumV == 0 ? 0.01 : sumV);\\n      //const timeToNextIndex = distLeft / currentVelocity;\\n\\n      if (timeToNextIndex >= predictionTime || nextIndex + 1 >= pathPoses.length) {\\n        const dist = sumV / 2 * predictionTime;\\n        const newProgress = progress + dist / segmentDist;\\n        const newRotation = Math.wrapAngle(prevPose.rot + Math.wrapAngle(nextPose.rot - prevPose.rot) * newProgress);\\n\\n        return {\\n          pos: nextPose.pos.clone().sub(prevPose.pos).multiplyScalar(newProgress).add(nextPose.pos),\\n          rot: newRotation,\\n          curv: prevPose.curv + (nextPose.curv - prevPose.curv) * newProgress,\\n          dCurv: 0,\\n          ddCurv: 0,\\n          velocity: nextPose.velocity\\n        }\\n      }\\n\\n      currentVelocity = nextPose.velocity;\\n      predictionTime -= timeToNextIndex;\\n      progress = 0;\\n      nextIndex++;\\n    }\\n  }\\n\\n  control(pose, wheelAngle, velocity, dt, lockPath = false) {\\n    const pathPoses = this.path.poses;\\n    const [nextIndex, progress, projection] = this.findNextIndex(pose.pos);\\n    this.nextIndex = nextIndex;\\n\\n    const prevPose = pathPoses[nextIndex - 1];\\n    const nextPose = pathPoses[nextIndex];\\n\\n    let gas = 0;\\n    let brake = 0;\\n    let steer = 0;\\n\\n    if (nextIndex >= pathPoses.length - 1 && progress >= 1) {\\n      brake = 1;\\n    } else {\\n      const kp_a = 4;\\n      const kd_a = 0.5;\\n      const kff_a = 0.5;\\n      const accelDamping = 0.5;\\n\\n      const currentAccel = (velocity - this.prevVelocity) / dt;\\n      const prevNextDist = nextPose.pos.distanceTo(prevPose.pos);\\n      const targetVelocity = Math.sqrt(2 * nextPose.acceleration * prevNextDist * Math.clamp(progress, 0, 1) + prevPose.velocity * prevPose.velocity);\\n      const diffVelocity = targetVelocity - velocity;\\n      const diffAccel = nextPose.acceleration - currentAccel;\\n      const targetAccel = kp_a * diffVelocity + kd_a * diffAccel + kff_a * nextPose.acceleration;\\n      const dampedAccel = this.prevAccel * (1 - accelDamping) + targetAccel * accelDamping;\\n\\n      if (dampedAccel > 0)\\n        gas = Math.min(dampedAccel / Car.MAX_GAS_ACCEL, 1);\\n      else\\n        brake = Math.min(-dampedAccel / Car.MAX_BRAKE_DECEL, 1);\\n\\n      this.prevVelocity = velocity;\\n\\n      const curvature = prevPose.curv + (nextPose.curv - prevPose.curv) * progress;\\n      const desiredWheelAngle = Math.atan(curvature * Car.WHEEL_BASE);\\n      const wheelAngleError = desiredWheelAngle - wheelAngle;\\n      steer = Math.clamp(wheelAngleError / dt / Car.MAX_STEER_SPEED, -1, 1);\\n\\n      if (lockPath) {\\n        const damping = 0.1;\\n        const newRotation = Math.wrapAngle(prevPose.rot + Math.wrapAngle(nextPose.rot - prevPose.rot) * progress);\\n        const newPosition = new THREE.Vector2(projection.x - Car.REAR_AXLE_POS * Math.cos(newRotation), projection.y - Car.REAR_AXLE_POS * Math.sin(newRotation));\\n\\n        if (Math.abs(Math.wrapAngle(newRotation - this.car.rotation)) > 0.5) {\\n          console.log('wut');\\n        }\\n\\n        this.car.rotation += damping * Math.wrapAngle(newRotation - this.car.rotation);\\n        this.car.position = this.car.position.clone().multiplyScalar(1 - damping).add(newPosition.multiplyScalar(damping));\\n      }\\n    }\\n\\n    return { gas, brake, steer };\\n  }\\n\\n  findNextIndex(pos) {\\n    const pathPoses = this.path.poses;\\n\\n    // Constrain the search to just a few points surrounding the current nextIndex\\n    // for performance and to avoid problems with a path that crosses itself\\n    const start = Math.max(0, this.nextIndex - 20);\\n    const end = Math.min(pathPoses.length - 1, this.nextIndex + 20);\\n    let closestDistSqr = pos.distanceToSquared(pathPoses[start].pos);\\n    let closestIndex = start;\\n\\n    for (let i = start + 1; i < end; i++) {\\n      const distSqr = pos.distanceToSquared(pathPoses[i].pos);\\n      if (distSqr < closestDistSqr) {\\n        closestDistSqr = distSqr;\\n        closestIndex = i;\\n      }\\n    }\\n\\n    if (closestIndex == pathPoses.length - 1) {\\n      const [projection, progress] = projectPointOnSegment(pos, pathPoses[closestIndex - 1].pos, pathPoses[closestIndex].pos);\\n      return [closestIndex, progress, projection];\\n    } else if (closestIndex == 0) {\\n      const [projection, progress] = projectPointOnSegment(pos, pathPoses[closestIndex].pos, pathPoses[closestIndex + 1].pos);\\n      return [closestIndex + 1, progress, projection];\\n    } else {\\n      // The nextPoint is either (closestPoint) or (closestPoint + 1). Project the pos to both\\n      // of those two line segments (the segment preceding closestPoint and the segment succeeding closestPoint)\\n      // to determine which segment it's closest to.\\n      const [precedingProjection, precedingProgress] = projectPointOnSegment(pos, pathPoses[closestIndex - 1].pos, pathPoses[closestIndex].pos);\\n      const [succeedingProjection, succeedingProgress] = projectPointOnSegment(pos, pathPoses[closestIndex].pos, pathPoses[closestIndex + 1].pos);\\n\\n      if (pos.distanceToSquared(precedingProjection) < pos.distanceToSquared(succeedingProjection)) {\\n        return [closestIndex, precedingProgress, precedingProjection];\\n      } else {\\n        return [closestIndex + 1, succeedingProgress, succeedingProjection];\\n      }\\n    }\\n  }\\n}\\n\\n// Returns [pointOnSegment, progressAlongSegment {0 - 1}]\\nfunction projectPointOnSegment(point, start, end) {\\n  const distSqr = start.distanceToSquared(end);\\n  const progress = point.clone().sub(start).dot(end.clone().sub(start)) / distSqr;\\n  return [end.clone().sub(start).multiplyScalar(progress).add(start), progress];\\n}\\n\",\"export default class ManualController {\\n  constructor() {\\n    this.carKeys = { forward: false, backward: false, left: false, right: false, brake: false };\\n\\n    document.addEventListener('keydown', event => {\\n      switch (event.key) {\\n        case 'w': case 'W': this.carKeys.forward = true; break;\\n        case 's': case 'S': this.carKeys.backward = true; break;\\n        case 'a': case 'A': this.carKeys.left = true; break;\\n        case 'd': case 'D': this.carKeys.right = true; break;\\n        case ' ': this.carKeys.brake = true; break;\\n      }\\n    });\\n\\n    document.addEventListener('keyup', event => {\\n      switch (event.key) {\\n        case 'w': case 'W': this.carKeys.forward = false; break;\\n        case 's': case 'S': this.carKeys.backward = false; break;\\n        case 'a': case 'A': this.carKeys.left = false; break;\\n        case 'd': case 'D': this.carKeys.right = false; break;\\n        case ' ': this.carKeys.brake = false; break;\\n      }\\n    });\\n  }\\n\\n  control() {\\n    let gas = 0;\\n    let brake = 0;\\n    let steer = 0;\\n\\n    if (this.carKeys.forward) gas += 1;\\n    if (this.carKeys.backward) gas -= 1;\\n    if (this.carKeys.left) steer -= 1;\\n    if (this.carKeys.right) steer += 1;\\n    if (this.carKeys.brake) brake += 1;\\n\\n    return { gas, brake, steer };\\n  }\\n}\\n\",\"export default class MapObject extends THREE.Object3D {\\n  constructor(geolocation) {\\n    super();\\n\\n    this.geolocation = geolocation;\\n    this.tilesGroup = null;\\n\\n    const tileSize = this.tileSizeInMeters();\\n    const grid = new THREE.GridHelper(MapObject.HALF_NUM_TILES * 4 * tileSize, MapObject.HALF_NUM_TILES * 4, 0x333333, 0x333333);\\n    grid.renderOrder = -1;\\n    grid.material.depthTest = false;\\n    grid.position.add(new THREE.Vector3(-tileSize / 2, 0, -tileSize / 2));\\n    this.add(grid);\\n\\n    this.drawTiles();\\n  }\\n\\n  // Converts lat-long geolocation to Google Maps world coodinates\\n  static geoToWorld(latlng) {\\n    const latitudeRadians = latlng[0] * Math.PI / 180;\\n    const x = (latlng[1] + 180) / 360 * 256;\\n    const y = ((1 - Math.log(Math.tan(latitudeRadians) + 1 / Math.cos(latitudeRadians)) / Math.PI) / 2) * 256;\\n    return [x, y];\\n  }\\n\\n  // Calculates the x and y tile indices for the provided world coordinates\\n  static worldToTile(worldCoordinates) {\\n    return [Math.floor(worldCoordinates[0] * MapObject.SCALE / 256), Math.floor(worldCoordinates[1] * MapObject.SCALE / 256)];\\n  }\\n\\n  drawTiles() {\\n    if (this.tileGroup != null) this.remove(this.tilesGroup);\\n    this.tileGroup = new THREE.Group();\\n\\n    const originTile = MapObject.worldToTile(MapObject.geoToWorld(this.geolocation));\\n    const tileSize = this.tileSizeInMeters();\\n\\n    for (let x = -MapObject.HALF_NUM_TILES; x < MapObject.HALF_NUM_TILES; x++) {\\n      for (let y = -MapObject.HALF_NUM_TILES; y < MapObject.HALF_NUM_TILES; y++) {\\n        const tileTexture = new THREE.TextureLoader().load(`https://khms0.google.com/kh/v=748?x=${originTile[0] + x}&y=${originTile[1] + y}&z=${MapObject.ZOOM}`);\\n        tileTexture.anisotropy = 16;\\n        const tileGeometry = new THREE.PlaneBufferGeometry(tileSize, tileSize);\\n        const tileMaterial = new THREE.MeshBasicMaterial({ map: tileTexture, color: 0xffffff });\\n        const tile = new THREE.Mesh(tileGeometry, tileMaterial);\\n        tile.rotation.x = -Math.PI / 2;\\n        tile.position.x = x * tileSize;\\n        tile.position.z = y * tileSize;\\n\\n        this.tileGroup.add(tile);\\n      }\\n    }\\n\\n    this.add(this.tileGroup);\\n  }\\n\\n  tileSizeInMeters() {\\n    // Because of the Mercator projection used to create the tile images, the size of a tile (in meters) depends on the latitude\\n    return 2 * Math.PI * MapObject.EARTH_RADIUS * Math.cos(this.geolocation[0] * Math.PI / 180) / Math.pow(2, MapObject.ZOOM);\\n  }\\n}\\n\\nMapObject.EARTH_RADIUS = 6378137; // meters\\nMapObject.TILE_PIXELS = 256; // pixels per tile\\nMapObject.ZOOM = 20;\\nMapObject.SCALE = 1 << MapObject.ZOOM;\\nMapObject.HALF_NUM_TILES = 20;\\n\",\"import Car from \\\"../physics/Car.js\\\";\\n\\nexport default class CarObject extends THREE.Object3D {\\n  constructor(car) {\\n    super();\\n\\n    this.car = car;\\n\\n    const carMesh = new THREE.Mesh(new THREE.PlaneGeometry(Car.HALF_CAR_LENGTH * 2, Car.HALF_CAR_WIDTH * 2), new THREE.MeshBasicMaterial({ color: 0x0080ff, depthTest: false, transparent: true, opacity: 0.5 }));\\n    carMesh.rotation.x = -Math.PI / 2;\\n    this.add(carMesh);\\n\\n    const wheelGeometry = new THREE.PlaneGeometry(Car.HALF_WHEEL_LENGTH * 2, Car.HALF_WHEEL_WIDTH * 2);\\n    const wheelMaterial = new THREE.MeshBasicMaterial({ color: 0xff8000, depthTest: false, transparent: true, opacity: 0.7 })\\n\\n    this.lfWheel = new THREE.Mesh(wheelGeometry, wheelMaterial);\\n    this.lfWheel.renderOrder = 1;\\n    this.lfWheel.position.set(Car.FRONT_AXLE_POS, 0, Car.WHEEL_LATERAL_POS);\\n    this.lfWheel.rotation.x = -Math.PI / 2;\\n    this.add(this.lfWheel);\\n\\n    this.rfWheel = new THREE.Mesh(wheelGeometry, wheelMaterial);\\n    this.rfWheel.renderOrder = 1;\\n    this.rfWheel.position.set(Car.FRONT_AXLE_POS, 0, -Car.WHEEL_LATERAL_POS);\\n    this.rfWheel.rotation.x = -Math.PI / 2;\\n    this.add(this.rfWheel);\\n\\n    const lrWheel = new THREE.Mesh(wheelGeometry, wheelMaterial);\\n    lrWheel.renderOrder = 1;\\n    lrWheel.position.set(Car.REAR_AXLE_POS, 0, Car.WHEEL_LATERAL_POS);\\n    lrWheel.rotation.x = -Math.PI / 2;\\n    this.add(lrWheel);\\n\\n    const rrWheel = new THREE.Mesh(wheelGeometry, wheelMaterial);\\n    rrWheel.renderOrder = 1;\\n    rrWheel.position.set(Car.REAR_AXLE_POS, 0, -Car.WHEEL_LATERAL_POS);\\n    rrWheel.rotation.x = -Math.PI / 2;\\n    this.add(rrWheel);\\n  }\\n\\n  updateMatrix() {\\n    this.updateCar();\\n    super.updateMatrix();\\n  }\\n\\n  updateCar() {\\n    const carPosition = this.car.position;\\n    this.position.set(carPosition.x, 0, carPosition.y);\\n    this.rotation.y = -this.car.rotation;\\n\\n    const wheelAngle = this.car.wheelAngle;\\n    this.lfWheel.rotation.z = -wheelAngle;\\n    this.rfWheel.rotation.z = -wheelAngle;\\n  }\\n}\\n\",\"import LanePath from \\\"../autonomy/LanePath.js\\\";\\n\\nconst GROUND_PLANE = new THREE.Plane(new THREE.Vector3(0, 1, 0));\\n\\nexport default class Editor {\\n  constructor(canvas, camera, scene) {\\n    this.canvas = canvas;\\n    this.camera = camera;\\n\\n    this.raycaster = new THREE.Raycaster();\\n    this.mouse = new THREE.Vector2();\\n    this.dragOffset = new THREE.Vector3();\\n    this.draggingPoint = null;\\n    this.pointIndex = 0;\\n    this.centerlineGeometry = new THREE.Geometry();\\n    this.leftBoundaryGeometry = new THREE.Geometry();\\n    this.rightBoundaryGeometry = new THREE.Geometry();\\n\\n    this.points = [];\\n    this.enabled = false;\\n\\n    this.group = new THREE.Group();\\n    this.pointsGroup = new THREE.Group();\\n    this.group.add(this.pointsGroup);\\n    scene.add(this.group);\\n\\n    this.lanePath = new LanePath();\\n\\n    this.mouseDown = this.mouseDown.bind(this);\\n    this.mouseMove = this.mouseMove.bind(this);\\n    this.mouseUp = this.mouseUp.bind(this);\\n\\n    canvas.addEventListener('mousedown', this.mouseDown);\\n    canvas.addEventListener('mousemove', this.mouseMove);\\n    canvas.addEventListener('mouseup', this.mouseUp);\\n    canvas.addEventListener('contextmenu', e => this.enabled && e.preventDefault());\\n\\n    const editorClearOptions = document.getElementById('editor-clear-options');\\n    document.getElementById('editor-clear').addEventListener('click', event => {\\n      event.stopPropagation();\\n      editorClearOptions.classList.toggle('is-hidden');\\n    });\\n    document.addEventListener('click', () => editorClearOptions.classList.add('is-hidden'));\\n\\n    this.centerlineObject = new THREE.Mesh(new THREE.Geometry(), new MeshLineMaterial({ color: new THREE.Color(0x004080), lineWidth: 0.2, depthTest: false, transparent: true, opacity: 0.7, resolution: new THREE.Vector2(this.canvas.clientWidth, this.canvas.clientHeight) }));\\n    this.centerlineObject.rotation.x = Math.PI / 2;\\n    this.centerlineObject.renderOrder = 1;\\n    this.group.add(this.centerlineObject);\\n\\n    this.leftBoundaryObject = new THREE.Mesh(new THREE.Geometry(), new MeshLineMaterial({ color: new THREE.Color(0xff8000), lineWidth: 0.15, depthTest: false, transparent: true, opacity: 0.7, resolution: new THREE.Vector2(this.canvas.clientWidth, this.canvas.clientHeight) }));\\n    this.leftBoundaryObject.rotation.x = Math.PI / 2;\\n    this.leftBoundaryObject.renderOrder = 1;\\n    this.group.add(this.leftBoundaryObject);\\n\\n    this.rightBoundaryObject = new THREE.Mesh(new THREE.Geometry(), new MeshLineMaterial({ color: new THREE.Color(0xff8000), lineWidth: 0.15, depthTest: false, transparent: true, opacity: 0.7, resolution: new THREE.Vector2(this.canvas.clientWidth, this.canvas.clientHeight) }));\\n    this.rightBoundaryObject.rotation.x = Math.PI / 2;\\n    this.rightBoundaryObject.renderOrder = 1;\\n    this.group.add(this.rightBoundaryObject);\\n  }\\n\\n  redraw() {\\n    this.centerlineGeometry.setFromPoints(this.lanePath.centerline);\\n    const centerline = new MeshLine();\\n    centerline.setGeometry(this.centerlineGeometry);\\n    this.centerlineObject.geometry = centerline.geometry;\\n\\n    this.leftBoundaryGeometry.setFromPoints(this.lanePath.leftBoundary);\\n    const leftBoundary = new MeshLine();\\n    leftBoundary.setGeometry(this.leftBoundaryGeometry);\\n    this.leftBoundaryObject.geometry = leftBoundary.geometry;\\n\\n    this.rightBoundaryGeometry.setFromPoints(this.lanePath.rightBoundary);\\n    const rightBoundary = new MeshLine();\\n    rightBoundary.setGeometry(this.rightBoundaryGeometry);\\n    this.rightBoundaryObject.geometry = rightBoundary.geometry;\\n  }\\n\\n  addPoint(pos) {\\n    const point = new THREE.Mesh(new THREE.CircleGeometry(0.4, 32), new THREE.MeshBasicMaterial({ color: 0x0080ff, depthTest: false, transparent: true, opacity: 0.7 }));\\n    point.rotation.x = -Math.PI / 2;\\n    point.position.set(pos.x, 0, pos.y);\\n    point.userData = { index: this.pointIndex++ };\\n\\n    this.pointsGroup.add(point);\\n    this.points.push(point);\\n    this.lanePath.addAnchor(pos);\\n\\n    return point;\\n  }\\n\\n  updatePoint(object, pos) {\\n    object.position.copy(pos);\\n    this.lanePath.updateAnchor(object.userData.index, new THREE.Vector2(pos.x, pos.z));\\n  }\\n\\n  clearPoints() {\\n    this.centerlineObject.geometry = new THREE.Geometry();\\n\\n    this.group.remove(this.pointsGroup);\\n    this.pointsGroup = new THREE.Group();\\n    this.points = [];\\n    this.pointIndex = 0;\\n\\n    this.lanePath = new LanePath();\\n  }\\n\\n  loadPoints(points) {\\n    this.clearPoints();\\n\\n    points.forEach(p => this.addPoint(new THREE.Vector2(p.x, p.y)));\\n    this.redraw();\\n  }\\n\\n  mouseDown(event) {\\n    if (!this.enabled || event.button != 0) return;\\n\\n    this.mouse.x = (event.offsetX / this.canvas.clientWidth) * 2 - 1;\\n    this.mouse.y = -(event.offsetY / this.canvas.clientHeight) * 2 + 1;\\n\\n    this.raycaster.setFromCamera(this.mouse, this.camera);\\n    const picked = this.raycaster.intersectObjects(this.points)[0];\\n\\n    if (picked) {\\n      this.draggingPoint = picked.object;\\n      this.dragOffset.copy(picked.object.position).sub(picked.point);\\n      event.stopImmediatePropagation();\\n    } else {\\n      const intersection = this.raycaster.ray.intersectPlane(GROUND_PLANE);\\n      if (intersection != null) {\\n        this.addPoint(new THREE.Vector2(intersection.x, intersection.z));\\n        this.redraw();\\n      }\\n    }\\n  }\\n\\n  mouseMove(event) {\\n    if (!this.enabled || this.draggingPoint == null) return;\\n\\n    this.mouse.x = (event.offsetX / this.canvas.clientWidth) * 2 - 1;\\n    this.mouse.y = -(event.offsetY / this.canvas.clientHeight) * 2 + 1;\\n\\n    this.raycaster.setFromCamera(this.mouse, this.camera);\\n\\n    const intersection = this.raycaster.ray.intersectPlane(GROUND_PLANE);\\n    if (intersection != null) {\\n      this.updatePoint(this.draggingPoint, intersection.add(this.dragOffset));\\n      this.redraw();\\n    }\\n  }\\n\\n  mouseUp(event) {\\n    if (!this.enabled || event.button != 0) return;\\n\\n    this.draggingPoint = null;\\n  }\\n}\\n\",\"/**\\n * @author qiao / https://github.com/qiao\\n * @author mrdoob / http://mrdoob.com\\n * @author alteredq / http://alteredqualia.com/\\n * @author WestLangley / http://github.com/WestLangley\\n * @author erich666 / http://erichaines.com\\n */\\n\\n// This set of controls performs orbiting, dollying (zooming), and panning.\\n// Unlike TrackballControls, it maintains the \\\"up\\\" direction object.up (+Y by default).\\n//\\n//    Orbit - left mouse / touch: one finger move\\n//    Zoom - middle mouse, or mousewheel / touch: two finger spread or squish\\n//    Pan - right mouse, or arrow keys / touch: three finger swipe\\n\\nconst OrbitControls = function ( object, domElement ) {\\n\\n\\tthis.object = object;\\n\\n\\tthis.domElement = ( domElement !== undefined ) ? domElement : document;\\n\\n\\t// Set to false to disable this control\\n\\tthis.enabled = true;\\n\\n\\t// \\\"target\\\" sets the location of focus, where the object orbits around\\n\\tthis.target = new THREE.Vector3();\\n\\n\\t// How far you can dolly in and out ( PerspectiveCamera only )\\n\\tthis.minDistance = 0;\\n\\tthis.maxDistance = Infinity;\\n\\n\\t// How far you can zoom in and out ( OrthographicCamera only )\\n\\tthis.minZoom = 0;\\n\\tthis.maxZoom = Infinity;\\n\\n\\t// How far you can orbit vertically, upper and lower limits.\\n\\t// Range is 0 to Math.PI radians.\\n\\tthis.minPolarAngle = 0; // radians\\n\\tthis.maxPolarAngle = Math.PI; // radians\\n\\n\\t// How far you can orbit horizontally, upper and lower limits.\\n\\t// If set, must be a sub-interval of the interval [ - Math.PI, Math.PI ].\\n\\tthis.minAzimuthAngle = - Infinity; // radians\\n\\tthis.maxAzimuthAngle = Infinity; // radians\\n\\n\\t// Set to true to enable damping (inertia)\\n\\t// If damping is enabled, you must call controls.update() in your animation loop\\n\\tthis.enableDamping = false;\\n\\tthis.dampingFactor = 0.25;\\n\\n\\t// This option actually enables dollying in and out; left as \\\"zoom\\\" for backwards compatibility.\\n\\t// Set to false to disable zooming\\n\\tthis.enableZoom = true;\\n\\tthis.zoomSpeed = 1.0;\\n\\n\\t// Set to false to disable rotating\\n\\tthis.enableRotate = true;\\n\\tthis.rotateSpeed = 1.0;\\n\\n\\t// Set to false to disable panning\\n\\tthis.enablePan = true;\\n\\tthis.keyPanSpeed = 7.0;\\t// pixels moved per arrow key push\\n\\n\\t// Set to true to automatically rotate around the target\\n\\t// If auto-rotate is enabled, you must call controls.update() in your animation loop\\n\\tthis.autoRotate = false;\\n\\tthis.autoRotateSpeed = 2.0; // 30 seconds per round when fps is 60\\n\\n\\t// Set to false to disable use of the keys\\n\\tthis.enableKeys = true;\\n\\n\\t// The four arrow keys\\n\\tthis.keys = { LEFT: 37, UP: 38, RIGHT: 39, BOTTOM: 40 };\\n\\n\\t// Mouse buttons\\n\\tthis.mouseButtons = { ORBIT: THREE.MOUSE.LEFT, ZOOM: THREE.MOUSE.MIDDLE, PAN: THREE.MOUSE.RIGHT };\\n\\n\\t// for reset\\n\\tthis.target0 = this.target.clone();\\n\\tthis.position0 = this.object.position.clone();\\n\\tthis.zoom0 = this.object.zoom;\\n\\n\\t//\\n\\t// public methods\\n\\t//\\n\\n\\tthis.getPolarAngle = function () {\\n\\n\\t\\treturn spherical.phi;\\n\\n\\t};\\n\\n\\tthis.getAzimuthalAngle = function () {\\n\\n\\t\\treturn spherical.theta;\\n\\n\\t};\\n\\n\\tthis.saveState = function () {\\n\\n\\t\\tscope.target0.copy( scope.target );\\n\\t\\tscope.position0.copy( scope.object.position );\\n\\t\\tscope.zoom0 = scope.object.zoom;\\n\\n\\t};\\n\\n\\tthis.reset = function () {\\n\\n\\t\\tscope.target.copy( scope.target0 );\\n\\t\\tscope.object.position.copy( scope.position0 );\\n\\t\\tscope.object.zoom = scope.zoom0;\\n\\n\\t\\tscope.object.updateProjectionMatrix();\\n\\t\\tscope.dispatchEvent( changeEvent );\\n\\n\\t\\tscope.update();\\n\\n\\t\\tstate = STATE.NONE;\\n\\n\\t};\\n\\n  this.rotateLeft = function(angle) {\\n    rotateLeft(angle);\\n  }\\n\\n\\t// this method is exposed, but perhaps it would be better if we can make it private...\\n\\tthis.update = function () {\\n\\n\\t\\tvar offset = new THREE.Vector3();\\n\\n\\t\\t// so camera.up is the orbit axis\\n\\t\\tvar quat = new THREE.Quaternion().setFromUnitVectors( object.up, new THREE.Vector3( 0, 1, 0 ) );\\n\\t\\tvar quatInverse = quat.clone().inverse();\\n\\n\\t\\tvar lastPosition = new THREE.Vector3();\\n\\t\\tvar lastQuaternion = new THREE.Quaternion();\\n\\n\\t\\treturn function update() {\\n\\n\\t\\t\\tvar position = scope.object.position;\\n\\n\\t\\t\\toffset.copy( position ).sub( scope.target );\\n\\n\\t\\t\\t// rotate offset to \\\"y-axis-is-up\\\" space\\n\\t\\t\\toffset.applyQuaternion( quat );\\n\\n\\t\\t\\t// angle from z-axis around y-axis\\n\\t\\t\\tspherical.setFromVector3( offset );\\n\\n\\t\\t\\tif ( scope.autoRotate && state === STATE.NONE ) {\\n\\n\\t\\t\\t\\trotateLeft( getAutoRotationAngle() );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tspherical.theta += sphericalDelta.theta;\\n\\t\\t\\tspherical.phi += sphericalDelta.phi;\\n\\n\\t\\t\\t// restrict theta to be between desired limits\\n\\t\\t\\tspherical.theta = Math.max( scope.minAzimuthAngle, Math.min( scope.maxAzimuthAngle, spherical.theta ) );\\n\\n\\t\\t\\t// restrict phi to be between desired limits\\n\\t\\t\\tspherical.phi = Math.max( scope.minPolarAngle, Math.min( scope.maxPolarAngle, spherical.phi ) );\\n\\n\\t\\t\\tspherical.makeSafe();\\n\\n\\n\\t\\t\\tspherical.radius *= scale;\\n\\n\\t\\t\\t// restrict radius to be between desired limits\\n\\t\\t\\tspherical.radius = Math.max( scope.minDistance, Math.min( scope.maxDistance, spherical.radius ) );\\n\\n\\t\\t\\t// move target to panned location\\n\\t\\t\\tscope.target.add( panOffset );\\n\\n\\t\\t\\toffset.setFromSpherical( spherical );\\n\\n\\t\\t\\t// rotate offset back to \\\"camera-up-vector-is-up\\\" space\\n\\t\\t\\toffset.applyQuaternion( quatInverse );\\n\\n\\t\\t\\tposition.copy( scope.target ).add( offset );\\n\\n\\t\\t\\tscope.object.lookAt( scope.target );\\n\\n\\t\\t\\tif ( scope.enableDamping === true ) {\\n\\n\\t\\t\\t\\tsphericalDelta.theta *= ( 1 - scope.dampingFactor );\\n\\t\\t\\t\\tsphericalDelta.phi *= ( 1 - scope.dampingFactor );\\n\\n\\t\\t\\t} else {\\n\\n\\t\\t\\t\\tsphericalDelta.set( 0, 0, 0 );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tscale = 1;\\n\\t\\t\\tpanOffset.set( 0, 0, 0 );\\n\\n\\t\\t\\t// update condition is:\\n\\t\\t\\t// min(camera displacement, camera rotation in radians)^2 > EPS\\n\\t\\t\\t// using small-angle approximation cos(x/2) = 1 - x^2 / 8\\n\\n\\t\\t\\tif ( zoomChanged ||\\n\\t\\t\\t\\tlastPosition.distanceToSquared( scope.object.position ) > EPS ||\\n\\t\\t\\t\\t8 * ( 1 - lastQuaternion.dot( scope.object.quaternion ) ) > EPS ) {\\n\\n\\t\\t\\t\\tscope.dispatchEvent( changeEvent );\\n\\n\\t\\t\\t\\tlastPosition.copy( scope.object.position );\\n\\t\\t\\t\\tlastQuaternion.copy( scope.object.quaternion );\\n\\t\\t\\t\\tzoomChanged = false;\\n\\n\\t\\t\\t\\treturn true;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn false;\\n\\n\\t\\t};\\n\\n\\t}();\\n\\n\\tthis.dispose = function () {\\n\\n\\t\\tscope.domElement.removeEventListener( 'contextmenu', onContextMenu, false );\\n\\t\\tscope.domElement.removeEventListener( 'mousedown', onMouseDown, false );\\n\\t\\tscope.domElement.removeEventListener( 'wheel', onMouseWheel, false );\\n\\n\\t\\tscope.domElement.removeEventListener( 'touchstart', onTouchStart, false );\\n\\t\\tscope.domElement.removeEventListener( 'touchend', onTouchEnd, false );\\n\\t\\tscope.domElement.removeEventListener( 'touchmove', onTouchMove, false );\\n\\n\\t\\tdocument.removeEventListener( 'mousemove', onMouseMove, false );\\n\\t\\tdocument.removeEventListener( 'mouseup', onMouseUp, false );\\n\\n\\t\\twindow.removeEventListener( 'keydown', onKeyDown, false );\\n\\n\\t\\t//scope.dispatchEvent( { type: 'dispose' } ); // should this be added here?\\n\\n\\t};\\n\\n\\t//\\n\\t// internals\\n\\t//\\n\\n\\tvar scope = this;\\n\\n\\tvar changeEvent = { type: 'change' };\\n\\tvar startEvent = { type: 'start' };\\n\\tvar endEvent = { type: 'end' };\\n\\n\\tvar STATE = { NONE: - 1, ROTATE: 0, DOLLY: 1, PAN: 2, TOUCH_ROTATE: 3, TOUCH_DOLLY: 4, TOUCH_PAN: 5 };\\n\\n\\tvar state = STATE.NONE;\\n\\n\\tvar EPS = 0.000001;\\n\\n\\t// current position in spherical coordinates\\n\\tvar spherical = new THREE.Spherical();\\n\\tvar sphericalDelta = new THREE.Spherical();\\n\\n\\tvar scale = 1;\\n\\tvar panOffset = new THREE.Vector3();\\n\\tvar zoomChanged = false;\\n\\n\\tvar rotateStart = new THREE.Vector2();\\n\\tvar rotateEnd = new THREE.Vector2();\\n\\tvar rotateDelta = new THREE.Vector2();\\n\\n\\tvar panStart = new THREE.Vector2();\\n\\tvar panEnd = new THREE.Vector2();\\n\\tvar panDelta = new THREE.Vector2();\\n\\n\\tvar dollyStart = new THREE.Vector2();\\n\\tvar dollyEnd = new THREE.Vector2();\\n\\tvar dollyDelta = new THREE.Vector2();\\n\\n\\tfunction getAutoRotationAngle() {\\n\\n\\t\\treturn 2 * Math.PI / 60 / 60 * scope.autoRotateSpeed;\\n\\n\\t}\\n\\n\\tfunction getZoomScale() {\\n\\n\\t\\treturn Math.pow( 0.95, scope.zoomSpeed );\\n\\n\\t}\\n\\n\\tfunction rotateLeft( angle ) {\\n\\n\\t\\tsphericalDelta.theta -= angle;\\n\\n\\t}\\n\\n\\tfunction rotateUp( angle ) {\\n\\n\\t\\tsphericalDelta.phi -= angle;\\n\\n\\t}\\n\\n\\tvar panLeft = function () {\\n\\n\\t\\tvar v = new THREE.Vector3();\\n\\n\\t\\treturn function panLeft( distance, objectMatrix ) {\\n\\n\\t\\t\\tv.setFromMatrixColumn( objectMatrix, 0 ); // get X column of objectMatrix\\n\\t\\t\\tv.multiplyScalar( - distance );\\n\\n\\t\\t\\tpanOffset.add( v );\\n\\n\\t\\t};\\n\\n\\t}();\\n\\n\\tvar panUp = function () {\\n\\n\\t\\tvar v = new THREE.Vector3();\\n\\n\\t\\treturn function panUp( distance, objectMatrix ) {\\n\\n\\t\\t\\tv.setFromMatrixColumn( objectMatrix, 1 ); // get Y column of objectMatrix\\n\\t\\t\\tv.multiplyScalar( distance );\\n\\n\\t\\t\\tpanOffset.add( v );\\n\\n\\t\\t};\\n\\n\\t}();\\n\\n\\t// deltaX and deltaY are in pixels; right and down are positive\\n\\tvar pan = function () {\\n\\n\\t\\tvar offset = new THREE.Vector3();\\n\\n\\t\\treturn function pan( deltaX, deltaY ) {\\n\\n\\t\\t\\tvar element = scope.domElement === document ? scope.domElement.body : scope.domElement;\\n\\n\\t\\t\\tif ( scope.object.isPerspectiveCamera ) {\\n\\n\\t\\t\\t\\t// perspective\\n\\t\\t\\t\\tvar position = scope.object.position;\\n\\t\\t\\t\\toffset.copy( position ).sub( scope.target );\\n\\t\\t\\t\\tvar targetDistance = offset.length();\\n\\n\\t\\t\\t\\t// half of the fov is center to top of screen\\n\\t\\t\\t\\ttargetDistance *= Math.tan( ( scope.object.fov / 2 ) * Math.PI / 180.0 );\\n\\n\\t\\t\\t\\t// we actually don't use screenWidth, since perspective camera is fixed to screen height\\n\\t\\t\\t\\tpanLeft( 2 * deltaX * targetDistance / element.clientHeight, scope.object.matrix );\\n\\t\\t\\t\\tpanUp( 2 * deltaY * targetDistance / element.clientHeight, scope.object.matrix );\\n\\n\\t\\t\\t} else if ( scope.object.isOrthographicCamera ) {\\n\\n\\t\\t\\t\\t// orthographic\\n\\t\\t\\t\\tpanLeft( deltaX * ( scope.object.right - scope.object.left ) / scope.object.zoom / element.clientWidth, scope.object.matrix );\\n\\t\\t\\t\\tpanUp( deltaY * ( scope.object.top - scope.object.bottom ) / scope.object.zoom / element.clientHeight, scope.object.matrix );\\n\\n\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t// camera neither orthographic nor perspective\\n\\t\\t\\t\\tconsole.warn( 'WARNING: OrbitControls.js encountered an unknown camera type - pan disabled.' );\\n\\t\\t\\t\\tscope.enablePan = false;\\n\\n\\t\\t\\t}\\n\\n\\t\\t};\\n\\n\\t}();\\n\\n\\tfunction dollyIn( dollyScale ) {\\n\\n\\t\\tif ( scope.object.isPerspectiveCamera ) {\\n\\n\\t\\t\\tscale /= dollyScale;\\n\\n\\t\\t} else if ( scope.object.isOrthographicCamera ) {\\n\\n\\t\\t\\tscope.object.zoom = Math.max( scope.minZoom, Math.min( scope.maxZoom, scope.object.zoom * dollyScale ) );\\n\\t\\t\\tscope.object.updateProjectionMatrix();\\n\\t\\t\\tzoomChanged = true;\\n\\n\\t\\t} else {\\n\\n\\t\\t\\tconsole.warn( 'WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled.' );\\n\\t\\t\\tscope.enableZoom = false;\\n\\n\\t\\t}\\n\\n\\t}\\n\\n\\tfunction dollyOut( dollyScale ) {\\n\\n\\t\\tif ( scope.object.isPerspectiveCamera ) {\\n\\n\\t\\t\\tscale *= dollyScale;\\n\\n\\t\\t} else if ( scope.object.isOrthographicCamera ) {\\n\\n\\t\\t\\tscope.object.zoom = Math.max( scope.minZoom, Math.min( scope.maxZoom, scope.object.zoom / dollyScale ) );\\n\\t\\t\\tscope.object.updateProjectionMatrix();\\n\\t\\t\\tzoomChanged = true;\\n\\n\\t\\t} else {\\n\\n\\t\\t\\tconsole.warn( 'WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled.' );\\n\\t\\t\\tscope.enableZoom = false;\\n\\n\\t\\t}\\n\\n\\t}\\n\\n\\t//\\n\\t// event callbacks - update the object state\\n\\t//\\n\\n\\tfunction handleMouseDownRotate( event ) {\\n\\n\\t\\t//console.log( 'handleMouseDownRotate' );\\n\\n\\t\\trotateStart.set( event.clientX, event.clientY );\\n\\n\\t}\\n\\n\\tfunction handleMouseDownDolly( event ) {\\n\\n\\t\\t//console.log( 'handleMouseDownDolly' );\\n\\n\\t\\tdollyStart.set( event.clientX, event.clientY );\\n\\n\\t}\\n\\n\\tfunction handleMouseDownPan( event ) {\\n\\n\\t\\t//console.log( 'handleMouseDownPan' );\\n\\n\\t\\tpanStart.set( event.clientX, event.clientY );\\n\\n\\t}\\n\\n\\tfunction handleMouseMoveRotate( event ) {\\n\\n\\t\\t//console.log( 'handleMouseMoveRotate' );\\n\\n\\t\\trotateEnd.set( event.clientX, event.clientY );\\n\\t\\trotateDelta.subVectors( rotateEnd, rotateStart );\\n\\n\\t\\tvar element = scope.domElement === document ? scope.domElement.body : scope.domElement;\\n\\n\\t\\t// rotating across whole screen goes 360 degrees around\\n\\t\\trotateLeft( 2 * Math.PI * rotateDelta.x / element.clientWidth * scope.rotateSpeed );\\n\\n\\t\\t// rotating up and down along whole screen attempts to go 360, but limited to 180\\n\\t\\trotateUp( 2 * Math.PI * rotateDelta.y / element.clientHeight * scope.rotateSpeed );\\n\\n\\t\\trotateStart.copy( rotateEnd );\\n\\n\\t\\tscope.update();\\n\\n\\t}\\n\\n\\tfunction handleMouseMoveDolly( event ) {\\n\\n\\t\\t//console.log( 'handleMouseMoveDolly' );\\n\\n\\t\\tdollyEnd.set( event.clientX, event.clientY );\\n\\n\\t\\tdollyDelta.subVectors( dollyEnd, dollyStart );\\n\\n\\t\\tif ( dollyDelta.y > 0 ) {\\n\\n\\t\\t\\tdollyIn( getZoomScale() );\\n\\n\\t\\t} else if ( dollyDelta.y < 0 ) {\\n\\n\\t\\t\\tdollyOut( getZoomScale() );\\n\\n\\t\\t}\\n\\n\\t\\tdollyStart.copy( dollyEnd );\\n\\n\\t\\tscope.update();\\n\\n\\t}\\n\\n\\tfunction handleMouseMovePan( event ) {\\n\\n\\t\\t//console.log( 'handleMouseMovePan' );\\n\\n\\t\\tpanEnd.set( event.clientX, event.clientY );\\n\\n\\t\\tpanDelta.subVectors( panEnd, panStart );\\n\\n\\t\\tpan( panDelta.x, panDelta.y );\\n\\n\\t\\tpanStart.copy( panEnd );\\n\\n\\t\\tscope.update();\\n\\n\\t}\\n\\n\\tfunction handleMouseUp( event ) {\\n\\n\\t\\t// console.log( 'handleMouseUp' );\\n\\n\\t}\\n\\n\\tfunction handleMouseWheel( event ) {\\n\\n\\t\\t// console.log( 'handleMouseWheel' );\\n\\n\\t\\tif ( event.deltaY < 0 ) {\\n\\n\\t\\t\\tdollyOut( getZoomScale() );\\n\\n\\t\\t} else if ( event.deltaY > 0 ) {\\n\\n\\t\\t\\tdollyIn( getZoomScale() );\\n\\n\\t\\t}\\n\\n\\t\\tscope.update();\\n\\n\\t}\\n\\n\\tfunction handleKeyDown( event ) {\\n\\n\\t\\t//console.log( 'handleKeyDown' );\\n\\n\\t\\tswitch ( event.keyCode ) {\\n\\n\\t\\t\\tcase scope.keys.UP:\\n\\t\\t\\t\\tpan( 0, scope.keyPanSpeed );\\n\\t\\t\\t\\tscope.update();\\n\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\tcase scope.keys.BOTTOM:\\n\\t\\t\\t\\tpan( 0, - scope.keyPanSpeed );\\n\\t\\t\\t\\tscope.update();\\n\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\tcase scope.keys.LEFT:\\n\\t\\t\\t\\tpan( scope.keyPanSpeed, 0 );\\n\\t\\t\\t\\tscope.update();\\n\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\tcase scope.keys.RIGHT:\\n\\t\\t\\t\\tpan( - scope.keyPanSpeed, 0 );\\n\\t\\t\\t\\tscope.update();\\n\\t\\t\\t\\tbreak;\\n\\n\\t\\t}\\n\\n\\t}\\n\\n\\tfunction handleTouchStartRotate( event ) {\\n\\n\\t\\t//console.log( 'handleTouchStartRotate' );\\n\\n\\t\\trotateStart.set( event.touches[ 0 ].pageX, event.touches[ 0 ].pageY );\\n\\n\\t}\\n\\n\\tfunction handleTouchStartDolly( event ) {\\n\\n\\t\\t//console.log( 'handleTouchStartDolly' );\\n\\n\\t\\tvar dx = event.touches[ 0 ].pageX - event.touches[ 1 ].pageX;\\n\\t\\tvar dy = event.touches[ 0 ].pageY - event.touches[ 1 ].pageY;\\n\\n\\t\\tvar distance = Math.sqrt( dx * dx + dy * dy );\\n\\n\\t\\tdollyStart.set( 0, distance );\\n\\n\\t}\\n\\n\\tfunction handleTouchStartPan( event ) {\\n\\n\\t\\t//console.log( 'handleTouchStartPan' );\\n\\n\\t\\tpanStart.set( event.touches[ 0 ].pageX, event.touches[ 0 ].pageY );\\n\\n\\t}\\n\\n\\tfunction handleTouchMoveRotate( event ) {\\n\\n\\t\\t//console.log( 'handleTouchMoveRotate' );\\n\\n\\t\\trotateEnd.set( event.touches[ 0 ].pageX, event.touches[ 0 ].pageY );\\n\\t\\trotateDelta.subVectors( rotateEnd, rotateStart );\\n\\n\\t\\tvar element = scope.domElement === document ? scope.domElement.body : scope.domElement;\\n\\n\\t\\t// rotating across whole screen goes 360 degrees around\\n\\t\\trotateLeft( 2 * Math.PI * rotateDelta.x / element.clientWidth * scope.rotateSpeed );\\n\\n\\t\\t// rotating up and down along whole screen attempts to go 360, but limited to 180\\n\\t\\trotateUp( 2 * Math.PI * rotateDelta.y / element.clientHeight * scope.rotateSpeed );\\n\\n\\t\\trotateStart.copy( rotateEnd );\\n\\n\\t\\tscope.update();\\n\\n\\t}\\n\\n\\tfunction handleTouchMoveDolly( event ) {\\n\\n\\t\\t//console.log( 'handleTouchMoveDolly' );\\n\\n\\t\\tvar dx = event.touches[ 0 ].pageX - event.touches[ 1 ].pageX;\\n\\t\\tvar dy = event.touches[ 0 ].pageY - event.touches[ 1 ].pageY;\\n\\n\\t\\tvar distance = Math.sqrt( dx * dx + dy * dy );\\n\\n\\t\\tdollyEnd.set( 0, distance );\\n\\n\\t\\tdollyDelta.subVectors( dollyEnd, dollyStart );\\n\\n\\t\\tif ( dollyDelta.y > 0 ) {\\n\\n\\t\\t\\tdollyOut( getZoomScale() );\\n\\n\\t\\t} else if ( dollyDelta.y < 0 ) {\\n\\n\\t\\t\\tdollyIn( getZoomScale() );\\n\\n\\t\\t}\\n\\n\\t\\tdollyStart.copy( dollyEnd );\\n\\n\\t\\tscope.update();\\n\\n\\t}\\n\\n\\tfunction handleTouchMovePan( event ) {\\n\\n\\t\\t//console.log( 'handleTouchMovePan' );\\n\\n\\t\\tpanEnd.set( event.touches[ 0 ].pageX, event.touches[ 0 ].pageY );\\n\\n\\t\\tpanDelta.subVectors( panEnd, panStart );\\n\\n\\t\\tpan( panDelta.x, panDelta.y );\\n\\n\\t\\tpanStart.copy( panEnd );\\n\\n\\t\\tscope.update();\\n\\n\\t}\\n\\n\\tfunction handleTouchEnd( event ) {\\n\\n\\t\\t//console.log( 'handleTouchEnd' );\\n\\n\\t}\\n\\n\\t//\\n\\t// event handlers - FSM: listen for events and reset state\\n\\t//\\n\\n\\tfunction onMouseDown( event ) {\\n\\n\\t\\tif ( scope.enabled === false ) return;\\n\\n\\t\\tevent.preventDefault();\\n\\n\\t\\tswitch ( event.button ) {\\n\\n\\t\\t\\tcase scope.mouseButtons.ORBIT:\\n\\n\\t\\t\\t\\tif ( scope.enableRotate === false ) return;\\n\\n\\t\\t\\t\\thandleMouseDownRotate( event );\\n\\n\\t\\t\\t\\tstate = STATE.ROTATE;\\n\\n\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\tcase scope.mouseButtons.ZOOM:\\n\\n\\t\\t\\t\\tif ( scope.enableZoom === false ) return;\\n\\n\\t\\t\\t\\thandleMouseDownDolly( event );\\n\\n\\t\\t\\t\\tstate = STATE.DOLLY;\\n\\n\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\tcase scope.mouseButtons.PAN:\\n\\n\\t\\t\\t\\tif ( scope.enablePan === false ) return;\\n\\n\\t\\t\\t\\thandleMouseDownPan( event );\\n\\n\\t\\t\\t\\tstate = STATE.PAN;\\n\\n\\t\\t\\t\\tbreak;\\n\\n\\t\\t}\\n\\n\\t\\tif ( state !== STATE.NONE ) {\\n\\n\\t\\t\\tdocument.addEventListener( 'mousemove', onMouseMove, false );\\n\\t\\t\\tdocument.addEventListener( 'mouseup', onMouseUp, false );\\n\\n\\t\\t\\tscope.dispatchEvent( startEvent );\\n\\n\\t\\t}\\n\\n\\t}\\n\\n\\tfunction onMouseMove( event ) {\\n\\n\\t\\tif ( scope.enabled === false ) return;\\n\\n\\t\\tevent.preventDefault();\\n\\n\\t\\tswitch ( state ) {\\n\\n\\t\\t\\tcase STATE.ROTATE:\\n\\n\\t\\t\\t\\tif ( scope.enableRotate === false ) return;\\n\\n\\t\\t\\t\\thandleMouseMoveRotate( event );\\n\\n\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\tcase STATE.DOLLY:\\n\\n\\t\\t\\t\\tif ( scope.enableZoom === false ) return;\\n\\n\\t\\t\\t\\thandleMouseMoveDolly( event );\\n\\n\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\tcase STATE.PAN:\\n\\n\\t\\t\\t\\tif ( scope.enablePan === false ) return;\\n\\n\\t\\t\\t\\thandleMouseMovePan( event );\\n\\n\\t\\t\\t\\tbreak;\\n\\n\\t\\t}\\n\\n\\t}\\n\\n\\tfunction onMouseUp( event ) {\\n\\n\\t\\tif ( scope.enabled === false ) return;\\n\\n\\t\\thandleMouseUp( event );\\n\\n\\t\\tdocument.removeEventListener( 'mousemove', onMouseMove, false );\\n\\t\\tdocument.removeEventListener( 'mouseup', onMouseUp, false );\\n\\n\\t\\tscope.dispatchEvent( endEvent );\\n\\n\\t\\tstate = STATE.NONE;\\n\\n\\t}\\n\\n\\tfunction onMouseWheel( event ) {\\n\\n\\t\\tif ( scope.enabled === false || scope.enableZoom === false || ( state !== STATE.NONE && state !== STATE.ROTATE ) ) return;\\n\\n\\t\\tevent.preventDefault();\\n\\t\\tevent.stopPropagation();\\n\\n\\t\\thandleMouseWheel( event );\\n\\n\\t\\tscope.dispatchEvent( startEvent ); // not sure why these are here...\\n\\t\\tscope.dispatchEvent( endEvent );\\n\\n\\t}\\n\\n\\tfunction onKeyDown( event ) {\\n\\n\\t\\tif ( scope.enabled === false || scope.enableKeys === false || scope.enablePan === false ) return;\\n\\n\\t\\thandleKeyDown( event );\\n\\n\\t}\\n\\n\\tfunction onTouchStart( event ) {\\n\\n\\t\\tif ( scope.enabled === false ) return;\\n\\n\\t\\tswitch ( event.touches.length ) {\\n\\n\\t\\t\\tcase 1:\\t// one-fingered touch: rotate\\n\\n\\t\\t\\t\\tif ( scope.enableRotate === false ) return;\\n\\n\\t\\t\\t\\thandleTouchStartRotate( event );\\n\\n\\t\\t\\t\\tstate = STATE.TOUCH_ROTATE;\\n\\n\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\tcase 2:\\t// two-fingered touch: dolly\\n\\n\\t\\t\\t\\tif ( scope.enableZoom === false ) return;\\n\\n\\t\\t\\t\\thandleTouchStartDolly( event );\\n\\n\\t\\t\\t\\tstate = STATE.TOUCH_DOLLY;\\n\\n\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\tcase 3: // three-fingered touch: pan\\n\\n\\t\\t\\t\\tif ( scope.enablePan === false ) return;\\n\\n\\t\\t\\t\\thandleTouchStartPan( event );\\n\\n\\t\\t\\t\\tstate = STATE.TOUCH_PAN;\\n\\n\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\tdefault:\\n\\n\\t\\t\\t\\tstate = STATE.NONE;\\n\\n\\t\\t}\\n\\n\\t\\tif ( state !== STATE.NONE ) {\\n\\n\\t\\t\\tscope.dispatchEvent( startEvent );\\n\\n\\t\\t}\\n\\n\\t}\\n\\n\\tfunction onTouchMove( event ) {\\n\\n\\t\\tif ( scope.enabled === false ) return;\\n\\n\\t\\tevent.preventDefault();\\n\\t\\tevent.stopPropagation();\\n\\n\\t\\tswitch ( event.touches.length ) {\\n\\n\\t\\t\\tcase 1: // one-fingered touch: rotate\\n\\n\\t\\t\\t\\tif ( scope.enableRotate === false ) return;\\n\\t\\t\\t\\tif ( state !== STATE.TOUCH_ROTATE ) return; // is this needed?...\\n\\n\\t\\t\\t\\thandleTouchMoveRotate( event );\\n\\n\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\tcase 2: // two-fingered touch: dolly\\n\\n\\t\\t\\t\\tif ( scope.enableZoom === false ) return;\\n\\t\\t\\t\\tif ( state !== STATE.TOUCH_DOLLY ) return; // is this needed?...\\n\\n\\t\\t\\t\\thandleTouchMoveDolly( event );\\n\\n\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\tcase 3: // three-fingered touch: pan\\n\\n\\t\\t\\t\\tif ( scope.enablePan === false ) return;\\n\\t\\t\\t\\tif ( state !== STATE.TOUCH_PAN ) return; // is this needed?...\\n\\n\\t\\t\\t\\thandleTouchMovePan( event );\\n\\n\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\tdefault:\\n\\n\\t\\t\\t\\tstate = STATE.NONE;\\n\\n\\t\\t}\\n\\n\\t}\\n\\n\\tfunction onTouchEnd( event ) {\\n\\n\\t\\tif ( scope.enabled === false ) return;\\n\\n\\t\\thandleTouchEnd( event );\\n\\n\\t\\tscope.dispatchEvent( endEvent );\\n\\n\\t\\tstate = STATE.NONE;\\n\\n\\t}\\n\\n\\tfunction onContextMenu( event ) {\\n\\n\\t\\tif ( scope.enabled === false ) return;\\n\\n\\t\\tevent.preventDefault();\\n\\n\\t}\\n\\n\\t//\\n\\n\\tscope.domElement.addEventListener( 'contextmenu', onContextMenu, false );\\n\\n\\tscope.domElement.addEventListener( 'mousedown', onMouseDown, false );\\n\\tscope.domElement.addEventListener( 'wheel', onMouseWheel, false );\\n\\n\\tscope.domElement.addEventListener( 'touchstart', onTouchStart, false );\\n\\tscope.domElement.addEventListener( 'touchend', onTouchEnd, false );\\n\\tscope.domElement.addEventListener( 'touchmove', onTouchMove, false );\\n\\n\\twindow.addEventListener( 'keydown', onKeyDown, false );\\n\\n\\t// force an update at start\\n\\n\\tthis.update();\\n\\n};\\n\\nOrbitControls.prototype = Object.create( THREE.EventDispatcher.prototype );\\nOrbitControls.prototype.constructor = OrbitControls;\\n\\nObject.defineProperties( OrbitControls.prototype, {\\n\\n\\tcenter: {\\n\\n\\t\\tget: function () {\\n\\n\\t\\t\\tconsole.warn( 'OrbitControls: .center has been renamed to .target' );\\n\\t\\t\\treturn this.target;\\n\\n\\t\\t}\\n\\n\\t},\\n\\n\\t// backward compatibility\\n\\n\\tnoZoom: {\\n\\n\\t\\tget: function () {\\n\\n\\t\\t\\tconsole.warn( 'OrbitControls: .noZoom has been deprecated. Use .enableZoom instead.' );\\n\\t\\t\\treturn ! this.enableZoom;\\n\\n\\t\\t},\\n\\n\\t\\tset: function ( value ) {\\n\\n\\t\\t\\tconsole.warn( 'OrbitControls: .noZoom has been deprecated. Use .enableZoom instead.' );\\n\\t\\t\\tthis.enableZoom = ! value;\\n\\n\\t\\t}\\n\\n\\t},\\n\\n\\tnoRotate: {\\n\\n\\t\\tget: function () {\\n\\n\\t\\t\\tconsole.warn( 'OrbitControls: .noRotate has been deprecated. Use .enableRotate instead.' );\\n\\t\\t\\treturn ! this.enableRotate;\\n\\n\\t\\t},\\n\\n\\t\\tset: function ( value ) {\\n\\n\\t\\t\\tconsole.warn( 'OrbitControls: .noRotate has been deprecated. Use .enableRotate instead.' );\\n\\t\\t\\tthis.enableRotate = ! value;\\n\\n\\t\\t}\\n\\n\\t},\\n\\n\\tnoPan: {\\n\\n\\t\\tget: function () {\\n\\n\\t\\t\\tconsole.warn( 'OrbitControls: .noPan has been deprecated. Use .enablePan instead.' );\\n\\t\\t\\treturn ! this.enablePan;\\n\\n\\t\\t},\\n\\n\\t\\tset: function ( value ) {\\n\\n\\t\\t\\tconsole.warn( 'OrbitControls: .noPan has been deprecated. Use .enablePan instead.' );\\n\\t\\t\\tthis.enablePan = ! value;\\n\\n\\t\\t}\\n\\n\\t},\\n\\n\\tnoKeys: {\\n\\n\\t\\tget: function () {\\n\\n\\t\\t\\tconsole.warn( 'OrbitControls: .noKeys has been deprecated. Use .enableKeys instead.' );\\n\\t\\t\\treturn ! this.enableKeys;\\n\\n\\t\\t},\\n\\n\\t\\tset: function ( value ) {\\n\\n\\t\\t\\tconsole.warn( 'OrbitControls: .noKeys has been deprecated. Use .enableKeys instead.' );\\n\\t\\t\\tthis.enableKeys = ! value;\\n\\n\\t\\t}\\n\\n\\t},\\n\\n\\tstaticMoving: {\\n\\n\\t\\tget: function () {\\n\\n\\t\\t\\tconsole.warn( 'OrbitControls: .staticMoving has been deprecated. Use .enableDamping instead.' );\\n\\t\\t\\treturn ! this.enableDamping;\\n\\n\\t\\t},\\n\\n\\t\\tset: function ( value ) {\\n\\n\\t\\t\\tconsole.warn( 'OrbitControls: .staticMoving has been deprecated. Use .enableDamping instead.' );\\n\\t\\t\\tthis.enableDamping = ! value;\\n\\n\\t\\t}\\n\\n\\t},\\n\\n\\tdynamicDampingFactor: {\\n\\n\\t\\tget: function () {\\n\\n\\t\\t\\tconsole.warn( 'OrbitControls: .dynamicDampingFactor has been renamed. Use .dampingFactor instead.' );\\n\\t\\t\\treturn this.dampingFactor;\\n\\n\\t\\t},\\n\\n\\t\\tset: function ( value ) {\\n\\n\\t\\t\\tconsole.warn( 'OrbitControls: .dynamicDampingFactor has been renamed. Use .dampingFactor instead.' );\\n\\t\\t\\tthis.dampingFactor = value;\\n\\n\\t\\t}\\n\\n\\t}\\n\\n} );\\n\\nexport default OrbitControls;\\n\",\"const groundPlane = new THREE.Plane(new THREE.Vector3(0, 1, 0));\\nlet panning = false;\\n\\nexport default class TopDownCameraControls {\\n  constructor(domElement, camera) {\\n    this.domElement = domElement;\\n    this.camera = camera;\\n    this.enablePanning = false;\\n    this.enabled = true;\\n\\n    this.mouseDown = this.mouseDown.bind(this);\\n    this.mouseMove = this.mouseMove.bind(this);\\n    this.mouseUp = this.mouseUp.bind(this);\\n    this.wheel = this.wheel.bind(this);\\n\\n    this.domElement.addEventListener('mousedown', this.mouseDown);\\n    this.domElement.addEventListener('mousemove', this.mouseMove);\\n    this.domElement.addEventListener('mouseup', this.mouseUp);\\n    this.domElement.addEventListener('wheel', this.wheel);\\n  }\\n\\n  reset(prevCamera) {\\n    const lookAt = new THREE.Vector3(0, 0, -1);\\n    lookAt.applyQuaternion(prevCamera.quaternion);\\n\\n    const ray = new THREE.Ray(prevCamera.position, lookAt);\\n    const intersection = ray.intersectPlane(groundPlane);\\n\\n    if (intersection) {\\n      this.camera.position.set(intersection.x, 50, intersection.z);\\n    } else {\\n      this.camera.position.y = 50;\\n    }\\n\\n    this.camera.rotation.set(-Math.PI / 2, 0, 0);\\n  }\\n\\n  mouseDown(event) {\\n    if (!this.enabled || !this.enablePanning || event.button != 2) return;\\n    panning = true;\\n  }\\n\\n  mouseMove(event) {\\n    if (panning) {\\n      const distance = 2 * this.camera.position.y * Math.tan((this.camera.fov / 2) * Math.PI / 180) / this.domElement.clientHeight;\\n      this.camera.position.x -= distance * event.movementX;\\n      this.camera.position.z -= distance * event.movementY;\\n    }\\n  }\\n\\n  mouseUp(event) {\\n    if (event.button != 2) return;\\n    panning = false;\\n  }\\n\\n  wheel(event) {\\n    if (!this.enabled) return;\\n\\n    event.preventDefault();\\n\\n    this.camera.position.y *= Math.pow(0.995, -event.deltaY);\\n  }\\n}\\n\",\"import Car from \\\"../physics/Car.js\\\";\\n\\nconst MPS_TO_MPH = 2.23694;\\nconst METERS_TO_FEET = 3.28084;\\n\\nexport default class Dashboard {\\n  constructor(car) {\\n    this.car = car;\\n    this.units = 'metric';\\n\\n    if (document.readyState == 'complete') {\\n      this.fetchDomElements.call(this);\\n    } else {\\n      document.addEventListener('readystatechange', event => {\\n        if (event.target.readyState == 'complete')\\n          this.fetchDomElements.call(this);\\n      });\\n    }\\n  }\\n\\n  fetchDomElements() {\\n    this.wheelDom = document.getElementById('wheel');\\n    this.wheelPieDom = document.getElementById('wheel-pie');\\n    this.wheelPieLeftDom = document.getElementById('wheel-pie-left');\\n    this.wheelPieRightDom = document.getElementById('wheel-pie-right');\\n    this.gearDom = document.getElementById('gear');\\n    this.gasDom = document.getElementById('gas');\\n    this.brakeDom = document.getElementById('brake');\\n    this.speedDom = document.getElementById('speed');\\n    this.stationDom = document.getElementById('station');\\n    this.latitudeDom = document.getElementById('latitude');\\n    this.planTimeDom = document.getElementById('plan-time');\\n    this.elapsedTimeDom = document.getElementById('elapsed-time');\\n\\n    this.speedUnitsDom = document.getElementById('speed-units');\\n    this.stationUnitsDom = document.getElementById('station-units');\\n    this.latitudeUnitsDom = document.getElementById('latitude-units');\\n\\n    [this.speedUnitsDom, this.stationUnitsDom, this.latitudeUnitsDom].forEach(el => {\\n      el.addEventListener('click', event => {\\n        this.toggleUnits();\\n      });\\n    });\\n  }\\n\\n  toggleUnits() {\\n    let speedUnits;\\n    let distanceUnits;\\n\\n    if (this.units == 'metric') {\\n      this.units = 'imperial';\\n      speedUnits = 'mph';\\n      distanceUnits = 'feet';\\n    } else {\\n      this.units = 'metric';\\n      speedUnits = 'm/s';\\n      distanceUnits = 'meters';\\n    }\\n\\n    this.speedUnitsDom.innerHTML = speedUnits;\\n    this.stationUnitsDom.innerHTML = distanceUnits;\\n    this.latitudeUnitsDom.innerHTML = distanceUnits;\\n  }\\n\\n  update(controls, speed, station, latitude, elapsedTime, planTime) {\\n    if (!this.wheelDom) return;\\n\\n    if (this.units == 'imperial') {\\n      speed *= MPS_TO_MPH;\\n      station = station !== null ? station * METERS_TO_FEET : null;\\n      latitude = latitude !== null ? latitude * METERS_TO_FEET : null;\\n    }\\n\\n    const wheelTurn = Math.clamp(this.car.wheelAngle / Car.MAX_WHEEL_ANGLE * 0.95, -1, +1);\\n\\n    this.wheelDom.style.transform = `rotate(${wheelTurn}turn)`;\\n\\n    if (wheelTurn >= 0) {\\n      this.wheelPieRightDom.style.transform = `rotate(${wheelTurn}turn)`;\\n\\n      if (wheelTurn <= 0.5) {\\n        this.wheelPieDom.style.clipPath = \\\"inset(0 0 0 50%)\\\";\\n        this.wheelPieLeftDom.style.transform = \\\"rotate(0)\\\";\\n      } else {\\n        this.wheelPieDom.style.clipPath = \\\"inset(0 0 0 0)\\\";\\n        this.wheelPieLeftDom.style.transform = \\\"rotate(0.5turn)\\\";\\n      }\\n    } else {\\n      this.wheelPieRightDom.style.transform = `rotate(${0.5 + wheelTurn}turn)`;\\n\\n      if (wheelTurn >= -0.5) {\\n        this.wheelPieDom.style.clipPath = \\\"inset(0 50% 0 0)\\\";\\n        this.wheelPieLeftDom.style.transform = \\\"rotate(0.5turn)\\\";\\n      } else {\\n        this.wheelPieDom.style.clipPath = \\\"inset(0 0 0 0)\\\";\\n        this.wheelPieLeftDom.style.transform = \\\"rotate(0)\\\";\\n      }\\n    }\\n\\n    this.gearDom.innerText = controls.gas < 0 ? 'R' : 'D';\\n    this.brakeDom.style.clipPath = `inset(50% 50% 0 ${50 - controls.brake * 25}%)`;\\n    this.gasDom.style.clipPath = `inset(50% ${50 - Math.abs(controls.gas) * 25}% 0 50%)`;\\n\\n    this.speedDom.innerHTML = speed.toFixed(1);\\n    this.stationDom.innerHTML = station !== null ? station.toFixed(1) : '&mdash;';\\n    this.latitudeDom.innerHTML = latitude !== null ? latitude.toFixed(2) : '&mdash;';\\n    this.planTimeDom.innerHTML = planTime !== null ? (planTime * 1000).toFixed(0) : '&mdash;';\\n\\n    let mins = Math.floor(elapsedTime / 60);\\n    let seconds = elapsedTime % 60;\\n\\n    if (mins == 0) {\\n      this.elapsedTimeDom.innerHTML = seconds.toFixed(1);\\n    } else {\\n      if (seconds < 10)\\n        seconds = '0' + seconds.toFixed(1);\\n      else\\n        seconds = seconds.toFixed(1);\\n\\n      this.elapsedTimeDom.innerHTML = `${mins}:${seconds}`;\\n    }\\n  }\\n}\\n\",\"import GPGPU from \\\"../../GPGPU.js\\\";\\n\\nconst SPATIAL_HORIZON = 100; // meters\\nconst LANE_WIDTH = 3.7; // meters\\nconst NUM_STATIONS = 10;\\nconst NUM_LATITUDES = 19;\\nconst STATION_CONNECTIVITY = 3;\\nconst LATITUDE_CONNECTIVITY = 9;\\n\\nif (NUM_LATITUDES % 2 != 1)\\n  throw new Error(`Expected NUM_LATITUDES to be odd but it is ${NUM_LATITUDES}.`);\\n\\nif (LATITUDE_CONNECTIVITY % 2 != 1)\\n  throw new Error(`Expected LATITUDE_CONNECTIVITY to be odd but it is ${LATITUDE_CONNECTIVITY}.`);\\n\\nif (LATITUDE_CONNECTIVITY > NUM_LATITUDES)\\n  throw new Error(\\\"LATITUDE_CONNECTIVITY cannot be larger than NUM_LATITUDES.\\\");\\n\\nexport default class {\\n  constructor(lanePath, latticeStartStation) {\\n    const stationInterval = SPATIAL_HORIZON / NUM_STATIONS;\\n    // TODO: try transforming points into vehicle space\\n    const centerline = lanePath.sampleStations(latticeStartStation, NUM_STATIONS, stationInterval);\\n    const lattice = new Array(NUM_STATIONS);\\n    const offset = Math.floor(NUM_LATITUDES / 2);\\n\\n    for (let s = 0; s < NUM_STATIONS; s++) {\\n      const sample = centerline[s];\\n      const latitudes = lattice[s] = new Array(NUM_LATITUDES);\\n\\n      for (let l = 0; l < NUM_LATITUDES; l++) {\\n        const latitude = (l - offset) / offset * LANE_WIDTH / 2;\\n        const rot = sample.rot;\\n        const pos = THREE.Vector2.fromAngle(rot + Math.PI / 2).multiplyScalar(latitude).add(sample.pos);\\n        const curv = sample.curv == 0 ? 0 : 1 / (1 / sample.curv - latitude);\\n\\n        latitudes[l] = { pos, rot, curv };\\n      }\\n    }\\n\\n    this.lattice = lattice;\\n  }\\n}\\n\",\"export default class MovingAverage {\\n  constructor(maxSamples) {\\n    this.samples = new Array(maxSamples);\\n    this.numSamples = 0;\\n    this.nextIndex = 0;\\n    this.average = null;\\n  }\\n\\n  addSample(sample) {\\n    this.samples[this.nextIndex++] = sample;\\n    this.nextIndex = this.nextIndex % this.samples.length;\\n    this.numSamples = Math.min(this.numSamples + 1, this.samples.length);\\n\\n    const k = 2 / (this.numSamples + 1);\\n    let curr = this.nextIndex % this.numSamples;\\n    let newAverage = this.samples[curr];\\n\\n    for (let i = 1; i < this.numSamples; i++) {\\n      curr = (curr + 1) % this.numSamples;\\n      newAverage = this.samples[curr] * k + newAverage * (1 - k);\\n    }\\n\\n    this.average = newAverage;\\n  }\\n}\\n\",\"import Car from \\\"../physics/Car.js\\\";\\n\\nconst LOCAL_STORAGE_KEY = 'dashPathPlannerConfig';\\n\\nconst internalConfig = {\\n  lattice: {\\n    numStations: 10,\\n    numLatitudes: 11,\\n    stationConnectivity: 3,\\n    latitudeConnectivity: 5\\n  },\\n\\n  dCurvatureMax: Car.MAX_STEER_SPEED / Car.WHEEL_BASE,\\n  rearAxleToCenter: -Car.REAR_AXLE_POS\\n};\\n\\nconst defaultConfig = {\\n  spatialHorizon: 100, // meters\\n  centerlineStationInterval: 0.5, // meters\\n\\n  xyGridCellSize: 0.1, // meters\\n  slGridCellSize: 0.05, // meters\\n  gridMargin: 10, // meters\\n  pathSamplingStep: 0.5, // meters\\n\\n  cubicPathPenalty: 10,\\n\\n  lethalDilationS: Car.HALF_CAR_LENGTH + 1, // meters\\n  hazardDilationS: 12, // meters\\n  lethalDilationL: Car.HALF_CAR_WIDTH + 0.25, //meters\\n  hazardDilationL: 0.5, // meters\\n\\n  obstacleHazardCost: 3,\\n\\n  laneWidth: 3.7, // meters\\n  laneShoulderCost: 1,\\n  laneShoulderLatitude: 3.7 / 2 - Car.HALF_CAR_WIDTH,\\n  laneCostSlope: 5, // cost / meter\\n\\n  stationReachDiscount: 70,\\n  extraTimePenalty: 64,\\n\\n  hysteresisDiscount: 40,\\n\\n  speedLimit: 20, // m/s\\n  speedLimitPenalty: 2,\\n\\n  hardAccelerationPenalty: 6,\\n  hardDecelerationPenalty: 6,\\n\\n  lateralAccelerationLimit: 3, // m/s^2\\n  softLateralAccelerationPenalty: 4,\\n  linearLateralAccelerationPenalty: 4,\\n\\n  accelerationChangePenalty: 2\\n};\\n\\nexport default class PathPlannerConfigEditor {\\n  constructor() {\\n    this._config = Object.assign({}, defaultConfig);\\n\\n    this.showConfigBox = document.getElementById('show-config-box');\\n    this.configBox = document.getElementById('config-box-content');\\n    this.configForm = document.getElementById('config-form');\\n\\n    this._setUpButtons();\\n\\n    let storedConfig = {};\\n    try {\\n      storedConfig = JSON.parse(window.localStorage.getItem(LOCAL_STORAGE_KEY)) || {};\\n    } catch (e) {}\\n\\n    for (const key of Object.keys(this._config).sort()) {\\n      if (storedConfig[key] !== undefined) this._config[key] = storedConfig[key];\\n      this.configForm.appendChild(this._createConfigField(key, this._config[key]));\\n    }\\n  }\\n\\n  get config() {\\n    return Object.assign({}, this._config, internalConfig);\\n  }\\n\\n  _setUpButtons() {\\n    document.getElementById('show-config-button').addEventListener('click', e => {\\n      this.showConfigBox.classList.add('is-hidden');\\n      this.configBox.classList.remove('is-hidden');\\n    });\\n\\n    document.getElementById('hide-config-button').addEventListener('click', e => {\\n      this.showConfigBox.classList.remove('is-hidden');\\n      this.configBox.classList.add('is-hidden');\\n    });\\n\\n    document.getElementById('save-config-button').addEventListener('click', this._saveConfigFields.bind(this));\\n    document.getElementById('restore-defaults-config-button').addEventListener('click', this._restoreDefaults.bind(this));\\n  }\\n\\n  _createConfigField(key, value) {\\n    const html =\\n      `<div class=\\\"field is-horizontal\\\">\\n          <div class=\\\"field-label is-small\\\" style=\\\"flex-grow: 100;\\\">\\n              <label class=\\\"label has-text-grey-light\\\" for=\\\"config-field-${key}\\\">${key}</label>\\n          </div>\\n          <div class=\\\"field-body\\\">\\n              <div class=\\\"field\\\">\\n                  <div class=\\\"control\\\" style=\\\"margin-right: 16px;\\\">\\n                      <input id=\\\"config-field-${key}\\\" name=\\\"${key}\\\" class=\\\"input is-small ${value != defaultConfig[key] ? 'is-danger' : ''}\\\" type=\\\"text\\\" style=\\\"width: 60px; border-width: 2px;\\\" value=\\\"${value}\\\" />\\n                  </div>\\n              </div>\\n          </div>\\n      </div>`;\\n\\n    const template = document.createElement('template');\\n    template.innerHTML = html;\\n    return template.content.firstChild;\\n  }\\n\\n  _saveConfigFields() {\\n    const formData = new FormData(this.configForm);\\n\\n    for (const [k, v] of formData.entries()) {\\n      this._config[k] = Number.parseFloat(v);\\n\\n      const fieldDom = document.getElementById(`config-field-${k}`);\\n      if (v == defaultConfig[k])\\n        fieldDom.classList.remove('is-danger');\\n      else\\n        fieldDom.classList.add('is-danger');\\n    }\\n\\n    try {\\n      window.localStorage.setItem(LOCAL_STORAGE_KEY, JSON.stringify(this._config));\\n    } catch (e) {}\\n  }\\n\\n  _restoreDefaults() {\\n    this._config = defaultConfig;\\n\\n    try {\\n      window.localStorage.removeItem(LOCAL_STORAGE_KEY);\\n    } catch (e) {}\\n\\n    while (this.configForm.firstChild)\\n      this.configForm.removeChild(this.configForm.firstChild);\\n\\n    for (const key of Object.keys(this._config).sort())\\n      this.configForm.appendChild(this._createConfigField(key, this._config[key]));\\n  }\\n}\\n\",\"import Physics from \\\"./physics/simple/Physics.js\\\";\\nimport Path from \\\"./autonomy/Path.js\\\";\\nimport CubicPath from \\\"./autonomy/path-planning/CubicPath.js\\\";\\nimport AutonomousController from \\\"./autonomy/control/AutonomousController.js\\\";\\nimport FollowController from \\\"./autonomy/control/FollowController.js\\\";\\nimport ManualController from \\\"./autonomy/control/ManualController.js\\\";\\nimport MapObject from \\\"./objects/MapObject.js\\\";\\nimport CarObject from \\\"./objects/CarObject.js\\\";\\nimport Editor from \\\"./simulator/Editor.js\\\";\\nimport OrbitControls from \\\"./simulator/OrbitControls.js\\\";\\nimport TopDownCameraControls from \\\"./simulator/TopDownCameraControls.js\\\";\\nimport Dashboard from \\\"./simulator/Dashboard.js\\\";\\nimport GPGPU from \\\"./GPGPU.js\\\";\\nimport RoadLattice from \\\"./autonomy/path-planning/RoadLattice.js\\\";\\nimport PathPlanner from \\\"./autonomy/path-planning/PathPlanner.js\\\";\\nimport StaticObstacle from \\\"./autonomy/path-planning/StaticObstacle.js\\\";\\nimport MovingAverage from \\\"./autonomy/MovingAverage.js\\\";\\nimport PathPlannerConfigEditor from \\\"./simulator/PathPlannerConfigEditor.js\\\";\\n\\nconst FRAME_TIMESTEP = 1 / 60;\\n\\nexport default class Simulator {\\n  constructor(geolocation, domElement) {\\n    this.geolocation = geolocation;\\n\\n    this.pathPlannerWorker = new Worker('dist/PathPlannerWorker.js');\\n    this.pathPlannerWorker.onmessage = this.receivePlannedPath.bind(this);\\n    this.pathPlannerConfigEditor = new PathPlannerConfigEditor();\\n\\n    this.physics = new Physics();\\n    this.car = this.physics.createCar();\\n\\n    this.renderer = new THREE.WebGLRenderer();\\n    this.renderer.setPixelRatio(window.devicePixelRatio);\\n    this.renderer.setSize(domElement.clientWidth, domElement.clientHeight);\\n    this.renderer.shadowMap.enabled = true;\\n    domElement.appendChild(this.renderer.domElement);\\n\\n    this.lastPlanParams = null;\\n    this.renderer.context.canvas.addEventListener('webglcontextlost', event => {\\n      console.log('Simulator: webgl context lost');\\n      console.log(event);\\n      console.log(this.lastPlanParams);\\n    });\\n\\n    this._setUpCameras(this.renderer.domElement);\\n\\n    this.scene = new THREE.Scene();\\n    this.sceneFog = new THREE.FogExp2(0x111111, 0.0025);\\n    this.scene.fog = this.sceneFog;\\n    this.scene.background = new THREE.Color(0x111111);\\n\\n    this.editor = new Editor(this.renderer.domElement, this.editorCamera, this.scene);\\n\\n    const map = new MapObject(this.geolocation);\\n    this.scene.add(map);\\n\\n    const carObject = new CarObject(this.car);\\n    this.scene.add(carObject);\\n\\n    this.manualCarController = new ManualController();\\n    this.autonomousCarController = null;\\n\\n    this.dashboard = new Dashboard(this.car);\\n\\n    this.plannerReady = false;\\n    this.plannerReset = false;\\n    this.plannerEnabled = false;\\n    this.plannedPathGroup = new THREE.Group();\\n    this.scene.add(this.plannedPathGroup);\\n\\n    this.paused = false;\\n    this.prevTimestamp = null;\\n    this.frameCounter = 0;\\n    this.fpsTime = 0;\\n    this.fps = 1 / FRAME_TIMESTEP;\\n    this.simulatedTime = 0;\\n    this.lastPlanTime = null;\\n    this.averagePlanTime = new MovingAverage(20);\\n\\n    window.addEventListener('resize', () => {\\n      this._updateCameraAspects(domElement.clientWidth / domElement.clientHeight);\\n      this.renderer.setSize(domElement.clientWidth, domElement.clientHeight);\\n    });\\n\\n    this.manualModeButton = document.getElementById('mode-manual');\\n    this.manualModeButton.addEventListener('click', this.enableManualMode.bind(this));\\n    this.autonomousModeButton = document.getElementById('mode-autonomous');\\n    this.autonomousModeButton.addEventListener('click', this.enableAutonomousMode.bind(this));\\n\\n    document.getElementById('editor-enable').addEventListener('click', this.enableEditor.bind(this));\\n    document.getElementById('editor-save').addEventListener('click', this.finalizeEditor.bind(this));\\n    document.getElementById('scenario-restart').addEventListener('click', this.restartScenario.bind(this));\\n\\n    this.simModeBoxes = Array.prototype.slice.call(document.getElementsByClassName('sim-mode-box'), 0);\\n    this.editModeBoxes = Array.prototype.slice.call(document.getElementsByClassName('edit-mode-box'), 0);\\n\\n    this.fpsBox = document.getElementById('fps');\\n\\n    this.enableManualMode();\\n    this.changeCamera('chase');\\n\\n    this.aroundAnchorIndex = null;\\n    this.obstacles = [];\\n\\n    requestAnimationFrame(step.bind(this));\\n  }\\n\\n  toss() {\\n    const pose = this.car.pose;\\n    const rotVec = THREE.Vector2.fromAngle(pose.rot);\\n    const pos = rotVec.clone().multiplyScalar(50).add(new THREE.Vector2(rotVec.y, rotVec.x)).add(pose.pos);\\n    const obstacle = new StaticObstacle(pos, 0, 0.5, 0.5);\\n\\n    const obsGeom = new THREE.PlaneGeometry(obstacle.width, obstacle.height);\\n    const obsMat = new THREE.MeshBasicMaterial({ color: 0x0000ff, depthTest: false, transparent: true, opacity: 0.5 });\\n    const obsObj = new THREE.Mesh(obsGeom, obsMat);\\n    obsObj.rotation.x = -Math.PI / 2;\\n    obsObj.rotation.z = -obstacle.rot;\\n    obsObj.position.set(obstacle.pos.x, 0, obstacle.pos.y);\\n    this.scene.add(obsObj);\\n\\n    this.obstacles.push(obstacle);\\n  }\\n\\n  _setUpCameras(domElement) {\\n    this.chaseCamera = new THREE.PerspectiveCamera(45, domElement.clientWidth / domElement.clientHeight, 1, 10000);\\n    this.chaseCameraControls = new OrbitControls(this.chaseCamera, domElement);\\n    this.chaseCameraControls.maxPolarAngle = Math.PI / 2.02;\\n    this.chaseCameraControls.enablePan = false;\\n    this.chaseCameraControls.enabled = false;\\n    this._resetChaseCamera();\\n\\n    this.freeCamera = new THREE.PerspectiveCamera(45, domElement.clientWidth / domElement.clientHeight, 1, 10000);\\n    this.freeCameraControls = new OrbitControls(this.freeCamera, domElement);\\n    this.freeCameraControls.maxPolarAngle = Math.PI / 2.02;\\n    this.freeCameraControls.enabled = true;\\n    this._resetFreeCamera();\\n\\n    this.topDownCamera = new THREE.PerspectiveCamera(45, domElement.clientWidth / domElement.clientHeight, 1, 10000);\\n    this.topDownCamera.position.set(0, 50, 0);\\n    this.topDownCamera.lookAt(0, 0, 0);\\n    this.topDownControls = new TopDownCameraControls(domElement, this.topDownCamera);\\n    this.topDownControls.enabled = false;\\n\\n    this.editorCamera = new THREE.PerspectiveCamera(45, domElement.clientWidth / domElement.clientHeight, 1, 10000);\\n    this.editorCamera.position.set(0, 50, 0);\\n    this.editorCamera.lookAt(0, 0, 0);\\n    this.editorCameraControls = new TopDownCameraControls(domElement, this.editorCamera);\\n    this.editorCameraControls.enabled = false;\\n    this.editorCameraControls.enablePanning = true;\\n\\n    this.cameraButtons = {};\\n\\n    ['free', 'chase', 'topDown'].forEach(c => {\\n      const cameraButton = document.getElementById(`camera-${c}`);\\n      cameraButton.addEventListener('click', () => this.changeCamera(c));\\n      this.cameraButtons[c] = cameraButton;\\n    });\\n  }\\n\\n  _resetFreeCamera() {\\n    this.freeCameraControls.position0.copy(this.chaseCamera.position);\\n    const carPosition = this.car.position;\\n    this.freeCameraControls.target0.set(carPosition.x, 0, carPosition.y);\\n    this.freeCameraControls.reset();\\n  }\\n\\n  _resetChaseCamera() {\\n    const pos = this.car.position;\\n    const dirVector = THREE.Vector2.fromAngle(this.car.rotation).multiplyScalar(-20);\\n    this.chaseCamera.position.set(pos.x + dirVector.x, 10, pos.y + dirVector.y);\\n    this.chaseCamera.lookAt(pos.x, 0, pos.y);\\n  }\\n\\n  _resetTopDownCamera() {\\n    this.topDownCamera.position.setY(50);\\n  }\\n\\n  _updateCameraAspects(aspect) {\\n    this.freeCamera.aspect = aspect;\\n    this.freeCamera.updateProjectionMatrix();\\n    this.chaseCamera.aspect = aspect;\\n    this.chaseCamera.updateProjectionMatrix();\\n  }\\n\\n  enableEditor() {\\n    this.editor.enabled = true;\\n    this.previousCamera = this.camera;\\n    this.camera = this.editorCamera;\\n    this.editorCameraControls.enabled = true;\\n    this.chaseCameraControls.enabled = false;\\n    this.topDownControls.enabled = false;\\n    this.freeCameraControls.enabled = false;\\n\\n    this.scene.fog = null;\\n    if (this.plannedPathGroup) this.plannedPathGroup.visible = false;\\n\\n    this.simModeBoxes.forEach(el => el.classList.add('is-hidden'));\\n    this.editModeBoxes.forEach(el => el.classList.remove('is-hidden'));\\n  }\\n\\n  finalizeEditor(replaceCamera = true) {\\n    this.editor.enabled = false;\\n    this.editorCameraControls.enabled = false;\\n\\n    this.scene.fog = this.sceneFog;\\n\\n    this.simModeBoxes.forEach(el => el.classList.remove('is-hidden'));\\n    this.editModeBoxes.forEach(el => el.classList.add('is-hidden'));\\n\\n    const centerline = this.editor.lanePath.centerline;\\n    const pos = centerline[0].clone();\\n    const dir = centerline[1].clone().sub(centerline[0]);\\n    const rot = Math.atan2(dir.y, dir.x);\\n    this.car.setPose(pos.x, pos.y, rot);\\n\\n    this.autonomousCarController = null;\\n\\n    if (!this.plannerRunning) {\\n      this.plannerReady = true;\\n      this.plannerRunning = true;\\n    }\\n    this.plannerReset = true;\\n    this.simulatedTime = 0;\\n\\n    if (replaceCamera) {\\n      this.camera = this.previousCamera;\\n\\n      if (this.previousCamera == this.chaseCamera)\\n        this.chaseCameraControls.enabled = true;\\n      else if (this.previousCamera == this.topDownCamera)\\n        this.topDownControls.enabled = true;\\n      else if (this.previousCamera == this.freeCamera)\\n        this.freeCameraControls.enabled = true;\\n      else\\n        this.changeCamera('chase');\\n    }\\n\\n    this._resetFreeCamera();\\n    this._resetChaseCamera();\\n    this._resetTopDownCamera();\\n  }\\n\\n  restartScenario() {\\n    if (this.editor.enabled) return;\\n    this.finalizeEditor(false);\\n  }\\n\\n  enableManualMode() {\\n    this.manualModeButton.classList.remove('is-outlined');\\n    this.manualModeButton.classList.add('is-selected');\\n    this.autonomousModeButton.classList.add('is-outlined');\\n    this.autonomousModeButton.classList.remove('is-selected');\\n\\n    this.carControllerMode = 'manual';\\n  }\\n\\n  enableAutonomousMode() {\\n    this.autonomousModeButton.classList.remove('is-outlined');\\n    this.autonomousModeButton.classList.add('is-selected');\\n    this.manualModeButton.classList.add('is-outlined');\\n    this.manualModeButton.classList.remove('is-selected');\\n\\n    this.carControllerMode = 'autonomous';\\n  }\\n\\n  changeCamera(mode) {\\n    if (this.editor.enabled) return;\\n\\n    switch (mode) {\\n      case \\\"free\\\":\\n        this.chaseCameraControls.enabled = false;\\n        this.topDownControls.enabled = false;\\n        this.freeCameraControls.enabled = true;\\n\\n        if (this.camera == this.freeCamera)\\n          this._resetFreeCamera();\\n        else\\n          this.camera = this.freeCamera;\\n\\n        break;\\n      case \\\"chase\\\":\\n        this.freeCameraControls.enabled = false;\\n        this.topDownControls.enabled = false;\\n        this.chaseCameraControls.enabled = true;\\n\\n        if (this.camera == this.chaseCamera)\\n          this._resetChaseCamera();\\n        else\\n          this.camera = this.chaseCamera;\\n\\n        break;\\n      case \\\"topDown\\\":\\n        this.freeCameraControls.enabled = false;\\n        this.chaseCameraControls.enabled = false;\\n        this.topDownControls.enabled = true;\\n\\n        if (this.camera == this.topDownCamera)\\n          this._resetTopDownCamera();\\n        else\\n          this.camera = this.topDownCamera;\\n\\n        break;\\n      default:\\n        console.log(`Unknown camera mode: ${mode}`);\\n        return;\\n    }\\n\\n    for (const c in this.cameraButtons) {\\n      const classes = this.cameraButtons[c].classList;\\n      if (c == mode) {\\n        classes.remove('is-outlined');\\n        classes.add('is-selected');\\n      } else {\\n        classes.add('is-outlined');\\n        classes.remove('is-selected');\\n      }\\n    }\\n  }\\n\\n  startPlanner(pose, station) {\\n    this.plannerReady = false;\\n    this.lastPlanTime = performance.now();\\n\\n    // In order to create a stable trajectory between successive planning\\n    // cycles, we must compensate for the latency between when a planning cycle\\n    // starts and when it ends. The average planning time is used to forward\\n    // simulate the vehicle to the pose it is expected to have when the\\n    // planning actually finishes.\\n\\n    let predictedPose = pose;\\n\\n    if (!this.plannerReset && this.autonomousCarController && this.carControllerMode == 'autonomous') {\\n      predictedPose = this.autonomousCarController.predictPoseAfterTime(pose, this.averagePlanTime.average * this.fps * FRAME_TIMESTEP);\\n    }\\n\\n    const reset = this.plannerReset;\\n    this.plannerReset = false;\\n\\n    this.lastPlanParams =  {\\n      config: this.pathPlannerConfigEditor.config,\\n      vehiclePose: predictedPose,\\n      vehicleStation: station,\\n      lanePath: this.editor.lanePath,\\n      obstacles: this.obstacles,\\n      reset: reset\\n    };\\n\\n    this.pathPlannerWorker.postMessage(this.lastPlanParams);\\n  }\\n\\n  receivePlannedPath(event) {\\n    if (this.editor.enabled) return;\\n\\n    const { fromVehicleSegment, fromVehicleParams, vehiclePose, vehicleStation, latticeStartStation } = event.data;\\n    let { path } = event.data;\\n\\n    this.averagePlanTime.addSample((performance.now() - this.lastPlanTime) / 1000);\\n    this.plannerReady = true;\\n\\n    if (path === null || this.plannerReset) return;\\n\\n    path = fromVehicleSegment.concat(path);\\n\\n    path.forEach(p => Object.setPrototypeOf(p.pos, THREE.Vector2.prototype));\\n    const followPath = new Path(path);\\n\\n    if (this.autonomousCarController)\\n      this.autonomousCarController.replacePath(followPath);\\n    else\\n      this.autonomousCarController = new FollowController(followPath, this.car);\\n\\n    this.scene.remove(this.plannedPathGroup);\\n    this.plannedPathGroup = new THREE.Group();\\n    this.scene.add(this.plannedPathGroup);\\n\\n    const circleGeom = new THREE.CircleGeometry(0.15, 32);\\n    const circleMat = new THREE.MeshBasicMaterial({ color: 0x00ff80, depthTest: false, transparent: true, opacity: 0.7 });\\n\\n    const lattice = new RoadLattice(this.editor.lanePath, latticeStartStation);\\n    lattice.lattice.forEach(cells => {\\n      cells.forEach(c => {\\n        const circle = new THREE.Mesh(circleGeom, circleMat);\\n        circle.position.set(c.pos.x, 0, c.pos.y);\\n        circle.rotation.x = -Math.PI / 2;\\n        this.plannedPathGroup.add(circle);\\n      });\\n    });\\n\\n    const pathGeometry = new THREE.Geometry();\\n    pathGeometry.setFromPoints(path.map(p => new THREE.Vector3(p.pos.x, 0, p.pos.y)));\\n    const pathLine = new MeshLine();\\n    pathLine.setGeometry(pathGeometry);\\n\\n    const pathObject = new THREE.Mesh(pathLine.geometry, new MeshLineMaterial({ color: new THREE.Color(0xff40ff), lineWidth: 0.15, depthTest: false, transparent: true, opacity: 0.5, resolution: new THREE.Vector2(this.renderer.domElement.clientWidth, this.renderer.domElement.clientHeight) }));\\n    pathObject.renderOrder = 1;\\n    this.plannedPathGroup.add(pathObject);\\n\\n    const frontMaterial = new THREE.LineBasicMaterial({ color: 0x00ff00, depthTest: false });\\n    const frontGeometry = new THREE.Geometry();\\n    frontGeometry.vertices.push(...followPath.poses.map(p => new THREE.Vector3(p.frontPos.x, 0, p.frontPos.y)));\\n    this.plannedPathGroup.add(new THREE.Line(frontGeometry, frontMaterial));\\n  }\\n}\\n\\nfunction step(timestamp) {\\n  if (this.prevTimestamp == null) {\\n    this.prevTimestamp = timestamp;\\n    requestAnimationFrame(step.bind(this));\\n    return;\\n  }\\n\\n  if (!this.editor.enabled || this.paused) {\\n    //const dt = Math.min((timestamp - this.prevTimestamp) / 1000, 1 / 30);\\n    const dt = FRAME_TIMESTEP;\\n    this.simulatedTime += dt;\\n\\n    const prevCarPosition = this.car.position;\\n    const prevCarRotation = this.car.rotation;\\n\\n    const autonomousControls = this.autonomousCarController ? this.autonomousCarController.control(this.car.pose, this.car.wheelAngle, this.car.velocity, dt, this.carControllerMode == 'autonomous') : { steer: 0, brake: 1, gas: 0 };\\n    const manualControls = this.manualCarController.control(this.car.pose, this.car.wheelAngle, this.car.velocity, dt);\\n\\n    const controls = this.carControllerMode == 'autonomous' ? autonomousControls : manualControls;\\n\\n    this.car.update(controls, dt);\\n    this.physics.step(dt);\\n\\n    const carPosition = this.car.position;\\n    const carRotation = this.car.rotation;\\n    const carRearAxle = this.car.rearAxlePosition;\\n    const carVelocity = this.car.velocity;\\n\\n    const positionOffset = { x: carPosition.x - prevCarPosition.x, y: 0, z: carPosition.y - prevCarPosition.y };\\n    this.chaseCamera.position.add(positionOffset);\\n    this.chaseCameraControls.target.set(carPosition.x, 0, carPosition.y);\\n    this.chaseCameraControls.rotateLeft(carRotation - prevCarRotation);\\n    this.chaseCameraControls.update();\\n\\n    this.topDownCamera.position.setX(carPosition.x);\\n    this.topDownCamera.position.setZ(carPosition.y);\\n    this.topDownCamera.rotation.z = -carRotation - Math.PI / 2\\n\\n    let station = null;\\n    let latitude = null;\\n\\n    if (this.editor.lanePath.anchors.length > 1) {\\n      const [s, l, aroundAnchorIndex] = this.editor.lanePath.stationLatitudeFromPosition(carRearAxle, this.aroundAnchorIndex);\\n      this.aroundAnchorIndex = aroundAnchorIndex;\\n\\n      station = s;\\n      latitude = l;\\n    }\\n\\n    if (this.plannerReady)\\n      this.startPlanner(this.car.pose, station);\\n\\n    this.dashboard.update(controls, carVelocity, station, latitude, this.simulatedTime, this.averagePlanTime.average);\\n  }\\n\\n  this.frameCounter++;\\n  this.fpsTime += timestamp - this.prevTimestamp;\\n  if (this.fpsTime >= 1000) {\\n    this.fps = this.frameCounter / (this.fpsTime / 1000);\\n    this.frameCounter = 0;\\n    this.fpsTime = 0;\\n    this.fpsBox.innerHTML = this.fps.toFixed(1);\\n  }\\n\\n  this.renderer.render(this.scene, this.camera);\\n\\n  this.prevTimestamp = timestamp;\\n\\n  requestAnimationFrame(step.bind(this));\\n}\\n\",\"import Simulator from \\\"./Simulator.js\\\";\\n\\ndocument.addEventListener('DOMContentLoaded', e => {\\n  //const geolocation = [36.037351, -86.786561];\\n  const geolocation = [33.523900, -111.908756];\\n\\n  window.simulator = new Simulator(geolocation, document.getElementById('container'));\\n});\\n\"]}","code":"!function(t){var e={};function n(i){if(e[i])return e[i].exports;var a=e[i]={i:i,l:!1,exports:{}};return t[i].call(a.exports,a,a.exports,n),a.l=!0,a.exports}n.m=t,n.c=e,n.d=function(t,e,i){n.o(t,e)||Object.defineProperty(t,e,{configurable:!1,enumerable:!0,get:i})},n.r=function(t){Object.defineProperty(t,\"__esModule\",{value:!0})},n.n=function(t){var e=t&&t.__esModule?function(){return t.default}:function(){return t};return n.d(e,\"a\",e),e},n.o=function(t,e){return Object.prototype.hasOwnProperty.call(t,e)},n.p=\"\",n(n.s=8)}([function(t,e,n){\"use strict\";var i=n(3);e.a=i.a},function(t,e,n){\"use strict\";n.d(e,\"a\",function(){return c});const i=8,a=16,s=32,o=.01,r=new THREE.Matrix3,l=new THREE.Matrix3;class c{constructor(t,e,n=null){this.start=Object.assign({},t),this.end=Object.assign({},e),t.pos&&(this.start.x=t.pos.x,this.start.y=t.pos.y),e.pos&&(this.end.x=e.pos.x,this.end.y=e.pos.y);const i=this.end.x-this.start.x,a=this.end.y-this.start.y,s=Math.sin(this.start.rot),o=Math.cos(this.start.rot);this.goal={x:o*i+s*a,y:-s*i+o*a,rot:Math.wrapAngle(this.end.rot-this.start.rot),curv:this.end.curv},n?this.params=Object.assign({},n,{p0:this.start.curv,p3:this.end.curv}):this.guessInitialParams(),this.converged=!1}guessInitialParams(){const t=this.goal,e=this.start.curv/s,n=t.y/s,i=t.rot/s,a=t.curv/s;this.goal={x:t.x,y:0,rot:0,curv:0},this.params={p0:0,p1:0,p2:0,p3:0,sG:t.x};for(let t=0;t<s;t++)this.params.p0+=e,this.params.p3+=a,this.goal.y+=n,this.goal.rot+=i,this.goal.curv+=a,this.iterate();this.goal=t}optimize(){for(let t=0;t<a;t++)if(this.iterate())return this.converged=!0,!0;return this.converged=!1,!1}iterate(){const{p0:t,p1:e,p2:n,p3:a,sG:s}=this.params,c=s/i,h=s*s,d=h*s;let u,p,m,f,g,y,v=0,E=0,x=0,T=0,S=0,P=0,C=0,b=0;for(let o=0,r=0;o<=i;o++,r+=c){const l=0==o||o==i?1:o%2==0?2:4;u=(((-4.5*(t-3*e+3*n-a)/d*r/4+(9*t-22.5*e+18*n-4.5*a)/h/3)*r+(-5.5*t+9*e-4.5*n+a)/s/2)*r+t)*r,p=Math.cos(u);const c=r/s;v-=l*(m=Math.sin(u))*(f=((3.375*c-7.5)*c+4.5)*c*r),E-=l*m*(g=((-3.375*c+6)*c-2.25)*c*r),x-=l*m*(y=((3.375*(t-3*e+3*n-a)*c-3*(2*t-5*e+4*n-a))*c+.25*(11*t-18*e+9*n-2*a))*c*c),T+=l*p*f,S+=l*p*g,P+=l*p*y,C+=l*p,b+=l*m}const _=s/i/3,w=this.goal.x-C*_,R=this.goal.y-b*_,A=Math.wrapAngle(this.goal.rot-u);if(Math.abs(w)+Math.abs(R)+Math.abs(A)<o)return!0;r.set(v*_,E*_,p+x*_,T*_,S*_,m+P*_,f,g,y);const[L,I,M,G,O,H,D,F,V]=l.getInverse(r).elements;return this.params.p1+=L*w+G*R+D*A,this.params.p2+=I*w+O*R+F*A,this.params.sG+=M*w+H*R+V*A,!1}buildPath(t){const{p0:e,p1:n,p2:i,p3:a,sG:s}=this.params,o=s*s,r=e,l=(-5.5*e+9*n-4.5*i+a)/s,c=(9*e-22.5*n+18*i-4.5*a)/o,h=-4.5*(e-3*n+3*i-a)/(o*s),d=[{pos:new THREE.Vector2(this.start.x,this.start.y),rot:this.start.rot,curv:this.start.curv}],u=s/(t-1);let p=u,m=0,f=0,g=Math.cos(d[0].rot),y=Math.sin(d[0].rot);for(let e=1;e<t-1;e++){const t=(((h*p/4+c/3)*p+l/2)*p+r)*p+this.start.rot,n=((h*p+c)*p+l)*p+r,i=Math.cos(t),a=Math.sin(t);m=m*(e-1)/e+(i+g)/(2*e),f=f*(e-1)/e+(a+y)/(2*e),d.push({pos:new THREE.Vector2(p*m+this.start.x,p*f+this.start.y),rot:t,curv:n}),p+=u,g=i,y=a}return d.push({pos:new THREE.Vector2(this.end.x,this.end.y),rot:this.end.rot,curv:this.end.curv}),d}}},function(t,e,n){\"use strict\";const i=\"#version 300 es\\nin vec2 position;\\nin vec2 texture;\\nout vec2 kernelPosition;\\n\\nvoid main(void) {\\n  kernelPosition = texture;\\n  gl_Position = vec4(position.xy, 0.0, 1.0);\\n}\\n\";e.a=class{static alloc(t,e){if(!Number.isInteger(e)||e<1||e>4)throw new Error(\"Data stride must be an integer between 1 and 4.\");const n=Math.pow(Math.ceil(Math.sqrt(t)),2),i=new Float32Array(n*e);return i.gpgpuSize=t,i.gpgpuStride=e,i}constructor(t,e={}){this._setUpGL(),this.outputTextures={},this.sharedTextures={},this.programs=t.map(t=>this._prepareProgram(t));for(const t in e){const{width:n,height:i,channels:a,data:s,...o}=e[t];this.sharedTextures[t]=this._createTexture(s,n,i,a,o)}}updateSharedTextures(t){this.sharedTextures={};for(const e in t){const{width:n,height:i,channels:a,data:s,...o}=t[e];this.sharedTextures[e]=this._createTexture(s,n,i,a,o)}}updateProgram(t,e){const n=\"number\"==typeof t?this.programs[t]:t;if(!n)throw new Error(`Program with index ${t} does not exist.`);if(e.inputs)throw new Error(\"The `updateProgram` function cannot be used to update inputs. Use `updateProgramInputs` instead.\");e.meta&&(n.meta=Object.assign(n.meta,e.meta)),void 0!==e.width&&void 0!==e.height&&this.updateProgramSize(n,e.width,e.height),\"object\"==typeof e.uniforms&&this.updateProgramUniforms(n,e.uniforms)}updateProgramInputs(t,e){const n=this.programs[t];if(!n)throw new Error(`Program with index ${t} does not exist.`);if(n.inputTextures.length!=e.length)throw new Error(`You must provide the same number of inputs as when the program was set up: got ${e.length} but expected ${n.inputTextures.length}.`);const i=n.inputWidth,a=n.inputHeight,s=n.config;void 0!==s.width&&void 0!==s.height||(n.inputWidth=void 0,n.inputHeight=void 0,n.inputDataSize=void 0),this._prepareProgramInputs(n,e),n.inputWidth==i&&n.inputHeight==a||(this.gl.useProgram(n.glProgram),this.gl.uniform2i(n.kernelSizeLocation,n.inputWidth,n.inputHeight),this._prepareProgramOutput(n))}updateProgramSize(t,e,n){const i=\"number\"==typeof t?this.programs[t]:t;if(!i)throw new Error(`Program with index ${t} does not exist.`);if(0!=i.inputTextures.length)throw new Error(\"Size can only be updated on programs with no inputs.\");e==i.inputWidth&&n==i.inputHeight||(i.inputWidth=e,i.inputHeight=n,i.inputDataSize=e*n,this.gl.useProgram(i.glProgram),this.gl.uniform2i(i.kernelSizeLocation,i.inputWidth,i.inputHeight),this._prepareProgramOutput(i))}updateProgramUniforms(t,e){const n=\"number\"==typeof t?this.programs[t]:t;if(this.gl.useProgram(n.glProgram),!n)throw new Error(`Program with index ${t} does not exist.`);for(const t in e){const i=e[t];let a;if(a=n.uniforms[t])this._setUniform(a.type,a.location,i);else{if(!(a=n.uniformTextures[t]))throw new Error(`The uniform ${t} does not exist in this program.`);{if(\"object\"!=typeof i||\"texture\"!=i.type)throw new Error(`Expected texture type for uniform ${t}.`);const{width:e,height:s,channels:o,data:r,...l}=a;n.uniformTextures[t].texture=this._createTexture(r,e,s,o,l)}}}}run(){const t=[];for(const e of this.programs){this.gl.useProgram(e.glProgram),this.gl.viewport(0,0,e.inputWidth,e.inputHeight),this.gl.bindFramebuffer(this.gl.FRAMEBUFFER,e.frameBuffer);for(const[t,n]of e.inputTextures.entries())this.gl.activeTexture(this.gl.TEXTURE0+t),this.gl.bindTexture(this.gl.TEXTURE_2D,n);for(const t in e.uniformTextures){const n=e.uniformTextures[t];this.gl.activeTexture(this.gl.TEXTURE0+n.index),this.gl.bindTexture(n.target,n.texture||this.sharedTextures[n.name]||this.outputTextures[n.name])}if(\"function\"==typeof e.draw)e.draw(this.gl,e);else if(this.gl.bindBuffer(this.gl.ARRAY_BUFFER,this.textureBuffer),this.gl.enableVertexAttribArray(e.textureLocation),this.gl.vertexAttribPointer(e.textureLocation,2,this.gl.FLOAT,!1,0,0),this.gl.bindBuffer(this.gl.ARRAY_BUFFER,this.positionBuffer),this.gl.enableVertexAttribArray(e.positionLocation),this.gl.vertexAttribPointer(e.positionLocation,2,this.gl.FLOAT,!1,0,0),this.gl.bindBuffer(this.gl.ELEMENT_ARRAY_BUFFER,this.indexBuffer),e.drawProxy){const t=(()=>this.gl.drawElements(this.gl.TRIANGLES,6,this.gl.UNSIGNED_SHORT,0)).bind(this);e.drawProxy(this,e,t)}else this.gl.drawElements(this.gl.TRIANGLES,6,this.gl.UNSIGNED_SHORT,0);if(e.output&&e.output.name&&!e.output.read)t.push(null);else{const n=new Float32Array(e.inputWidth*e.inputHeight*4);this.gl.readPixels(0,0,e.inputWidth,e.inputHeight,this.gl.RGBA,this.gl.FLOAT,n),t.push(n.subarray(0,4*e.inputDataSize))}}return t}_setUpGL(){let t;if(self.document)t=document.createElement(\"canvas\");else{if(!self.OffscreenCanvas)throw new Error(\"Could not create a canvas.\");t=new OffscreenCanvas(0,0)}const e={alpha:!1,antialias:!1};if(this.gl=t.getContext(\"webgl2\",e)||t.getContext(\"experimental-webgl2\",e),!this.gl)throw new Error(\"Unable to initialize WebGL2. Your browser may not support it.\");if(!this.gl.getExtension(\"EXT_color_buffer_float\"))throw new Error(\"Required WebGL extension EXT_color_buffer_float not supported.\");if(!this.gl.getExtension(\"OES_texture_float_linear\"))throw new Error(\"Required WebGL extension OES_texture_float_linear not supported.\");this.positionBuffer=this._newBuffer([-1,-1,1,-1,1,1,-1,1]),this.textureBuffer=this._newBuffer([0,0,1,0,1,1,0,1]),this.indexBuffer=this._newBuffer([1,2,0,3,0,2],Uint16Array,this.gl.ELEMENT_ARRAY_BUFFER)}_prepareProgram(t){const e={config:t};e.draw=t.draw,e.drawProxy=t.drawProxy,e.meta=Object.assign({},t.meta),t.width&&t.height&&(e.inputWidth=t.width,e.inputHeight=t.height,e.inputDataSize=t.width*t.height),e.output=t.output;const n=t.kernel;if(\"string\"!=typeof n||0==n.length)throw new Error(\"Kernel code cannot be empty.\");const a=t.inputs||[],s=t.uniforms||{};this._prepareProgramInputs(e,a);let o=\"\";for(const t in a)o+=`uniform sampler2D _input${t};\\n`;if(void 0===e.inputWidth||void 0===e.inputHeight)throw new Error(\"Unknown kernel size. You must provide either an input or the `width` and `height` parameters in the kernel config.\");e.uniformTextures={},e.uniforms={};for(const t in s){const n=s[t];if(\"number\"==typeof n)e.uniforms[t]={type:\"float\",value:n},o+=`uniform float ${t};\\n`;else if(Array.isArray(n)){if(n.length<2||n.length>4)throw new Error(\"Array uniforms can only have lengths of 2, 3, or 4 elements (corresponding to vec2, vec3, and vec4).\");const i=[\"vec2\",\"vec3\",\"vec4\"][n.length-2];e.uniforms[t]={type:i,value:n},o+=`uniform ${i} ${t};\\n`}else{const{type:i,width:a,height:s,channels:r,data:l,value:c,length:h,name:d,...u}=n;if(\"texture\"==i||\"outputTexture\"==i||\"sharedTexture\"==i){let n,i;\"3D\"==u.textureType?(n=this.gl.TEXTURE_3D,i=\"sampler3D\"):\"2DArray\"==u.textureType?(n=this.gl.TEXTURE_2D_ARRAY,i=\"sampler2DArray\"):(n=this.gl.TEXTURE_2D,i=\"sampler2D\"),e.uniformTextures[t]=\"texture\"==i?{target:n,texture:l?this._createTexture(l,a,s,r,u):null}:{target:n,texture:null,name:d||t},o+=`uniform ${i} ${t};\\n`}else e.uniforms[t]={type:i,value:c},o+=void 0!==h?`uniform ${i} ${t}[${h}];\\n`:`uniform ${i} ${t};\\n`}}const r=this.gl.createShader(this.gl.VERTEX_SHADER);if(this.gl.shaderSource(r,t.vertexShader||i),this.gl.compileShader(r),!this.gl.getShaderParameter(r,this.gl.COMPILE_STATUS))throw new Error(\"Could not build internal vertex shader (fatal).\\n\\n--- CODE DUMP ---\\n\"+i+\"\\n\\n--- ERROR LOG ---\\n\"+this.gl.getShaderInfoLog(r));const l=`\\nvoid main() {\\n  kernelOut = vec4(kernel(${[...Array(a.length).keys()].map(t=>`texture(_input${t}, kernelPosition)`).join(\", \")}));\\n}\\n    `,c=this.gl.createShader(this.gl.FRAGMENT_SHADER),h=\"#version 300 es\\nprecision highp float;\\nprecision highp int;\\nprecision highp sampler2D;\\nprecision highp sampler2DArray;\\nprecision highp sampler3D;\\nprecision highp samplerCube;\\n\\nin vec2 kernelPosition;\\nout vec4 kernelOut;\\nuniform ivec2 kernelSize;\\n\"+o+n+l;if(this.gl.shaderSource(c,h),this.gl.compileShader(c),!this.gl.getShaderParameter(c,this.gl.COMPILE_STATUS)){const t=h.split(\"\\n\");let e=\"ERROR: Could not build shader (fatal).\\n\\n------------------ KERNEL CODE DUMP ------------------\\n\";for(let n=0;n<t.length;n++)e+=`${n+1}> ${t[n]}\\n`;throw e+=\"\\n--------------------- ERROR  LOG ---------------------\\n\"+this.gl.getShaderInfoLog(c),new Error(e)}if(e.glProgram=this.gl.createProgram(),this.gl.attachShader(e.glProgram,r),this.gl.attachShader(e.glProgram,c),this.gl.linkProgram(e.glProgram),this.gl.useProgram(e.glProgram),!this.gl.getProgramParameter(e.glProgram,this.gl.LINK_STATUS))throw new Error(\"Failed to link GLSL program code.\");let d=0;for(const t of e.inputTextures){const t=this.gl.getUniformLocation(e.glProgram,`_input${d}`);this.gl.uniform1i(t,d),d++}for(const t in e.uniformTextures){e.uniformTextures[t].index=d;const n=this.gl.getUniformLocation(e.glProgram,t);this.gl.uniform1i(n,d),d++}for(const t in e.uniforms){const{type:n,value:i}=e.uniforms[t],a=e.uniforms[t].location=this.gl.getUniformLocation(e.glProgram,t);void 0!==i&&this._setUniform(n,a,i),delete e.uniforms[t].value}return e.kernelSizeLocation=this.gl.getUniformLocation(e.glProgram,\"kernelSize\"),this.gl.uniform2i(e.kernelSizeLocation,e.inputWidth,e.inputHeight),e.positionLocation=this.gl.getAttribLocation(e.glProgram,\"position\"),e.textureLocation=this.gl.getAttribLocation(e.glProgram,\"texture\"),e.frameBuffer=this.gl.createFramebuffer(),this._prepareProgramOutput(e),e}_prepareProgramInputs(t,e){t.inputTextures=[];for(const[n,i]of e.entries()){if(void 0===i.gpgpuSize||void 0===i.gpgpuStride)throw new Error(\"GPGPU inputs must be created by the `alloc` function.\");const e=Math.sqrt(i.length/i.gpgpuStride);if(e<=0||e%1!=0)throw new Error(\"GPGPU input size is expected to be a perfect square.\");if(void 0===t.inputWidth||void 0===t.inputHeight)t.inputWidth=e,t.inputHeight=e,t.inputDataSize=i.gpgpuSize;else if(e!=t.inputWidth||e!=t.inputHeight)throw new Error(`All GPGPU inputs must be of the same size. Received ${i.gpgpuSize} (internal ${e*e}) but expected ${t.inputDataSize} (internal ${t.inputWidth*t.inputHeight}).`);t.inputTextures.push(this._createTexture(i,e,e,i.gpgpuStride))}}_prepareProgramOutput(t){this.gl.bindFramebuffer(this.gl.FRAMEBUFFER,t.frameBuffer);const e=this._createTexture(null,t.inputWidth,t.inputHeight,4,t.output);if(this.gl.framebufferTexture2D(this.gl.FRAMEBUFFER,this.gl.COLOR_ATTACHMENT0,this.gl.TEXTURE_2D,e,0),!(this.gl.checkFramebufferStatus(this.gl.FRAMEBUFFER)==this.gl.FRAMEBUFFER_COMPLETE))throw new Error(\"Error attaching float texture to framebuffer. Your device is probably incompatible.\");t.output&&t.output.name&&(this.outputTextures[t.output.name]=e)}_setUniform(t,e,n){switch(t){case\"int\":this.gl.uniform1i(e,n);break;case\"float\":Array.isArray(n)?this.gl.uniform1fv(e,n):this.gl.uniform1f(e,n);break;case\"vec2\":this.gl.uniform2fv(e,n);break;case\"vec3\":this.gl.uniform3fv(e,n);break;case\"vec4\":this.gl.uniform4fv(e,n);break;case\"mat3\":this.gl.uniformMatrix3fv(e,n);break;default:throw new Error(`Unknown uniform type ${t}.`)}}_newBuffer(t,e,n){const i=this.gl.createBuffer();return this.gl.bindBuffer(n||this.gl.ARRAY_BUFFER,i),this.gl.bufferData(n||this.gl.ARRAY_BUFFER,new(e||Float32Array)(t),this.gl.STATIC_DRAW),i}_createTexture(t,e,n,i,a={}){const s=this.gl.createTexture();let o,r;switch(i){case 1:o=this.gl.R32F,r=this.gl.RED;break;case 2:o=this.gl.RG32F,r=this.gl.RG;break;case 3:o=this.gl.RGB32F,r=this.gl.RGB;break;case 4:o=this.gl.RGBA32F,r=this.gl.RGBA;break;default:throw\"Texture channels must between 1 and 4.\"}const l=\"3D\"==a.textureType?this.gl.TEXTURE_3D:\"2DArray\"==a.textureType?this.gl.TEXTURE_2D_ARRAY:this.gl.TEXTURE_2D;return this.gl.bindTexture(l,s),this.gl.texParameteri(l,this.gl.TEXTURE_WRAP_S,this.gl.CLAMP_TO_EDGE),this.gl.texParameteri(l,this.gl.TEXTURE_WRAP_T,this.gl.CLAMP_TO_EDGE),this.gl.texParameteri(l,this.gl.TEXTURE_MIN_FILTER,\"linear\"==a.filter?this.gl.LINEAR:this.gl.NEAREST),this.gl.texParameteri(l,this.gl.TEXTURE_MAG_FILTER,\"linear\"==a.filter?this.gl.LINEAR:this.gl.NEAREST),\"3D\"==a.textureType||\"2DArray\"==a.textureType?this.gl.texImage3D(l,0,o,e,n,a.depth,0,r,this.gl.FLOAT,t):this.gl.texImage2D(l,0,o,e,n,0,r,this.gl.FLOAT,t),this.gl.bindTexture(l,null),s}}},function(t,e,n){\"use strict\";n.d(e,\"a\",function(){return i});class i{constructor(t=0,e=0,n=0){this.setPose(t,e,n)}static getFrontAxlePosition(t,e){return THREE.Vector2.fromAngle(e).multiplyScalar(i.WHEEL_BASE).add(t)}static getFakeAxlePosition(t,e){return i.frontToRearAxlePosition(t,e)}static centerToRearAxlePosition(t,e){return THREE.Vector2.fromAngle(e).multiplyScalar(i.REAR_AXLE_POS).add(t)}static frontToRearAxlePosition(t,e){return THREE.Vector2.fromAngle(e).multiplyScalar(-i.WHEEL_BASE).add(t)}get pose(){return{pos:this.rearAxlePosition,rot:this.rotation,velocity:this.velocity,curv:this.curvature,dCurv:0,ddCurv:0}}get curvature(){return Math.tan(this.wheelAngle)/i.WHEEL_BASE}get rearAxlePosition(){const{x:t,y:e}=this.position,n=this.rotation;return new THREE.Vector2(t+Math.cos(n)*i.REAR_AXLE_POS,e+Math.sin(n)*i.REAR_AXLE_POS)}get frontAxlePosition(){const{x:t,y:e}=this.position,n=this.rotation;return new THREE.Vector2(t+Math.cos(n)*i.FRONT_AXLE_POS,e+Math.sin(n)*i.FRONT_AXLE_POS)}setPose(t,e,n){t-=i.REAR_AXLE_POS*Math.cos(n),e-=i.REAR_AXLE_POS*Math.sin(n),this.position=new THREE.Vector2(t,e),this.rotation=Math.wrapAngle(n),this.velocity=0,this.acceleration=0,this.wheelAngle=0,this.wheelAngularVelocity=0,this.dCurv=0,this.ddCurv=0}step(t){const e=this.curvature,n=this.dCurv,a=(.5*i.DRAG_COEFF*i.FRONTAL_AREA*i.DENSITY_OF_AIR*Math.abs(this.velocity)+i.ROLL_RESIST)*-this.velocity;this.velocity+=(this.acceleration+a/i.MASS)*t;const s=this.velocity*this.velocity,o=Math.clamp(Math.atan(i.MAX_LATERAL_ACCEL*i.WHEEL_BASE/s),.07,i.MAX_WHEEL_ANGLE);this.wheelAngle=Math.clamp(Math.wrapAngle(this.wheelAngle+this.wheelAngularVelocity*t),-o,o);const r=this.velocity*this.curvature;this.rotation=Math.wrapAngle(this.rotation+r*t);const l=this.velocity*t;this.position=THREE.Vector2.fromAngle(this.rotation).multiplyScalar(l).add(this.position),this.dCurv=(this.curvature-e)/l,this.ddCurv=(this.dCurv-n)/l}update(t,e){const n=Math.clamp(t.gas,-1,1),a=Math.clamp(t.brake,0,1),s=Math.clamp(t.steer,-1,1);if(a>0){this.acceleration=-Math.sign(this.velocity)*i.MAX_BRAKE_DECEL*a;const t=this.velocity+this.acceleration*e;Math.sign(t)!=Math.sign(this.velocity)&&(this.velocity=0,this.acceleration=0)}else this.acceleration=i.MAX_GAS_ACCEL*n;this.wheelAngularVelocity=0!=s?s*i.MAX_STEER_SPEED:Math.clamp(-this.wheelAngle/i.MAX_WHEEL_ANGLE*this.velocity*this.velocity*e,-i.MAX_STEER_SPEED,i.MAX_STEER_SPEED)}}i.HALF_CAR_LENGTH=2.5,i.HALF_CAR_WIDTH=1,i.HALF_WHEEL_LENGTH=.33,i.HALF_WHEEL_WIDTH=.12,i.MAX_WHEEL_ANGLE=32/180*Math.PI,i.MASS=1600,i.DRAG_COEFF=.7,i.DENSITY_OF_AIR=1.8580608,i.FRONTAL_AREA=1.85,i.ROLL_RESIST=0,i.MAX_STEER_SPEED=.8,i.MAX_GAS_ACCEL=3.5,i.MAX_BRAKE_DECEL=6.5,i.WHEEL_LATERAL_POS=.843,i.FRONT_AXLE_POS=1.56,i.REAR_AXLE_POS=-1.37,i.WHEEL_BASE=i.FRONT_AXLE_POS-i.REAR_AXLE_POS,i.MAX_LATERAL_ACCEL=9.81},function(t,e,n){\"use strict\";new THREE.Geometry,new THREE.Geometry,new THREE.Geometry;function i(t,e,n,i,a){const s=.5*(i-e),o=.5*(a-n),r=t*t;return(2*n-2*i+s+o)*(t*r)+(-3*n+3*i-2*s-o)*r+s*t+n}function a(t,e,n,a,s){return new THREE.Vector2(i(t,e.x,n.x,a.x,s.x),i(t,e.y,n.y,a.y,s.y))}function s(t,e,n,i,s){let o=t-1e-4,r=t+1e-4;o<0&&(o=0),r>1&&(r=1);const l=a(o,e,n,i,s);return a(r,e,n,i,s).sub(l).normalize()}function o(t,e,n,i,s){0==t&&(t=1e-4),1==t&&(t=.9999);let o=t-1e-4,r=t+1e-4;o<0&&(o=0),r>1&&(r=1);const l=a(o,e,n,i,s),c=a(t,e,n,i,s),h=a(r,e,n,i,s);return(Math.atan2(h.y-c.y,h.x-c.x)-Math.atan2(c.y-l.y,c.x-l.x))/c.distanceTo(l)}e.a=class{constructor(){this.anchors=[],this.centerlines=[],this.sampleLengths=[],this.arcLengths=[],this.rotations=[],this.leftBoundaries=[],this.rightBoundaries=[]}get centerline(){return[].concat(...this.centerlines)}get centerlineRotations(){return[].concat(...this.rotations)}get centerlineLengths(){return[].concat(...this.arclengths)}get leftBoundary(){return[].concat(...this.leftBoundaries)}get rightBoundary(){return[].concat(...this.rightBoundaries)}sampleStations(t,e,n){const i=[];let r=0,l=0,c=0,h=t;for(;c+this.arcLengths[r]<h;)if(c+=this.arcLengths[r],++r>=this.arcLengths.length)throw new Error(`Exhausted lane path before reaching ${e} centerline samples at ${n}m intervals.`);for(let t=0;t<e;t++){let t=this.sampleLengths[r][l];for(;c+t<h;){if(c+=t,++l>=this.sampleLengths[r].length&&(l=0,++r>=this.sampleLengths.length))throw new Error(`Exhausted lane path before reaching ${e} centerline samples at ${n}m intervals.`);t=this.sampleLengths[r][l]}const[d,u,p,m]=this.anchorsForSplineIndex(r),f=(l+(h-c)/t)/this.sampleLengths[r].length,g=a(f,d,u,p,m),y=s(f,d,u,p,m),v=Math.atan2(y.y,y.x),E=o(f,d,u,p,m);i.push({pos:g,rot:v,curv:E}),h+=n}return i}stationLatitudeFromPosition(t,e=null){const[n,i,a,s]=this._findClosestSample(t,e);let o,r,l,c;if(0==n&&0==i)o=this.centerlines[n][i],r=this.centerlines[n][i+1],l=0,c=this.sampleLengths[n][i];else if(n==this.centerlines.length-1&&i==this.centerlines[n].length-1)o=this.centerlines[n][i-1],r=this.centerlines[n][i],l=s,c=a;else{o=0==i?this.centerlines[n-1][this.centerlines[n-1].length-1]:this.centerlines[n][i-1],r=i==this.centerlines[n].length-1?this.centerlines[n+1][0]:this.centerlines[n][i+1];const e=this.centerlines[n][i];t.clone().sub(o).dot(e.clone().sub(o))/o.distanceToSquared(e)<1?(r=e,l=s,c=a):(o=e,l=a,c=a+this.sampleLengths[n][i])}const h=Math.clamp(t.clone().sub(o).dot(r.clone().sub(o))/o.distanceToSquared(r),0,1),d=r.clone().sub(o).multiplyScalar(h).add(o);return[l+(c-l)*h,Math.sign((r.x-o.x)*(t.y-o.y)-(r.y-o.y)*(t.x-o.x))*t.distanceTo(d),n]}_findClosestSample(t,e=null){let n,i,a,s,o=Number.POSITIVE_INFINITY,r=0,l=0,c=0,h=this.centerlines.length-1;if(null!==e&&(c=Math.max(0,e-1),h=Math.min(this.centerlines.length-1,e+1)),c>0){for(let t=0;t<c;t++)r+=this.arcLengths[t];l=r-this.sampleLengths[c-1][this.sampleLengths[c-1].length-1]}for(let e=c;e<=h;e++){const c=this.centerlines[e];for(let h=0;h<c.length;h++){const d=t.distanceToSquared(c[h]);d<o&&(o=d,n=e,i=h,a=r,s=l),l=r,r+=this.sampleLengths[e][h]}}return[n,i,a,s]}addAnchor(t){const e=this.anchors.push(t)-1;for(let t=e-2;t<e;t++)this.resample(t)}updateAnchor(t,e){this.anchors[t]=e;for(let e=t-2;e<=t+1;e++)this.resample(e)}resample(t){if(t<0||t>this.anchors.length-2)return;const[e,n,i,o]=this.anchorsForSplineIndex(t),r=[],l=[],c=[],h=[],d=[];let u=null;const p=Math.ceil(n.distanceTo(i)/1),m=t==this.anchors.length-2?p+1:p;for(let t=0;t<m;t++){const m=t/p,f=a(m,e,n,i,o);r.push(f),null!=u&&l.push(u.distanceTo(f)),u=f;const g=s(m,e,n,i,o);c.push(Math.atan2(g.y,g.x));const y=new THREE.Vector2(-g.y,g.x);h.push(y.clone().multiplyScalar(-1.85).add(f)),d.push(y.clone().multiplyScalar(1.85).add(f))}l.push(u.distanceTo(i)),this.centerlines[t]=r,this.sampleLengths[t]=l,this.rotations[t]=c,this.leftBoundaries[t]=h,this.rightBoundaries[t]=d,this.arcLengths[t]=l.reduce((t,e)=>t+e)}anchorsForSplineIndex(t){let e;return void 0===(e=0==t?[this.anchors[0]].concat(this.anchors.slice(0,3)):this.anchors.slice(t-1,t+3))[3]&&(e[3]=e[2]),e}}},function(t,e,n){\"use strict\";e.a=class{constructor(t,e,n,i){this.pos=t,this.rot=e,this.width=n,this.height=i,this.updateVertices()}updateVertices(){this.vertices=[];const t=Math.cos(this.rot),e=Math.sin(this.rot),n=this.width/2,i=this.height/2,a=n*t,s=n*e,o=i*t,r=i*e,l=[-a-r+this.pos.x,-s+o+this.pos.y],c=[-a+r+this.pos.x,-s-o+this.pos.y],h=[a+r+this.pos.x,s-o+this.pos.y],d=[a-r+this.pos.x,s+o+this.pos.y];this.vertices=[l[0],l[1],c[0],c[1],h[0],h[1],h[0],h[1],d[0],d[1],l[0],l[1]]}}},function(t,e,n){\"use strict\";var i=n(2),a=(n(0),n(1));class s{constructor(t,e,n){this.start=Object.assign({},t),this.end=Object.assign({},e),t.pos&&(this.start.x=t.pos.x,this.start.y=t.pos.y),e.pos&&(this.end.x=e.pos.x,this.end.y=e.pos.y);const i=this.end.x-this.start.x,a=this.end.y-this.start.y,s=Math.sin(this.start.rot),o=Math.cos(this.start.rot);this.goal={x:o*i+s*a,y:-s*i+o*a,rot:Math.wrapAngle(this.end.rot-this.start.rot),curv:this.end.curv},this.params=Object.assign({},n,{p0:this.start.curv,p1:this.start.dCurv||0,p2:this.start.ddCurv||0,p5:this.end.curv})}buildPath(t){const{p0:e,p1:n,p2:i,p3:a,p4:s,p5:o,sG:r}=this.params,l=r*r,c=l*r,h=e,d=n,u=i/2,p=(-71.875*e+81*a-10.125*s+o-21.25*n*r-2.75*i*l)/c,m=(166.5*e-202.5*a+40.5*s-4.5*o+45*n*r+4.5*i*l)/(l*l),f=(-95.625*e+121.5*a-30.375*s+4.5*o-24.75*n*r-2.25*i*l)/(l*c),g=[{pos:new THREE.Vector2(this.start.x,this.start.y),rot:this.start.rot,curv:this.start.curv}],y=r/(t-1);let v=y,E=0,x=0,T=Math.cos(g[0].rot),S=Math.sin(g[0].rot);for(let e=1;e<t-1;e++){const t=(((((f*v/6+m/5)*v+p/4)*v+u/3)*v+d/2)*v+h)*v+this.start.rot,n=((((f*v+m)*v+p)*v+u)*v+d)*v+h,i=Math.cos(t),a=Math.sin(t);E=E*(e-1)/e+(i+T)/(2*e),x=x*(e-1)/e+(a+S)/(2*e),g.push({pos:new THREE.Vector2(v*E+this.start.x,v*x+this.start.y),rot:t,curv:n}),v+=y,T=i,S=a}return g.push({pos:new THREE.Vector2(this.end.x,this.end.y),rot:this.end.rot,curv:this.end.curv}),g}}let o,r;var l={setUp:()=>({kernel:\"\\n  vec4 kernel() {\\n    return vec4(1, 0, 0, 1);\\n  }\\n\",vertexShader:\"#version 300 es\\nuniform mat3 xform;\\nin vec2 position;\\n\\nvoid main(void) {\\n  gl_Position = vec4((xform * vec3(position, 1)).xy, 0, 1);\\n}\\n\",output:{name:\"xyObstacleGrid\"},draw:(t,e)=>{if(t.clearColor(0,0,0,0),t.clear(t.COLOR_BUFFER_BIT),o.length>0){t.bindBuffer(t.ARRAY_BUFFER,t.createBuffer()),t.bufferData(t.ARRAY_BUFFER,o,t.STATIC_DRAW),t.enableVertexAttribArray(e.positionLocation),t.vertexAttribPointer(e.positionLocation,2,t.FLOAT,!1,0,0);const n=t.getUniformLocation(e.glProgram,\"xform\");t.uniformMatrix3fv(n,!1,r.elements),t.drawArrays(t.TRIANGLES,0,o.length/2)}}}),update(t,e,n,i,a,s){o=new Float32Array(Array.prototype.concat.apply([],s.map(t=>t.vertices)));const l=new THREE.Matrix3;l.set(1,0,-i.x,0,1,-i.y,0,0,1);const c=new THREE.Matrix3;return c.set(2/(e*t.xyGridCellSize),0,0,0,2/(n*t.xyGridCellSize),0,0,0,1),r=c.multiply(l).multiply(a),{width:e,height:n}}};var c={setUp:()=>({kernel:\"\\n\\nvec4 kernel() {\\n  float centerlineWidth = float(textureSize(centerline, 0).x);\\n\\n  vec2 sl = (kernelPosition - 0.5) * vec2(kernelSize) * vec2(slGridCellSize) + slCenterPoint;\\n  float centerlineCoord = sl.x / centerlineStationInterval / centerlineWidth * (centerlineWidth - 1.0) / centerlineWidth + (0.5 / centerlineWidth);\\n  if (centerlineCoord < 0.0 || centerlineCoord > 1.0) return vec4(0);\\n\\n  vec3 centerlineSample = texture(centerline, vec2(centerlineCoord, 0)).xyz;\\n  float perpindicular = centerlineSample.z + radians(90.0);\\n  vec2 xy = centerlineSample.xy + sl.yy * vec2(cos(perpindicular), sin(perpindicular));\\n\\n  vec2 xyTexCoords = (xy - xyCenterPoint) / vec2(textureSize(xyObstacleGrid, 0)) / vec2(xyGridCellSize) + 0.5;\\n  return texture(xyObstacleGrid, xyTexCoords);\\n}\\n\\n\",output:{name:\"slObstacleGrid\"},uniforms:{xyObstacleGrid:{type:\"outputTexture\"},slGridCellSize:{type:\"float\"},xyGridCellSize:{type:\"float\"},slCenterPoint:{type:\"vec2\"},xyCenterPoint:{type:\"vec2\"},centerlineStationInterval:{type:\"float\"},centerline:{type:\"sharedTexture\"}}}),update:(t,e,n,i,a)=>({width:e,height:n,uniforms:{slGridCellSize:t.slGridCellSize,xyGridCellSize:t.xyGridCellSize,slCenterPoint:[i.x,i.y],xyCenterPoint:[a.x,a.y],centerlineStationInterval:t.centerlineStationInterval}})};const h=\"\\n\\n// TODO: test performance of returning early if non-zero pixel found\\nvec4 kernel() {\\n  float val = 0.0;\\n\\n  for (int d = 0; d <= lethalDilation; d++) {\\n    val = max(val, texture(slObstacleGrid, kernelPosition + delta * vec2(d)).r);\\n    val = max(val, texture(slObstacleGrid, kernelPosition + delta * vec2(-d)).r);\\n  }\\n\\n  for (int d = lethalDilation + 1; d <= lethalDilation + hazardDilation; d++) {\\n    val = max(val, texture(slObstacleGrid, kernelPosition + delta * vec2(d)).r * 0.5);\\n    val = max(val, texture(slObstacleGrid, kernelPosition + delta * vec2(-d)).r * 0.5);\\n  }\\n\\n  val = max(val, step(0.1, val) * 0.5);\\n\\n  return vec4(val, 0, 0, 1);\\n}\\n\\n\";var d={setUp:()=>[{kernel:h,output:{name:\"slObstacleGridStationDilated\"},uniforms:{slObstacleGrid:{type:\"outputTexture\"},delta:{type:\"vec2\"},lethalDilation:{type:\"int\"},hazardDilation:{type:\"int\"}}},{kernel:h,output:{name:\"slObstacleGridDilated\"},uniforms:{slObstacleGrid:{type:\"outputTexture\",name:\"slObstacleGridStationDilated\"},delta:{type:\"vec2\"},lethalDilation:{type:\"int\"},hazardDilation:{type:\"int\"}}}],update:(t,e,n)=>[{width:e,height:n,uniforms:{delta:[1/e,0],lethalDilation:Math.ceil(t.lethalDilationS/t.slGridCellSize),hazardDilation:Math.ceil(t.hazardDilationS/t.slGridCellSize)}},{width:e,height:n,uniforms:{delta:[0,1/n],lethalDilation:Math.ceil(t.lethalDilationL/t.slGridCellSize),hazardDilation:Math.ceil(t.hazardDilationL/t.slGridCellSize)}}]};var u={setUp:()=>({kernel:\"\\n\\nvec4 kernel() {\\n  vec2 xy = (kernelPosition - 0.5) * vec2(kernelSize) * vec2(xyGridCellSize) + xyCenterPoint;\\n\\n  int numSamples = textureSize(centerline, 0).x;\\n  int closest = 0;\\n  float closestDist = distance(xy, texelFetch(centerline, ivec2(0, 0), 0).xy);\\n  for (int i = 1; i < numSamples; i++) {\\n    float dist = distance(xy, texelFetch(centerline, ivec2(i, 0), 0).xy);\\n    if (dist < closestDist) {\\n      closestDist = dist;\\n      closest = i;\\n    }\\n  }\\n\\n  vec2 closestPos = texelFetch(centerline, ivec2(closest, 0), 0).xy;\\n  vec2 prev, next;\\n  int prevIndex, nextIndex;\\n\\n  if (closest == 0) {\\n    prevIndex = 0;\\n    nextIndex = 1;\\n    prev = closestPos;\\n    next = texelFetch(centerline, ivec2(1, 0), 0).xy;\\n  } else if (closest == numSamples - 1) {\\n    prevIndex = closest - 1;\\n    nextIndex = closest;\\n    prev = texelFetch(centerline, ivec2(prevIndex, 0), 0).xy;\\n    next = closestPos;\\n  } else {\\n    vec2 before = texelFetch(centerline, ivec2(closest - 1, 0), 0).xy;\\n    vec2 after = texelFetch(centerline, ivec2(closest + 1, 0), 0).xy;\\n\\n    if (distance(before, xy) < distance(after, xy)) {\\n      prevIndex = closest - 1;\\n      nextIndex = closest;\\n      prev = before;\\n      next = closestPos;\\n    } else {\\n      prevIndex = closest;\\n      nextIndex = closest + 1;\\n      prev = closestPos;\\n      next = after;\\n    }\\n  }\\n\\n  float dist = distance(prev, next);\\n  float progress = clamp(dot(xy - prev, next - prev) / dist / dist, 0.0, 1.0);\\n  vec2 projectedPos = (next - prev) * vec2(progress) + prev;\\n\\n  return vec4(\\n    (float(prevIndex) + progress) * centerlineStationInterval,\\n    sign(determinant(mat2(next - prev, xy - prev))) * distance(xy, projectedPos),\\n    0,\\n    0\\n  );\\n}\\n\\n\",output:{name:\"xyslMap\",filter:\"linear\"},uniforms:{centerline:{type:\"sharedTexture\"},xyCenterPoint:{type:\"vec2\"},xyGridCellSize:{type:\"float\"},centerlineStationInterval:{type:\"float\"}}}),update:(t,e,n,i)=>({width:e,height:n,uniforms:{xyCenterPoint:[i.x,i.y],xyGridCellSize:t.xyGridCellSize,centerlineStationInterval:t.centerlineStationInterval}})};var p={setUp:()=>[{kernel:\"\\n\\nconst int NEWTON_ITERATIONS = 16;\\nconst int RELAXATION_ITERATIONS = 16;\\nconst float CONVERGENCE_ERROR = 0.01;\\n\\n// These two consts must stay in sync.\\nconst int SIMPSONS_INTERVALS = 8;\\n//const float SIMPSONS_COEFFS[SIMPSONS_INTERVALS + 1] = float[](1.0, 4.0, 2.0, 4.0, 2.0, 4.0, 2.0, 4.0, 2.0, 4.0, 2.0, 4.0, 2.0, 4.0, 2.0, 4.0, 1.0);\\nconst float SIMPSONS_COEFFS[SIMPSONS_INTERVALS + 1] = float[](1.0, 4.0, 2.0, 4.0, 2.0, 4.0, 2.0, 4.0, 1.0);\\n\\nconst float PI = 3.1415926535897932384626433832795;\\nconst float TWO_PI = PI + PI;\\n\\nconst float RELAXATION_ITERATIONS_F = float(RELAXATION_ITERATIONS);\\nconst float SIMPSONS_INTERVALS_F = float(SIMPSONS_INTERVALS);\\n\\nfloat wrapAngle(float angle) {\\n  angle = mod(angle, TWO_PI);\\n  if (angle <= -PI) return angle + TWO_PI;\\n  else if (angle > PI) return angle - TWO_PI;\\n  return angle;\\n}\\n\\nvec4 iterate(vec4 goal, float p0, float p1, float p2, float p3, float sG) {\\n  float ds = sG / SIMPSONS_INTERVALS_F;\\n  float sG_2 = sG * sG;\\n  float sG_3 = sG_2 * sG;\\n\\n  vec3 dX_p = vec3(0.0);\\n  vec3 dY_p = vec3(0.0);\\n  vec2 guess = vec2(0.0);\\n  float s = 0.0;\\n\\n  float theta, cosTheta, sinTheta;\\n  vec3 dT_p;\\n\\n  for (int i = 0; i <= SIMPSONS_INTERVALS; i++) {\\n    float coeff = SIMPSONS_COEFFS[i];\\n\\n    float a = p0;\\n    float b = (-5.5 * p0 + 9.0 * p1 - 4.5 * p2 + p3) / sG;\\n    float c = (9.0 * p0 - 22.5 * p1 + 18.0 * p2 - 4.5 * p3) / sG_2;\\n    float d = (-4.5 * (p0 - 3.0 * p1 + 3.0 * p2 - p3)) / sG_3;\\n\\n    theta = (((d * s / 4.0 + c / 3.0) * s + b / 2.0) * s + a) * s;\\n    cosTheta = cos(theta);\\n    sinTheta = sin(theta);\\n\\n    float s_sG = s / sG;\\n\\n    dT_p = vec3(\\n      // p1\\n      ((3.375 * s_sG - 7.5) * s_sG + 4.5) * s_sG * s,\\n\\n      // p2\\n      ((-3.375 * s_sG + 6.0) * s_sG - 2.25) * s_sG * s,\\n\\n      // sG\\n      ((3.375 * (p0 - 3.0 * p1 + 3.0 * p2 - p3) * s_sG - 3.0 * (2.0 * p0 - 5.0 * p1 + 4.0 * p2 - p3)) * s_sG + 0.25 * (11.0 * p0 - 18.0 * p1 + 9.0 * p2 - 2.0 * p3)) * s_sG * s_sG\\n    );\\n\\n    dX_p -= coeff * sinTheta * dT_p;\\n    dY_p += coeff * cosTheta * dT_p;\\n\\n    guess += coeff * vec2(cosTheta, sinTheta);\\n\\n    s += ds;\\n  }\\n\\n  float hOver3 = sG / SIMPSONS_INTERVALS_F / 3.0;\\n\\n  vec3 delta;\\n  delta.xy = goal.xy - guess * hOver3;\\n  delta.z = wrapAngle(goal.z - theta);\\n\\n  if (abs(delta.x) + abs(delta.y) + abs(delta.z) < CONVERGENCE_ERROR)\\n    return vec4(p1, p2, sG, 1.0);\\n\\n  dX_p.xyz *= hOver3;\\n  dY_p.xyz *= hOver3;\\n  dX_p.z += cosTheta;\\n  dY_p.z += sinTheta;\\n\\n  mat3 invJacobian = inverse(transpose(mat3(dX_p, dY_p, dT_p)));\\n\\n  vec3 deltaP = invJacobian * delta;\\n  vec4 params = vec4(p1, p2, sG, 0.0);\\n  params.xyz += deltaP;\\n\\n  return params;\\n}\\n\\n/* Input:\\n *   start: (vec4)\\n *     x: x position,\\n *     y: y position,\\n *     z: theta rotation,\\n *     w: k curvature\\n *   end: (vec4)\\n *     x: x position,\\n *     y: y position,\\n *     z: theta rotation,\\n *     w: k curvature\\n *\\n * Output: (vec4)\\n *   x: p1,\\n *   y: p2,\\n *   z: sG,\\n *   w: 1 if converged, 0 if not\\n */\\n\\nvec4 optimize(vec4 start, vec4 end) {\\n  // Translate and rotate start and end so that start is at the origin\\n  float sinRot = sin(start.z);\\n  float cosRot = cos(start.z);\\n\\n  vec4 diff = end - start;\\n  vec4 goal;\\n  goal.xy = mat2(cosRot, -sinRot, sinRot, cosRot) * diff.xy;\\n  goal.z = wrapAngle(diff.z);\\n  goal.w = end.w;\\n\\n  vec4 originalGoal = goal;\\n  vec4 dGoal;\\n  dGoal.x = 0.0;\\n  dGoal.yzw = goal.yzw / RELAXATION_ITERATIONS_F;\\n  float dK0 = start.w / RELAXATION_ITERATIONS_F;\\n\\n  // Relax the goal to (x, 0, 0, 0)\\n  goal.yzw = vec3(0, 0, 0);\\n\\n  // Relax the params to (0, 0, 0, 0, goal.x)\\n  float p0 = 0.0;\\n  float p1 = 0.0;\\n  float p2 = 0.0;\\n  float p3 = 0.0;\\n  float sG = goal.x;\\n\\n  if (sG < 0.1) return vec4(0.0);\\n\\n  for (int i = 0; i < RELAXATION_ITERATIONS; i++) {\\n    p0 += dK0;\\n    p3 += dGoal.w;\\n    goal += dGoal;\\n    \\n    vec4 result = iterate(goal, p0, p1, p2, p3, sG);\\n    p1 = result.x;\\n    p2 = result.y;\\n    sG = result.z;\\n  }\\n\\n  goal = originalGoal;\\n\\n  for (int i = 0; i < NEWTON_ITERATIONS; i++) {\\n    vec4 result = iterate(goal, p0, p1, p2, p3, sG);\\n    if (result.w == 1.0) {\\n      result.w = step(0.0, result.z);\\n      return result;\\n    }\\n\\n    p1 = result.x;\\n    p2 = result.y;\\n    sG = result.z;\\n  }\\n\\n  return vec4(p1, p2, sG, 0.0);\\n}\\n\\n\\n\\n// width: station * latitude index\\n// height: station_conn * lattice_conn\\n//\\n// lattice:\\n// width: latitudes\\n// height: stations\\n\\nvec4 kernel() {\\n  ivec2 indexes = ivec2(kernelPosition * vec2(kernelSize));\\n\\n  int endStation = indexes.x / numLatitudes;\\n  int endLatitude = int(mod(float(indexes.x), float(numLatitudes)));\\n\\n  int startStation = endStation - stationConnectivity + indexes.y / latitudeConnectivity;\\n  int startLatitude = endLatitude - latitudeConnectivity / 2 + int(mod(float(indexes.y), float(latitudeConnectivity)));\\n\\n  if (startStation < 0 || startStation >= numStations || startLatitude < 0 || startLatitude >= numLatitudes)\\n    return vec4(0.0);\\n\\n  vec4 start = texelFetch(lattice, ivec2(startLatitude, startStation), 0);\\n  vec4 end = texelFetch(lattice, ivec2(endLatitude, endStation), 0);\\n\\n  return optimize(start, end);\\n}\\n\\n\",output:{name:\"cubicPaths\",read:!0},uniforms:{lattice:{type:\"sharedTexture\"},numStations:{type:\"int\"},numLatitudes:{type:\"int\"},stationConnectivity:{type:\"int\"},latitudeConnectivity:{type:\"int\"}}},{kernel:\"\\n\\nconst int NEWTON_ITERATIONS = 16;\\nconst int RELAXATION_ITERATIONS = 16;\\nconst float CONVERGENCE_ERROR = 0.01;\\n\\n// These two consts must stay in sync.\\nconst int SIMPSONS_INTERVALS = 8;\\n//const float SIMPSONS_COEFFS[SIMPSONS_INTERVALS + 1] = float[](1.0, 4.0, 2.0, 4.0, 2.0, 4.0, 2.0, 4.0, 2.0, 4.0, 2.0, 4.0, 2.0, 4.0, 2.0, 4.0, 1.0);\\nconst float SIMPSONS_COEFFS[SIMPSONS_INTERVALS + 1] = float[](1.0, 4.0, 2.0, 4.0, 2.0, 4.0, 2.0, 4.0, 1.0);\\n\\nconst float PI = 3.1415926535897932384626433832795;\\nconst float TWO_PI = PI + PI;\\n\\nconst float RELAXATION_ITERATIONS_F = float(RELAXATION_ITERATIONS);\\nconst float SIMPSONS_INTERVALS_F = float(SIMPSONS_INTERVALS);\\n\\nfloat wrapAngle(float angle) {\\n  angle = mod(angle, TWO_PI);\\n  if (angle <= -PI) return angle + TWO_PI;\\n  else if (angle > PI) return angle - TWO_PI;\\n  return angle;\\n}\\n\\nvec4 iterate(vec4 goal, float p0, float p1, float p2, float p3, float sG) {\\n  float ds = sG / SIMPSONS_INTERVALS_F;\\n  float sG_2 = sG * sG;\\n  float sG_3 = sG_2 * sG;\\n\\n  vec3 dX_p = vec3(0.0);\\n  vec3 dY_p = vec3(0.0);\\n  vec2 guess = vec2(0.0);\\n  float s = 0.0;\\n\\n  float theta, cosTheta, sinTheta;\\n  vec3 dT_p;\\n\\n  for (int i = 0; i <= SIMPSONS_INTERVALS; i++) {\\n    float coeff = SIMPSONS_COEFFS[i];\\n\\n    float a = p0;\\n    float b = (-5.5 * p0 + 9.0 * p1 - 4.5 * p2 + p3) / sG;\\n    float c = (9.0 * p0 - 22.5 * p1 + 18.0 * p2 - 4.5 * p3) / sG_2;\\n    float d = (-4.5 * (p0 - 3.0 * p1 + 3.0 * p2 - p3)) / sG_3;\\n\\n    theta = (((d * s / 4.0 + c / 3.0) * s + b / 2.0) * s + a) * s;\\n    cosTheta = cos(theta);\\n    sinTheta = sin(theta);\\n\\n    float s_sG = s / sG;\\n\\n    dT_p = vec3(\\n      // p1\\n      ((3.375 * s_sG - 7.5) * s_sG + 4.5) * s_sG * s,\\n\\n      // p2\\n      ((-3.375 * s_sG + 6.0) * s_sG - 2.25) * s_sG * s,\\n\\n      // sG\\n      ((3.375 * (p0 - 3.0 * p1 + 3.0 * p2 - p3) * s_sG - 3.0 * (2.0 * p0 - 5.0 * p1 + 4.0 * p2 - p3)) * s_sG + 0.25 * (11.0 * p0 - 18.0 * p1 + 9.0 * p2 - 2.0 * p3)) * s_sG * s_sG\\n    );\\n\\n    dX_p -= coeff * sinTheta * dT_p;\\n    dY_p += coeff * cosTheta * dT_p;\\n\\n    guess += coeff * vec2(cosTheta, sinTheta);\\n\\n    s += ds;\\n  }\\n\\n  float hOver3 = sG / SIMPSONS_INTERVALS_F / 3.0;\\n\\n  vec3 delta;\\n  delta.xy = goal.xy - guess * hOver3;\\n  delta.z = wrapAngle(goal.z - theta);\\n\\n  if (abs(delta.x) + abs(delta.y) + abs(delta.z) < CONVERGENCE_ERROR)\\n    return vec4(p1, p2, sG, 1.0);\\n\\n  dX_p.xyz *= hOver3;\\n  dY_p.xyz *= hOver3;\\n  dX_p.z += cosTheta;\\n  dY_p.z += sinTheta;\\n\\n  mat3 invJacobian = inverse(transpose(mat3(dX_p, dY_p, dT_p)));\\n\\n  vec3 deltaP = invJacobian * delta;\\n  vec4 params = vec4(p1, p2, sG, 0.0);\\n  params.xyz += deltaP;\\n\\n  return params;\\n}\\n\\n/* Input:\\n *   start: (vec4)\\n *     x: x position,\\n *     y: y position,\\n *     z: theta rotation,\\n *     w: k curvature\\n *   end: (vec4)\\n *     x: x position,\\n *     y: y position,\\n *     z: theta rotation,\\n *     w: k curvature\\n *\\n * Output: (vec4)\\n *   x: p1,\\n *   y: p2,\\n *   z: sG,\\n *   w: 1 if converged, 0 if not\\n */\\n\\nvec4 optimize(vec4 start, vec4 end) {\\n  // Translate and rotate start and end so that start is at the origin\\n  float sinRot = sin(start.z);\\n  float cosRot = cos(start.z);\\n\\n  vec4 diff = end - start;\\n  vec4 goal;\\n  goal.xy = mat2(cosRot, -sinRot, sinRot, cosRot) * diff.xy;\\n  goal.z = wrapAngle(diff.z);\\n  goal.w = end.w;\\n\\n  vec4 originalGoal = goal;\\n  vec4 dGoal;\\n  dGoal.x = 0.0;\\n  dGoal.yzw = goal.yzw / RELAXATION_ITERATIONS_F;\\n  float dK0 = start.w / RELAXATION_ITERATIONS_F;\\n\\n  // Relax the goal to (x, 0, 0, 0)\\n  goal.yzw = vec3(0, 0, 0);\\n\\n  // Relax the params to (0, 0, 0, 0, goal.x)\\n  float p0 = 0.0;\\n  float p1 = 0.0;\\n  float p2 = 0.0;\\n  float p3 = 0.0;\\n  float sG = goal.x;\\n\\n  if (sG < 0.1) return vec4(0.0);\\n\\n  for (int i = 0; i < RELAXATION_ITERATIONS; i++) {\\n    p0 += dK0;\\n    p3 += dGoal.w;\\n    goal += dGoal;\\n    \\n    vec4 result = iterate(goal, p0, p1, p2, p3, sG);\\n    p1 = result.x;\\n    p2 = result.y;\\n    sG = result.z;\\n  }\\n\\n  goal = originalGoal;\\n\\n  for (int i = 0; i < NEWTON_ITERATIONS; i++) {\\n    vec4 result = iterate(goal, p0, p1, p2, p3, sG);\\n    if (result.w == 1.0) {\\n      result.w = step(0.0, result.z);\\n      return result;\\n    }\\n\\n    p1 = result.x;\\n    p2 = result.y;\\n    sG = result.z;\\n  }\\n\\n  return vec4(p1, p2, sG, 0.0);\\n}\\n\\n\\n\\nvec4 kernel() {\\n  ivec2 indexes = ivec2(kernelPosition * vec2(kernelSize));\\n\\n  vec4 start = vec4(0, 0, 0, curvVehicle);\\n  vec4 end = texelFetch(lattice, indexes, 0);\\n\\n  return optimize(start, end);\\n}\\n\\n\",output:{name:\"cubicPathsFromVehicle\",read:!0},uniforms:{lattice:{type:\"sharedTexture\"},curvVehicle:{type:\"float\"}}}],update:(t,e)=>[{width:t.lattice.numStations*t.lattice.numLatitudes,height:t.lattice.stationConnectivity*t.lattice.latitudeConnectivity,uniforms:{numStations:t.lattice.numStations,numLatitudes:t.lattice.numLatitudes,stationConnectivity:t.lattice.stationConnectivity,latitudeConnectivity:t.lattice.latitudeConnectivity}},{width:t.lattice.numLatitudes,height:t.lattice.stationConnectivity,uniforms:{curvVehicle:e.curv}}]};var m={setUp:()=>({kernel:\"\\n\\nconst int NEWTON_ITERATIONS = 32;\\nconst int RELAXATION_ITERATIONS = 32;\\nconst float CONVERGENCE_ERROR = 0.01;\\n\\n// These two consts must stay in sync.\\nconst int SIMPSONS_INTERVALS = 8;\\nconst float SIMPSONS_COEFFS[SIMPSONS_INTERVALS + 1] = float[](1.0, 4.0, 2.0, 4.0, 2.0, 4.0, 2.0, 4.0, 1.0);\\n\\nconst float PI = 3.1415926535897932384626433832795;\\nconst float TWO_PI = PI + PI;\\n\\nconst float RELAXATION_ITERATIONS_F = float(RELAXATION_ITERATIONS);\\nconst float SIMPSONS_INTERVALS_F = float(SIMPSONS_INTERVALS);\\n\\nfloat wrapAngle(float angle) {\\n  angle = mod(angle, TWO_PI);\\n  if (angle <= -PI) return angle + TWO_PI;\\n  else if (angle > PI) return angle - TWO_PI;\\n  return angle;\\n}\\n\\nvec4 iterate(vec4 goal, float p0, float p1, float p2, float p3, float p4, float p5, float sG) {\\n  float ds = sG / SIMPSONS_INTERVALS_F;\\n  float sG_2 = sG * sG;\\n  float sG_3 = sG_2 * sG;\\n\\n  vec3 dX_p = vec3(0.0);\\n  vec3 dY_p = vec3(0.0);\\n  vec2 guess = vec2(0.0);\\n  float s = 0.0;\\n\\n  float theta, cosTheta, sinTheta;\\n  vec3 dT_p;\\n\\n  for (int i = 0; i <= SIMPSONS_INTERVALS; i++) {\\n    float coeff = SIMPSONS_COEFFS[i];\\n\\n    float a = p0;\\n    float b = p1;\\n    float c = p2 / 2.0;\\n    float d = (-71.875 * p0 + 81.0 * p3 - 10.125 * p4 + p5 - 21.25 * p1 * sG - 2.75 * p2 * sG_2) / sG_3;\\n    float e = (166.5 * p0 - 202.5 * p3 + 40.5 * p4 - 4.5 * p5 + 45.0 * p1 * sG + 4.5 * p2 * sG_2) / (sG_2 * sG_2);\\n    float f = (-95.625 * p0 + 121.5 * p3 - 30.375 * p4 + 4.5 * p5 - 24.75 * p1 * sG - 2.25 * p2 * sG_2) / (sG_2 * sG_3);\\n\\n    theta = (((((f * s / 6.0 + e / 5.0) * s + d / 4.0) * s + c / 3.0) * s + b / 2.0) * s + a) * s;\\n    cosTheta = cos(theta);\\n    sinTheta = sin(theta);\\n\\n    float s_2 = s * s;\\n    float s_sG = s / sG;\\n    float s_sG_2 = s_sG * s_sG;\\n    float s_sG_3 = s_sG_2 * s_sG;\\n    float s_sG_4 = s_sG_3 * s_sG;\\n    float s_sG_5 = s_sG_4 * s_sG;\\n\\n    dT_p = vec3(\\n      // p3\\n      ((20.25 * s_sG - 40.5) * s_sG + 20.25) * s_sG_3 * s,\\n\\n      // p4\\n      ((-5.0625 * s_sG + 8.1) * s_sG - 2.53125) * s_sG_3 * s,\\n\\n      // sG\\n      (53.90625 * p0 - 60.75 * p3 + 7.59375 * p4 - 0.75 * p5) * s_sG_4 + 10.625 * p1 * s * s_sG_3 + 0.6875 * p2 * s_2 * s_sG_2 + (-133.2 * p0 + 162.0 * p3 - 32.4 * p4 + 3.6 * p5) * s_sG_5 + (-27.0) * p1 * s * s_sG_4 - 1.8 * p2 * s_2 * s_sG_3 + (79.6875 * p0 - 101.25 * p3 + 25.3125 * p4 - 3.75 * p5) * s_sG_5 * s_sG + 16.5 * p1 * s * s_sG_5 + 1.125 * p2 * s_2 * s_sG_4\\n    );\\n\\n    dX_p -= coeff * sinTheta * dT_p;\\n    dY_p += coeff * cosTheta * dT_p;\\n\\n    guess += coeff * vec2(cosTheta, sinTheta);\\n\\n    s += ds;\\n  }\\n\\n  float hOver3 = sG / SIMPSONS_INTERVALS_F / 3.0;\\n\\n  vec3 delta;\\n  delta.xy = goal.xy - guess * hOver3;\\n  delta.z = wrapAngle(goal.z - theta);\\n\\n  if (abs(delta.x) + abs(delta.y) + abs(delta.z) < CONVERGENCE_ERROR)\\n    return vec4(p3, p4, sG, 1.0);\\n\\n  dX_p.xyz *= hOver3;\\n  dY_p.xyz *= hOver3;\\n  dX_p.z += cosTheta;\\n  dY_p.z += sinTheta;\\n\\n  mat3 invJacobian = inverse(transpose(mat3(dX_p, dY_p, dT_p)));\\n\\n  vec3 deltaP = invJacobian * delta;\\n  vec4 params = vec4(p3, p4, sG, 0.0);\\n  params.xyz += deltaP;\\n\\n  return params;\\n}\\n\\nvec4 optimize(vec4 start, vec4 end) {\\n  // Translate and rotate start and end so that start is at the origin\\n  float sinRot = sin(start.z);\\n  float cosRot = cos(start.z);\\n\\n  vec4 diff = end - start;\\n  vec4 goal;\\n  goal.xy = mat2(cosRot, -sinRot, sinRot, cosRot) * diff.xy;\\n  goal.z = wrapAngle(diff.z);\\n  goal.w = end.w;\\n\\n  vec4 originalGoal = goal;\\n  vec4 dGoal;\\n  dGoal.x = 0.0;\\n  dGoal.yzw = goal.yzw / RELAXATION_ITERATIONS_F;\\n  float d_K0 = start.w / RELAXATION_ITERATIONS_F;\\n  float d_dK0 = dCurvVehicle / RELAXATION_ITERATIONS_F;\\n  float d_ddK0 = ddCurvVehicle / RELAXATION_ITERATIONS_F;\\n\\n  // Relax the goal to (x, 0, 0, 0)\\n  goal.yzw = vec3(0, 0, 0);\\n\\n  // Relax the params to (0, 0, 0, 0, goal.x)\\n  float p0 = 0.0;\\n  float p1 = 0.0;\\n  float p2 = 0.0;\\n  float p3 = 0.0;\\n  float p4 = 0.0;\\n  float p5 = 0.0;\\n  float sG = goal.x;\\n\\n  if (sG < 0.1) return vec4(0.0);\\n\\n  for (int i = 0; i < RELAXATION_ITERATIONS; i++) {\\n    p0 += d_K0;\\n    p1 += d_dK0;\\n    p2 += d_ddK0;\\n    p5 += dGoal.w;\\n    goal += dGoal;\\n    \\n    vec4 result = iterate(goal, p0, p1, p2, p3, p4, p5, sG);\\n    p3 = result.x;\\n    p4 = result.y;\\n    sG = result.z;\\n  }\\n\\n  goal = originalGoal;\\n\\n  for (int i = 0; i < NEWTON_ITERATIONS; i++) {\\n    vec4 result = iterate(goal, p0, p1, p2, p3, p4, p5, sG);\\n    if (result.w == 1.0) {\\n      result.w = step(0.0, result.z);\\n      return result;\\n    }\\n\\n    p3 = result.x;\\n    p4 = result.y;\\n    sG = result.z;\\n  }\\n\\n  return vec4(p3, p4, sG, 0.0);\\n}\\n\\nvec4 kernel() {\\n  ivec2 latticeIndexes = ivec2(kernelPosition * vec2(kernelSize));\\n\\n  vec4 start = vec4(0, 0, 0, curvVehicle);\\n  vec4 end = texelFetch(lattice, latticeIndexes, 0);\\n\\n  return optimize(start, end);\\n}\\n\\n\",output:{name:\"quinticPathsFromVehicle\",read:!0},uniforms:{lattice:{type:\"sharedTexture\"},curvVehicle:{type:\"float\"},dCurvVehicle:{type:\"float\"},ddCurvVehicle:{type:\"float\"}}}),update:(t,e)=>({width:t.lattice.numLatitudes,height:t.lattice.stationConnectivity,uniforms:{curvVehicle:e.curv,dCurvVehicle:e.dCurv,ddCurvVehicle:e.ddCurv}})};const f=\"\\n\\nconst float smallV = 0.01;\\nvec4 pathSamples[128];\\nfloat pathSampleCurvRates[128];\\n\\nfloat calculateAcceleration(int index, float initialVelocitySq, float distance) {\\n  if (index <= 4) {\\n    // [aMaxHard, aMinHard, aMaxSoft, aMinSoft, 0]\\n    return accelerationProfiles[index];\\n  } else {\\n    float finalVelocity = finalVelocityProfiles[index - 5];\\n    if (distance < 0.001) return 0.0;\\n    return clamp((finalVelocity * finalVelocity - initialVelocitySq) / (2.0 * distance), accelerationProfiles[1], accelerationProfiles[0]);\\n  }\\n}\\n\\nfloat sampleStaticCost(vec4 xytk) {\\n  vec2 xyTexCoords = (xytk.xy - xyCenterPoint) / vec2(textureSize(xyslMap, 0)) / vec2(xyGridCellSize) + 0.5;\\n  vec2 sl = texture(xyslMap, xyTexCoords).xy;\\n\\n  vec2 slTexCoords = (sl - slCenterPoint) / vec2(textureSize(slObstacleGrid, 0)) / vec2(slGridCellSize) + 0.5;\\n  float obstacleCost = texture(slObstacleGrid, slTexCoords).r;\\n\\n  if (obstacleCost >= 0.75) return -1.0; // Infinite cost\\n  obstacleCost = step(0.25, obstacleCost) * obstacleHazardCost;\\n\\n  float absLatitude = abs(sl.y);\\n  float laneCost = max(absLatitude * laneCostSlope, step(laneShoulderLatitude, absLatitude) * laneShoulderCost);\\n\\n  return obstacleCost + laneCost;\\n}\\n\\nfloat sampleDynamicCost(vec4 xytk, float time, float velocity, float acceleration) {\\n  return 1.0;\\n}\\n\\nfloat calculateAverageStaticCost(int numSamples) {\\n  float averageStaticCost = 0.0;\\n\\n  for (int i = 0; i < numSamples; i++) {\\n    float cost = sampleStaticCost(pathSamples[i]);\\n\\n    if (cost < 0.0) return cost;\\n\\n    averageStaticCost += cost;\\n  }\\n\\n  averageStaticCost /= float(numSamples);\\n\\n  return averageStaticCost;\\n}\\n\\nfloat calculateAverageDynamicCost(int numSamples, float pathLength, float initialVelocity, float acceleration) {\\n  float s = 0.0;\\n  float ds = pathLength / float(numSamples - 1);\\n  float averageDynamicCost = 0.0;\\n  float maxVelocity = 0.0;\\n  float maxLateralAcceleration = 0.0;\\n\\n  for (int i = 0; i < numSamples; i++) {\\n    vec4 pathSample = pathSamples[i]; // vec4(x-pos, y-pos, theta (rotation), kappa (curvature))\\n\\n    float velocitySq = 2.0 * acceleration * s + initialVelocity * initialVelocity;\\n    float velocity = max(smallV, sqrt(max(0.0, velocitySq)));\\n    maxVelocity = max(maxVelocity, velocity);\\n    maxLateralAcceleration = max(maxLateralAcceleration, abs(pathSample.w * velocity * velocity));\\n\\n    float time = 2.0 * s / (initialVelocity + velocity);\\n\\n    float dCurv = pathSampleCurvRates[i] * velocity;\\n    if (dCurv > dCurvatureMax) return -1.0;\\n\\n    float cost = sampleDynamicCost(pathSample, time, velocity, acceleration);\\n    if (cost < 0.0) return cost;\\n\\n    averageDynamicCost += cost;\\n    s += ds;\\n  }\\n\\n  averageDynamicCost /= float(numSamples);\\n\\n  // Apply speeding penality if any velocity along the trajectory is over the speed limit\\n  averageDynamicCost += step(speedLimit, maxVelocity) * speedLimitPenalty;\\n\\n  // Apply hard acceleration/deceleration penalties if the acceleration/deceleration exceeds the soft limits\\n  averageDynamicCost += step(accelerationProfiles[2] + 0.0001, acceleration) * hardAccelerationPenalty;\\n  averageDynamicCost += (1.0 - step(accelerationProfiles[3], acceleration)) * hardDecelerationPenalty;\\n\\n  // Penalize lateral acceleration\\n  averageDynamicCost += step(lateralAccelerationLimit, maxLateralAcceleration) * softLateralAccelerationPenalty;\\n  averageDynamicCost += linearLateralAccelerationPenalty * maxLateralAcceleration;\\n\\n  return averageDynamicCost;\\n}\\n\\nvec3 calculateAVT(int accelerationIndex, float initialVelocity, float initialTime, float pathLength) {\\n  float initialVelocitySq = initialVelocity * initialVelocity;\\n  float acceleration = calculateAcceleration(accelerationIndex, initialVelocitySq, pathLength);\\n\\n  float finalVelocitySq = 2.0 * acceleration * pathLength + initialVelocitySq;\\n  float finalVelocity = max(smallV, sqrt(max(0.0, finalVelocitySq)));\\n\\n  float finalTime = initialTime;\\n\\n  if (acceleration == 0.0) {\\n    finalTime += pathLength / finalVelocity;\\n  } else if (finalVelocitySq <= 0.0) { // Calculate final time if the vehicle stops before the end of the trajectory\\n    float distanceLeft = pathLength - (smallV * smallV - initialVelocitySq) / (2.0 * acceleration);\\n    finalTime += (finalVelocity - initialVelocity) / acceleration + distanceLeft / smallV;\\n  } else {\\n    finalTime += 2.0 * pathLength / (finalVelocity + initialVelocity);\\n  }\\n\\n  return vec3(acceleration, finalVelocity, finalTime);\\n}\\n\\n\",g=\"\\n\\nint sampleCubicPath(vec4 start, vec4 end, vec4 cubicPathParams) {\\n  float p0 = start.w;\\n  float p1 = cubicPathParams.x;\\n  float p2 = cubicPathParams.y;\\n  float p3 = end.w;\\n  float sG = cubicPathParams.z;\\n\\n  if (sG <= 0.0) return 0;\\n\\n  int numSamples = int(ceil(sG / pathSamplingStep)) + 1;\\n\\n  float sG_2 = sG * sG;\\n  float sG_3 = sG_2 * sG;\\n\\n  float a = p0;\\n  float b = (-5.5 * p0 + 9.0 * p1 - 4.5 * p2 + p3) / sG;\\n  float c = (9.0 * p0 - 22.5 * p1 + 18.0 * p2 - 4.5 * p3) / sG_2;\\n  float d = (-4.5 * (p0 - 3.0 * p1 + 3.0 * p2 - p3)) / sG_3;\\n\\n  pathSamples[0] = start;\\n\\n  float ds = sG / float(numSamples - 1);\\n  float s = ds;\\n  vec2 dxy = vec2(0);\\n  vec2 prevCosSin = vec2(cos(start.z), sin(start.z));\\n\\n  for (int i = 1; i < numSamples; i++) {\\n    float rot = (((d * s / 4.0 + c / 3.0) * s + b / 2.0) * s + a) * s + start.z;\\n    float curv = ((d * s + c) * s + b) * s + a;\\n\\n    vec2 cosSin = vec2(cos(rot), sin(rot));\\n    dxy = dxy * vec2(float(i - 1) / float(i)) + (cosSin + prevCosSin) / vec2(2 * i);\\n\\n    pathSamples[i] = vec4(dxy * vec2(s) + start.xy, rot, curv);\\n    pathSampleCurvRates[i] = b + s * (2.0 * c + 3.0 * d * s);\\n\\n    s += ds;\\n    prevCosSin = cosSin;\\n  }\\n\\n  return numSamples;\\n}\\n\\n\",y=\"\\n\\nint sampleQuinticPath(vec4 start, vec4 end, vec4 quinticPathParams) {\\n  float p0 = start.w;\\n  float p1 = dCurvVehicle;\\n  float p2 = ddCurvVehicle;\\n  float p3 = quinticPathParams.x;\\n  float p4 = quinticPathParams.y;\\n  float p5 = end.w;\\n  float sG = quinticPathParams.z;\\n\\n  if (sG <= 0.0) return 0;\\n\\n  int numSamples = int(ceil(sG / pathSamplingStep)) + 1;\\n\\n  float sG_2 = sG * sG;\\n  float sG_3 = sG_2 * sG;\\n\\n  float a = p0;\\n  float b = p1;\\n  float c = p2 / 2.0;\\n  float d = (-71.875 * p0 + 81.0 * p3 - 10.125 * p4 + p5 - 21.25 * p1 * sG - 2.75 * p2 * sG_2) / sG_3;\\n  float e = (166.5 * p0 - 202.5 * p3 + 40.5 * p4 - 4.5 * p5 + 45.0 * p1 * sG + 4.5 * p2 * sG_2) / (sG_2 * sG_2);\\n  float f = (-95.625 * p0 + 121.5 * p3 - 30.375 * p4 + 4.5 * p5 - 24.75 * p1 * sG - 2.25 * p2 * sG_2) / (sG_2 * sG_3);\\n\\n  pathSamples[0] = start;\\n\\n  float ds = sG / float(numSamples - 1);\\n  float s = ds;\\n  vec2 dxy = vec2(0);\\n  vec2 prevCosSin = vec2(cos(start.z), sin(start.z));\\n\\n  for (int i = 1; i < numSamples; i++) {\\n    float rot = (((((f * s / 6.0 + e / 5.0) * s + d / 4.0) * s + c / 3.0) * s + b / 2.0) * s + a) * s + start.z;\\n    float curv = ((((f * s + e) * s + d) * s + c) * s + b) * s + a;\\n\\n    vec2 cosSin = vec2(cos(rot), sin(rot));\\n    dxy = dxy * vec2(float(i - 1) / float(i)) + (cosSin + prevCosSin) / vec2(2 * i);\\n\\n    pathSamples[i] = vec4(dxy * vec2(s) + start.xy, rot, curv);\\n    pathSampleCurvRates[i] = b + s * (2.0 * c + s * (3.0 * d + s * (4.0 * e + 5.0 * f * s)));\\n\\n    s += ds;\\n    prevCosSin = cosSin;\\n  }\\n\\n  return numSamples;\\n}\\n\\n\",v={xyslMap:{type:\"outputTexture\"},slObstacleGrid:{type:\"outputTexture\",name:\"slObstacleGridDilated\"},accelerationProfiles:{type:\"float\",length:5},finalVelocityProfiles:{type:\"float\",length:3},xyCenterPoint:{type:\"vec2\"},xyGridCellSize:{type:\"float\"},slCenterPoint:{type:\"vec2\"},slGridCellSize:{type:\"float\"},laneCostSlope:{type:\"float\"},laneShoulderCost:{type:\"float\"},laneShoulderLatitude:{type:\"float\"},obstacleHazardCost:{type:\"float\"},speedLimit:{type:\"float\"},speedLimitPenalty:{type:\"float\"},hardAccelerationPenalty:{type:\"float\"},hardDecelerationPenalty:{type:\"float\"},lateralAccelerationLimit:{type:\"float\"},softLateralAccelerationPenalty:{type:\"float\"},linearLateralAccelerationPenalty:{type:\"float\"},dCurvatureMax:{type:\"float\"},pathSamplingStep:{type:\"float\"},rearAxleToCenter:{type:\"float\"}};function E(t,e,n){return{accelerationProfiles:[3.5,-6.5,2,-3,0],finalVelocityProfiles:[.999*t.speedLimit,1,.01],xyCenterPoint:[e.x,e.y],xyGridCellSize:t.xyGridCellSize,slCenterPoint:[n.x,n.y],slGridCellSize:t.slGridCellSize,laneCostSlope:t.laneCostSlope,laneShoulderCost:t.laneShoulderCost,laneShoulderLatitude:t.laneShoulderLatitude,obstacleHazardCost:t.obstacleHazardCost,speedLimit:t.speedLimit,speedLimitPenalty:t.speedLimitPenalty,hardAccelerationPenalty:t.hardAccelerationPenalty,hardDecelerationPenalty:t.hardDecelerationPenalty,lateralAccelerationLimit:t.lateralAccelerationLimit,softLateralAccelerationPenalty:t.softLateralAccelerationPenalty,linearLateralAccelerationPenalty:t.linearLateralAccelerationPenalty,dCurvatureMax:t.dCurvatureMax,pathSamplingStep:t.pathSamplingStep,rearAxleToCenter:t.rearAxleToCenter}}function x(t){return f+(\"cubic\"==t?g:y)+`\\n\\n/* Calculate cost of a {cubic|quintic} path from vehicle to (stationConnectivity * numLatitudes * numAccelerations) nodes\\n *   width: numLatitudes\\n *   height: station * numAccelerations\\n */\\nvec4 kernel() {\\n  ivec2 indexes = ivec2(kernelPosition * vec2(kernelSize));\\n\\n  int latitude = indexes.x;\\n  int station = indexes.y / numAccelerations;\\n  int accelerationIndex = int(mod(float(indexes.y), float(numAccelerations)));\\n\\n  vec4 pathStart = vec4(0, 0, 0, curvVehicle);\\n  vec4 pathEnd = texelFetch(lattice, ivec2(latitude, station), 0);\\n\\n  vec4 pathParams = texelFetch(pathsFromVehicle, ivec2(latitude, station), 0);\\n\\n  // If the path didn't converge\\n  if (pathParams.w == 0.0) return vec4(-1);\\n\\n  int numSamples = ${\"cubic\"==t?\"sampleCubicPath\":\"sampleQuinticPath\"}(pathStart, pathEnd, pathParams);\\n  float pathLength = pathParams.z;\\n\\n  if (numSamples < 2) return vec4(-1);\\n\\n  float averageStaticCost = calculateAverageStaticCost(numSamples);\\n  if (averageStaticCost < 0.0) return vec4(-1);\\n\\n  int slIndex = station * kernelSize.x + latitude;\\n  float hysteresisAdjustment = (slIndex == firstLatticePoint || slIndex == secondLatticePoint) ?  0.0 : hysteresisDiscount;\\n  averageStaticCost += hysteresisAdjustment;\\n\\n  vec3 avt = calculateAVT(accelerationIndex, velocityVehicle, 0.0, pathLength);\\n  float acceleration = avt.x;\\n  float finalVelocity = avt.y;\\n  float finalTime = avt.z;\\n\\n  float averageDynamicCost = calculateAverageDynamicCost(numSamples, pathLength, velocityVehicle, acceleration);\\n  if (averageDynamicCost < 0.0) return vec4(-1);\\n\\n  averageDynamicCost += accelerationChangePenalty;\\n\\n  // The cost of a trajectory is the average sample cost scaled by the path length\\n  float totalCost = (averageStaticCost + averageDynamicCost + ${\"cubic\"==t?\"(cubicPathPenalty * velocityVehicle * velocityVehicle)\":\"0.0\"}) * pathLength;\\n\\n  return vec4(totalCost, finalVelocity, finalTime, ${\"cubic\"==t?\"-2\":\"-1\"});\\n}\\n\\n`}var T={setUp:()=>[{kernel:x(\"cubic\"),output:{name:\"cubicPathFromVehicleCosts\"},uniforms:{...v,lattice:{type:\"sharedTexture\"},pathsFromVehicle:{type:\"outputTexture\",name:\"cubicPathsFromVehicle\"},firstLatticePoint:{type:\"int\"},secondLatticePoint:{type:\"int\"},velocityVehicle:{type:\"float\"},curvVehicle:{type:\"float\"},numAccelerations:{type:\"int\"},cubicPathPenalty:{type:\"float\"},hysteresisDiscount:{type:\"float\"},accelerationChangePenalty:{type:\"float\"}}},{kernel:x(\"quintic\"),output:{name:\"quinticPathFromVehicleCosts\"},uniforms:{...v,lattice:{type:\"sharedTexture\"},pathsFromVehicle:{type:\"outputTexture\",name:\"quinticPathsFromVehicle\"},firstLatticePoint:{type:\"int\"},secondLatticePoint:{type:\"int\"},velocityVehicle:{type:\"float\"},curvVehicle:{type:\"float\"},dCurvVehicle:{type:\"float\"},ddCurvVehicle:{type:\"float\"},numAccelerations:{type:\"int\"},hysteresisDiscount:{type:\"float\"},accelerationChangePenalty:{type:\"float\"}}}],update:(t,e,n,i,a,s)=>[{width:t.lattice.numLatitudes,height:8*t.lattice.stationConnectivity,uniforms:{...E(t,n,i),firstLatticePoint:a,secondLatticePoint:s,velocityVehicle:e.velocity,curvVehicle:e.curv,numAccelerations:8,cubicPathPenalty:t.cubicPathPenalty,hysteresisDiscount:t.hysteresisDiscount,accelerationChangePenalty:t.accelerationChangePenalty}},{width:t.lattice.numLatitudes,height:8*t.lattice.stationConnectivity,uniforms:{...E(t,n,i),firstLatticePoint:a,secondLatticePoint:s,velocityVehicle:e.velocity,curvVehicle:e.curv,dCurvVehicle:e.dCurv,ddCurvVehicle:e.ddCurv,numAccelerations:8,hysteresisDiscount:t.hysteresisDiscount,accelerationChangePenalty:t.accelerationChangePenalty}}]};const S=f+g+y+\"\\n\\nvec4 kernel() {\\n  ivec2 indexes = ivec2(kernelPosition * vec2(kernelSize));\\n\\n  int latitude = indexes.y;\\n\\n  int numPerTime = numAccelerations * numVelocities;\\n  int timeIndex = indexes.x / numPerTime;\\n  indexes.x -= timeIndex * numPerTime;\\n  int velocityIndex = indexes.x / numAccelerations;\\n  int accelerationIndex = int(mod(float(indexes.x), float(numAccelerations)));\\n\\n  int minLatitude = max(latitude - latitudeConnectivity / 2, 0);\\n  int maxLatitude = min(latitude + latitudeConnectivity / 2, numLatitudes - 1);\\n\\n  int slIndex = station * numLatitudes + latitude;\\n\\n  vec4 pathEnd = texelFetch(lattice, ivec2(latitude, station), 0);\\n\\n  float minVelocity = velocityRanges[velocityIndex];\\n  float maxVelocity = velocityRanges[velocityIndex + 1];\\n\\n  float minTime = timeRanges[timeIndex];\\n  float maxTime = timeRanges[timeIndex + 1];\\n\\n  vec4 bestTrajectory = vec4(-1); // -1 means infinite cost\\n  float bestCost = 1000000000.0;\\n\\n  float hysteresisAdjustment = (slIndex == firstLatticePoint || slIndex == secondLatticePoint) ?  0.0 : hysteresisDiscount;\\n\\n  for (int prevStation = max(station - stationConnectivity, 0); prevStation < station; prevStation++) {\\n    int stationConnectivityIndex = prevStation - station + stationConnectivity;\\n\\n    for (int prevLatitude = minLatitude; prevLatitude <= maxLatitude; prevLatitude++) {\\n      int latitudeConnectivityIndex = prevLatitude - latitude + latitudeConnectivity / 2;\\n      int connectivityIndex = stationConnectivityIndex * latitudeConnectivity + latitudeConnectivityIndex;\\n\\n      vec4 pathStart = texelFetch(lattice, ivec2(prevLatitude, prevStation), 0);\\n      vec4 cubicPathParams = texelFetch(cubicPaths, ivec2(slIndex, connectivityIndex), 0);\\n\\n      // If the path didn't converge\\n      if (cubicPathParams.w == 0.0) continue;\\n\\n      int numSamples = sampleCubicPath(pathStart, pathEnd, cubicPathParams);\\n      float pathLength = cubicPathParams.z;\\n\\n      if (numSamples < 2) continue;\\n\\n      float averageStaticCost = calculateAverageStaticCost(numSamples);\\n      if (averageStaticCost < 0.0) continue;\\n\\n      averageStaticCost += hysteresisAdjustment;\\n\\n      for (int prevVelocity = 0; prevVelocity < numVelocities; prevVelocity++) {\\n        for (int prevTime = 0; prevTime < numTimes; prevTime++) {\\n          for (int prevAccel = 0; prevAccel < numAccelerations; prevAccel++) {\\n            int avtIndex = prevTime * numPerTime + prevVelocity * numAccelerations + prevAccel;\\n\\n            // Cost table entry:\\n            //   x: cost so far\\n            //   y: end velocity\\n            //   z: end time\\n            //   w: parent index\\n            vec4 costTableEntry = texelFetch(costTable, ivec3(avtIndex, prevLatitude, prevStation), 0);\\n\\n            // If cost entry is infinity\\n            if (costTableEntry.x < 0.0) continue;\\n\\n            vec3 avt = calculateAVT(accelerationIndex, costTableEntry.y, costTableEntry.z, pathLength);\\n            float acceleration = avt.x;\\n            float finalVelocity = avt.y;\\n            float finalTime = avt.z;\\n\\n            // If the calculated final velocity does not match this fragment's velocity range, then skip this trajectory\\n            if (finalVelocity < minVelocity || finalVelocity >= maxVelocity) continue;\\n\\n            // If the calculated final time does not match this fragment's time range, then skip this trajectory\\n            if (finalTime < minTime || finalTime >= maxTime) continue;\\n\\n            float averageDynamicCost = calculateAverageDynamicCost(numSamples, pathLength, costTableEntry.y, acceleration);\\n            if (averageDynamicCost < 0.0) continue;\\n\\n            if (accelerationIndex != prevAccel)\\n              averageDynamicCost += accelerationChangePenalty;\\n\\n            // The cost of a trajectory is the average sample cost scaled by the path length\\n            float totalCost = (averageStaticCost + averageDynamicCost) * pathLength + costTableEntry.x;\\n\\n            float terminalCost = totalCost + extraTimePenalty * finalTime;\\n            if (terminalCost >= bestCost) continue;\\n            bestCost = terminalCost;\\n\\n            int incomingIndex = avtIndex + numPerTime * numTimes * (prevLatitude + numLatitudes * prevStation);\\n            bestTrajectory = vec4(totalCost, finalVelocity, finalTime, incomingIndex);\\n          }\\n        }\\n      }\\n    }\\n  }\\n\\n  if (station < stationConnectivity) {\\n    ivec2 slaIndex = ivec2(latitude, station * numAccelerations + accelerationIndex);\\n\\n    vec4 costTableEntry = texelFetch(cubicPathFromVehicleCosts, slaIndex, 0);\\n    float terminalCost;\\n\\n    if (costTableEntry.x >= 0.0) {\\n      terminalCost = costTableEntry.x + extraTimePenalty * costTableEntry.z;\\n\\n      if (terminalCost < bestCost) {\\n        bestCost = terminalCost;\\n        bestTrajectory = costTableEntry;\\n      }\\n    }\\n\\n    costTableEntry = texelFetch(quinticPathFromVehicleCosts, slaIndex, 0);\\n\\n    if (costTableEntry.x >= 0.0) {\\n      terminalCost = costTableEntry.x + extraTimePenalty * costTableEntry.z;\\n\\n      if (terminalCost < bestCost) {\\n        bestCost = terminalCost;\\n        bestTrajectory = costTableEntry;\\n      }\\n    }\\n  }\\n\\n  return bestTrajectory;\\n}\\n\\n\";var P={setUp:()=>({kernel:S,output:{name:\"graphSearch\"},uniforms:{...v,lattice:{type:\"sharedTexture\"},costTable:{type:\"sharedTexture\",textureType:\"2DArray\"},cubicPaths:{type:\"outputTexture\"},cubicPathFromVehicleCosts:{type:\"outputTexture\"},quinticPathFromVehicleCosts:{type:\"outputTexture\"},firstLatticePoint:{type:\"int\"},secondLatticePoint:{type:\"int\"},velocityVehicle:{type:\"float\"},curvVehicle:{type:\"float\"},dCurvVehicle:{type:\"float\"},ddCurvVehicle:{type:\"float\"},extraTimePenalty:{type:\"float\"},hysteresisDiscount:{type:\"float\"},accelerationChangePenalty:{type:\"float\"},numStations:{type:\"int\"},numLatitudes:{type:\"int\"},numAccelerations:{type:\"int\"},numVelocities:{type:\"int\"},numTimes:{type:\"int\"},stationConnectivity:{type:\"int\"},latitudeConnectivity:{type:\"int\"},velocityRanges:{type:\"float\",length:5},timeRanges:{type:\"float\",length:3},station:{type:\"int\"}},drawProxy:(t,e,n)=>{const i=e.meta.lattice.numLatitudes,a=new Float32Array(64*i*e.meta.lattice.numStations*4);for(let s=0;s<e.meta.lattice.numStations;s++)t.updateProgramUniforms(e,{station:s}),n(),t.gl.readPixels(0,0,64,i,t.gl.RGBA,t.gl.FLOAT,a,64*s*i*4),t.gl.bindTexture(t.gl.TEXTURE_2D_ARRAY,t.sharedTextures.costTable),t.gl.copyTexSubImage3D(t.gl.TEXTURE_2D_ARRAY,0,0,0,s,0,0,64,i);t._graphSearchCostTable=a}}),update:(t,e,n,i,a,s)=>({width:64,height:t.lattice.numLatitudes,meta:{lattice:t.lattice},uniforms:{...E(t,n,i),firstLatticePoint:a,secondLatticePoint:s,velocityVehicle:e.velocity,curvVehicle:e.curv,dCurvVehicle:e.dCurv,ddCurvVehicle:e.ddCurv,extraTimePenalty:t.extraTimePenalty,hysteresisDiscount:t.hysteresisDiscount,accelerationChangePenalty:t.accelerationChangePenalty,numStations:t.lattice.numStations,numLatitudes:t.lattice.numLatitudes,numAccelerations:8,numVelocities:4,numTimes:2,stationConnectivity:t.lattice.stationConnectivity,latitudeConnectivity:t.lattice.latitudeConnectivity,velocityRanges:[0,t.speedLimit/3,2*t.speedLimit/3,t.speedLimit,1e6],timeRanges:[0,10,1e6]}})};n.d(e,\"a\",function(){return w});const C=8,b=4,_=2;class w{constructor(){this.previousStartStation=null,this.previousFirstLatticePoint=-1,this.previousSecondLatticePoint=-1;performance.now();const t=[l.setUp(),c.setUp(),...d.setUp(),u.setUp(),...p.setUp(),m.setUp(),...T.setUp(),P.setUp()].map(t=>Object.assign({},t,{width:1,height:1}));this.gpgpu=new i.a(t)}reset(){this.previousStartStation=null,this.previousFirstLatticePoint=-1,this.previousSecondLatticePoint=-1}plan(t,e,n,i){const a=n.sampleStations(e,Math.ceil(this.config.spatialHorizon/this.config.centerlineStationInterval)+1,this.config.centerlineStationInterval),s=function({pos:t,rot:e}){const n=new THREE.Matrix3;n.set(1,0,-t.x,0,1,-t.y,0,0,1);const i=Math.cos(e),a=Math.sin(e),s=new THREE.Matrix3;return s.set(i,a,0,-a,i,0,0,0,1),s.multiply(n)}(t),o=a.map(e=>({pos:e.pos.clone().applyMatrix3(s),rot:e.rot-t.rot,curv:e.curv})),r=new Float32Array(3*o.length),h=new THREE.Vector2(0,0),f=new THREE.Vector2(0,0);for(let t=0;t<o.length;t++){const e=o[t],n=e.pos;r[3*t+0]=n.x,r[3*t+1]=n.y,r[3*t+2]=e.rot,h.max(n),f.min(n)}const g=h.clone().sub(f),y=f.clone().add(h).divideScalar(2),v=Math.ceil((g.x+2*this.config.gridMargin)/this.config.xyGridCellSize),E=Math.ceil((g.y+2*this.config.gridMargin)/this.config.xyGridCellSize),x=new THREE.Vector2(this.config.spatialHorizon/2,0),S=Math.ceil(this.config.spatialHorizon/this.config.slGridCellSize),w=Math.ceil((this.config.laneWidth+2*this.config.gridMargin)/this.config.slGridCellSize),R=this._latticeStationInterval();let A;null===this.previousStartStation||e+R/2>this.previousStartStation?(A=(null===this.previousStartStation?e:this.previousStartStation)+R,this.previousStartStation=A,this.previousFirstLatticePoint-=this.config.lattice.numLatitudes,this.previousSecondLatticePoint-=this.config.lattice.numLatitudes):A=this.previousStartStation;const L=this._buildLattice(n,A,t.rot,s);for(const[e,n]of[l.update(this.config,v,E,y,s,i),c.update(this.config,S,w,x,y),...d.update(this.config,S,w),u.update(this.config,v,E,y),...p.update(this.config,t),m.update(this.config,t),...T.update(this.config,t,y,x,this.previousFirstLatticePoint,this.previousSecondLatticePoint),P.update(this.config,t,y,x,this.previousFirstLatticePoint,this.previousSecondLatticePoint)].entries())this.gpgpu.updateProgram(e,n);this.gpgpu.updateSharedTextures({centerline:{width:o.length,height:1,channels:3,filter:\"linear\",data:r},costTable:{width:C*b*_,height:this.config.lattice.numLatitudes,depth:this.config.lattice.numStations,channels:4,textureType:\"2DArray\"},lattice:{width:this.config.lattice.numLatitudes,height:this.config.lattice.numStations,channels:4,data:L}});performance.now();const I=this.gpgpu.run(),M=this.gpgpu._graphSearchCostTable,G=I[5],O=I[6],H=I[7];let D,F=[Number.POSITIVE_INFINITY];const V=M.length/4;for(let t=0;t<V;t++){const e=this._unpackCostTableIndex(t),n=[M[4*t],M[4*t+1],M[4*t+2],M[4*t+3]];n[0]<0||(n[0]+=this._terminalCost(e,n),n[0]<F[0]&&(D=t,F=n))}const N=(new THREE.Matrix3).getInverse(s);let z=null,k=null,B=null,U=-1,W=-1;return isFinite(F[0])&&([z,k,B,U,W]=this._reconstructTrajectory(D,M,G,O,H,t,L),U==this.previousFirstLatticePoint&&W==this.previousSecondLatticePoint?(z=null,k=null,B=null):(k.forEach(e=>{e.pos=e.pos.applyMatrix3(N),e.rot+=t.rot}),z.forEach(e=>{e.pos=e.pos.applyMatrix3(N),e.rot+=t.rot}))),this.previousFirstLatticePoint=U,this.previousSecondLatticePoint=W,{path:z,fromVehicleSegment:k,fromVehicleParams:B,latticeStartStation:this.previousStartStation}}_buildLattice(t,e,n,i){const a=t.sampleStations(e,this.config.lattice.numStations,this._latticeStationInterval()),s=Math.floor(this.config.lattice.numLatitudes/2),o=new Float32Array(this.config.lattice.numStations*this.config.lattice.numLatitudes*4);let r=0;for(let t=0;t<this.config.lattice.numStations;t++){const e=a[t];for(let t=0;t<this.config.lattice.numLatitudes;t++){const a=(t-s)/s*this.config.laneWidth/2,l=e.rot-n,c=THREE.Vector2.fromAngle(l+Math.PI/2).multiplyScalar(a).add(e.pos.clone().applyMatrix3(i)),h=0==e.curv?0:1/(1/e.curv-a);o[r++]=c.x,o[r++]=c.y,o[r++]=l,o[r++]=h}}return o}_latticeStationInterval(){return this.config.spatialHorizon/this.config.lattice.numStations}_terminalCost([t,e,n,i,a],[s,o,r,l]){if(t!=this.config.lattice.numStations-1&&o>.05)return Number.POSITIVE_INFINITY;return this.config.spatialHorizon/this.config.lattice.numStations*(t+1)*-this.config.stationReachDiscount+r*this.config.extraTimePenalty}_unpackCostTableIndex(t){if(t<0)return[-1,t+2,null,null,null];const e=C*b,n=e*_,i=this.config.lattice.numLatitudes*n,a=Math.floor(t/i);t-=a*i;const s=Math.floor(t/n);t-=s*n;const o=Math.floor(t/e);return t-=o*e,[a,s,o,Math.floor(t/C),t%C]}_reconstructTrajectory(t,e,n,i,o,r,l){let c=this._unpackCostTableIndex(t);c.push(e[4*t+1]);const h=[c];let d=0;for(;c[0]>=0&&d++<100;){t=e[4*t+3];const n=(c=this._unpackCostTableIndex(t))[0]>=0?e[4*t+1]:r.velocity;c.push(n),h.unshift(c)}if(d>=100)throw new Error(\"Infinite loop encountered while reconstructing trajectory.\");const u=[];let p=[],m=null;for(let t=0;t<h.length-1;t++){const[e,c,d,f,g,y]=h[t],[v,E,x,T,S,P]=h[t+1];let C,b;if(e<0){const t={pos:new THREE.Vector2(0,0),rot:0,curv:r.curv},e=4*(v*this.config.lattice.numLatitudes+E),n={pos:new THREE.Vector2(l[e],l[e+1]),rot:l[e+2],curv:l[e+3]};if(0==c){C=i[e+2];const s={p1:i[e],p2:i[e+1],sG:C};b=new a.a(t,n,s),m={type:\"cubic\",params:s}}else{C=o[e+2];const i={p3:o[e],p4:o[e+1],sG:C};b=new s(t,n,i),m={type:\"quintic\",params:i}}}else{const t=4*(e*this.config.lattice.numLatitudes+c),i=4*(v*this.config.lattice.numLatitudes+E),s={pos:new THREE.Vector2(l[t],l[t+1]),rot:l[t+2],curv:l[t+3]},o={pos:new THREE.Vector2(l[i],l[i+1]),rot:l[i+2],curv:l[i+3]},r=v*this.config.lattice.numLatitudes+E,h=4*(((e-v+this.config.lattice.stationConnectivity)*this.config.lattice.latitudeConnectivity+c-E+Math.floor(this.config.lattice.latitudeConnectivity/2))*this.config.lattice.numStations*this.config.lattice.numLatitudes+r);C=n[h+2],b=new a.a(s,o,{p1:n[h],p2:n[h+1],sG:C})}const _=b.buildPath(Math.ceil(C/this.config.pathSamplingStep)),w=y*y,R=(P*P-w)/2/C,A=C/(_.length-1);let L=0;for(let t=0;t<_.length;t++)_[t].velocity=Math.sqrt(2*R*L+w),_[t].acceleration=R,L+=A;e<0?p=_:(t>0&&_.shift(),u.push(..._))}let f=null,g=null;return h.length>=2&&(f=h[1][0]*this.config.lattice.numLatitudes+h[1][1]),h.length>=3&&(g=h[2][0]*this.config.lattice.numLatitudes+h[2][1]),[u,p,m,f,g]}}},,function(t,e,n){\"use strict\";n.r(e);var i=n(3);class a{constructor(){this.cars=[]}step(t){this.cars.forEach(e=>e.step(t))}createCar(){const t=new i.a;return this.cars.push(t),t}}var s=n(0);class o{constructor(t,e=0,n=0){this.poses=t;for(let i=0;i<t.length;i++){const a=t[i];if(void 0===a.rot){let s;if(0==i)s=e;else if(i==t.length-1)s=n;else{const e=t[i-1].pos,n=t[i+1].pos;s=Math.atan2(n.y-e.y,n.x-e.x)}a.rot=s}a.frontPos=s.a.getFrontAxlePosition(a.pos,a.rot),a.fakePos=s.a.getFakeAxlePosition(a.pos,a.rot)}}}n(1);class r{constructor(t,e){this.path=t,this.car=e,this.nextIndex=1,this.prevVelocity=0,this.prevAccel=0}reset(){this.prevVelocity=0,this.prevAccel=0}replacePath(t){this.path=t,this.nextIndex=1}predictPoseAfterTime(t,e){const n=this.path.poses;let[i,a]=this.findNextIndex(t.pos),s=t.velocity;if(s<=.01)return t;for(;e>0;){const t=n[i-1],o=n[i],r=o.pos.distanceTo(t.pos),l=r*(1-a),c=s+o.velocity,h=2*l/(0==c?.01:c);if(h>=e||i+1>=n.length){const n=a+c/2*e/r,i=Math.wrapAngle(t.rot+Math.wrapAngle(o.rot-t.rot)*n);return{pos:o.pos.clone().sub(t.pos).multiplyScalar(n).add(o.pos),rot:i,curv:t.curv+(o.curv-t.curv)*n,dCurv:0,ddCurv:0,velocity:o.velocity}}s=o.velocity,e-=h,a=0,i++}}control(t,e,n,i,a=!1){const o=this.path.poses,[r,l,c]=this.findNextIndex(t.pos);this.nextIndex=r;const h=o[r-1],d=o[r];let u=0,p=0,m=0;if(r>=o.length-1&&l>=1)p=1;else{const t=4,o=.5,r=.5,f=.5,g=(n-this.prevVelocity)/i,y=d.pos.distanceTo(h.pos),v=t*(Math.sqrt(2*d.acceleration*y*Math.clamp(l,0,1)+h.velocity*h.velocity)-n)+o*(d.acceleration-g)+r*d.acceleration,E=this.prevAccel*(1-f)+v*f;E>0?u=Math.min(E/s.a.MAX_GAS_ACCEL,1):p=Math.min(-E/s.a.MAX_BRAKE_DECEL,1),this.prevVelocity=n;const x=h.curv+(d.curv-h.curv)*l,T=Math.atan(x*s.a.WHEEL_BASE)-e;if(m=Math.clamp(T/i/s.a.MAX_STEER_SPEED,-1,1),a){const t=.1,e=Math.wrapAngle(h.rot+Math.wrapAngle(d.rot-h.rot)*l),n=new THREE.Vector2(c.x-s.a.REAR_AXLE_POS*Math.cos(e),c.y-s.a.REAR_AXLE_POS*Math.sin(e));Math.abs(Math.wrapAngle(e-this.car.rotation))>.5&&console.log(\"wut\"),this.car.rotation+=t*Math.wrapAngle(e-this.car.rotation),this.car.position=this.car.position.clone().multiplyScalar(1-t).add(n.multiplyScalar(t))}}return{gas:u,brake:p,steer:m}}findNextIndex(t){const e=this.path.poses,n=Math.max(0,this.nextIndex-20),i=Math.min(e.length-1,this.nextIndex+20);let a=t.distanceToSquared(e[n].pos),s=n;for(let o=n+1;o<i;o++){const n=t.distanceToSquared(e[o].pos);n<a&&(a=n,s=o)}if(s==e.length-1){const[n,i]=l(t,e[s-1].pos,e[s].pos);return[s,i,n]}if(0==s){const[n,i]=l(t,e[s].pos,e[s+1].pos);return[s+1,i,n]}{const[n,i]=l(t,e[s-1].pos,e[s].pos),[a,o]=l(t,e[s].pos,e[s+1].pos);return t.distanceToSquared(n)<t.distanceToSquared(a)?[s,i,n]:[s+1,o,a]}}}function l(t,e,n){const i=e.distanceToSquared(n),a=t.clone().sub(e).dot(n.clone().sub(e))/i;return[n.clone().sub(e).multiplyScalar(a).add(e),a]}class c{constructor(){this.carKeys={forward:!1,backward:!1,left:!1,right:!1,brake:!1},document.addEventListener(\"keydown\",t=>{switch(t.key){case\"w\":case\"W\":this.carKeys.forward=!0;break;case\"s\":case\"S\":this.carKeys.backward=!0;break;case\"a\":case\"A\":this.carKeys.left=!0;break;case\"d\":case\"D\":this.carKeys.right=!0;break;case\" \":this.carKeys.brake=!0}}),document.addEventListener(\"keyup\",t=>{switch(t.key){case\"w\":case\"W\":this.carKeys.forward=!1;break;case\"s\":case\"S\":this.carKeys.backward=!1;break;case\"a\":case\"A\":this.carKeys.left=!1;break;case\"d\":case\"D\":this.carKeys.right=!1;break;case\" \":this.carKeys.brake=!1}})}control(){let t=0,e=0,n=0;return this.carKeys.forward&&(t+=1),this.carKeys.backward&&(t-=1),this.carKeys.left&&(n-=1),this.carKeys.right&&(n+=1),this.carKeys.brake&&(e+=1),{gas:t,brake:e,steer:n}}}class h extends THREE.Object3D{constructor(t){super(),this.geolocation=t,this.tilesGroup=null;const e=this.tileSizeInMeters(),n=new THREE.GridHelper(4*h.HALF_NUM_TILES*e,4*h.HALF_NUM_TILES,3355443,3355443);n.renderOrder=-1,n.material.depthTest=!1,n.position.add(new THREE.Vector3(-e/2,0,-e/2)),this.add(n),this.drawTiles()}static geoToWorld(t){const e=t[0]*Math.PI/180;return[(t[1]+180)/360*256,(1-Math.log(Math.tan(e)+1/Math.cos(e))/Math.PI)/2*256]}static worldToTile(t){return[Math.floor(t[0]*h.SCALE/256),Math.floor(t[1]*h.SCALE/256)]}drawTiles(){null!=this.tileGroup&&this.remove(this.tilesGroup),this.tileGroup=new THREE.Group;const t=h.worldToTile(h.geoToWorld(this.geolocation)),e=this.tileSizeInMeters();for(let n=-h.HALF_NUM_TILES;n<h.HALF_NUM_TILES;n++)for(let i=-h.HALF_NUM_TILES;i<h.HALF_NUM_TILES;i++){const a=(new THREE.TextureLoader).load(`https://khms0.google.com/kh/v=748?x=${t[0]+n}&y=${t[1]+i}&z=${h.ZOOM}`);a.anisotropy=16;const s=new THREE.PlaneBufferGeometry(e,e),o=new THREE.MeshBasicMaterial({map:a,color:16777215}),r=new THREE.Mesh(s,o);r.rotation.x=-Math.PI/2,r.position.x=n*e,r.position.z=i*e,this.tileGroup.add(r)}this.add(this.tileGroup)}tileSizeInMeters(){return 2*Math.PI*h.EARTH_RADIUS*Math.cos(this.geolocation[0]*Math.PI/180)/Math.pow(2,h.ZOOM)}}h.EARTH_RADIUS=6378137,h.TILE_PIXELS=256,h.ZOOM=20,h.SCALE=1<<h.ZOOM,h.HALF_NUM_TILES=20;class d extends THREE.Object3D{constructor(t){super(),this.car=t;const e=new THREE.Mesh(new THREE.PlaneGeometry(2*s.a.HALF_CAR_LENGTH,2*s.a.HALF_CAR_WIDTH),new THREE.MeshBasicMaterial({color:33023,depthTest:!1,transparent:!0,opacity:.5}));e.rotation.x=-Math.PI/2,this.add(e);const n=new THREE.PlaneGeometry(2*s.a.HALF_WHEEL_LENGTH,2*s.a.HALF_WHEEL_WIDTH),i=new THREE.MeshBasicMaterial({color:16744448,depthTest:!1,transparent:!0,opacity:.7});this.lfWheel=new THREE.Mesh(n,i),this.lfWheel.renderOrder=1,this.lfWheel.position.set(s.a.FRONT_AXLE_POS,0,s.a.WHEEL_LATERAL_POS),this.lfWheel.rotation.x=-Math.PI/2,this.add(this.lfWheel),this.rfWheel=new THREE.Mesh(n,i),this.rfWheel.renderOrder=1,this.rfWheel.position.set(s.a.FRONT_AXLE_POS,0,-s.a.WHEEL_LATERAL_POS),this.rfWheel.rotation.x=-Math.PI/2,this.add(this.rfWheel);const a=new THREE.Mesh(n,i);a.renderOrder=1,a.position.set(s.a.REAR_AXLE_POS,0,s.a.WHEEL_LATERAL_POS),a.rotation.x=-Math.PI/2,this.add(a);const o=new THREE.Mesh(n,i);o.renderOrder=1,o.position.set(s.a.REAR_AXLE_POS,0,-s.a.WHEEL_LATERAL_POS),o.rotation.x=-Math.PI/2,this.add(o)}updateMatrix(){this.updateCar(),super.updateMatrix()}updateCar(){const t=this.car.position;this.position.set(t.x,0,t.y),this.rotation.y=-this.car.rotation;const e=this.car.wheelAngle;this.lfWheel.rotation.z=-e,this.rfWheel.rotation.z=-e}}var u=n(4);const p=new THREE.Plane(new THREE.Vector3(0,1,0));class m{constructor(t,e,n){this.canvas=t,this.camera=e,this.raycaster=new THREE.Raycaster,this.mouse=new THREE.Vector2,this.dragOffset=new THREE.Vector3,this.draggingPoint=null,this.pointIndex=0,this.centerlineGeometry=new THREE.Geometry,this.leftBoundaryGeometry=new THREE.Geometry,this.rightBoundaryGeometry=new THREE.Geometry,this.points=[],this.enabled=!1,this.group=new THREE.Group,this.pointsGroup=new THREE.Group,this.group.add(this.pointsGroup),n.add(this.group),this.lanePath=new u.a,this.mouseDown=this.mouseDown.bind(this),this.mouseMove=this.mouseMove.bind(this),this.mouseUp=this.mouseUp.bind(this),t.addEventListener(\"mousedown\",this.mouseDown),t.addEventListener(\"mousemove\",this.mouseMove),t.addEventListener(\"mouseup\",this.mouseUp),t.addEventListener(\"contextmenu\",t=>this.enabled&&t.preventDefault());const i=document.getElementById(\"editor-clear-options\");document.getElementById(\"editor-clear\").addEventListener(\"click\",t=>{t.stopPropagation(),i.classList.toggle(\"is-hidden\")}),document.addEventListener(\"click\",()=>i.classList.add(\"is-hidden\")),this.centerlineObject=new THREE.Mesh(new THREE.Geometry,new MeshLineMaterial({color:new THREE.Color(16512),lineWidth:.2,depthTest:!1,transparent:!0,opacity:.7,resolution:new THREE.Vector2(this.canvas.clientWidth,this.canvas.clientHeight)})),this.centerlineObject.rotation.x=Math.PI/2,this.centerlineObject.renderOrder=1,this.group.add(this.centerlineObject),this.leftBoundaryObject=new THREE.Mesh(new THREE.Geometry,new MeshLineMaterial({color:new THREE.Color(16744448),lineWidth:.15,depthTest:!1,transparent:!0,opacity:.7,resolution:new THREE.Vector2(this.canvas.clientWidth,this.canvas.clientHeight)})),this.leftBoundaryObject.rotation.x=Math.PI/2,this.leftBoundaryObject.renderOrder=1,this.group.add(this.leftBoundaryObject),this.rightBoundaryObject=new THREE.Mesh(new THREE.Geometry,new MeshLineMaterial({color:new THREE.Color(16744448),lineWidth:.15,depthTest:!1,transparent:!0,opacity:.7,resolution:new THREE.Vector2(this.canvas.clientWidth,this.canvas.clientHeight)})),this.rightBoundaryObject.rotation.x=Math.PI/2,this.rightBoundaryObject.renderOrder=1,this.group.add(this.rightBoundaryObject)}redraw(){this.centerlineGeometry.setFromPoints(this.lanePath.centerline);const t=new MeshLine;t.setGeometry(this.centerlineGeometry),this.centerlineObject.geometry=t.geometry,this.leftBoundaryGeometry.setFromPoints(this.lanePath.leftBoundary);const e=new MeshLine;e.setGeometry(this.leftBoundaryGeometry),this.leftBoundaryObject.geometry=e.geometry,this.rightBoundaryGeometry.setFromPoints(this.lanePath.rightBoundary);const n=new MeshLine;n.setGeometry(this.rightBoundaryGeometry),this.rightBoundaryObject.geometry=n.geometry}addPoint(t){const e=new THREE.Mesh(new THREE.CircleGeometry(.4,32),new THREE.MeshBasicMaterial({color:33023,depthTest:!1,transparent:!0,opacity:.7}));return e.rotation.x=-Math.PI/2,e.position.set(t.x,0,t.y),e.userData={index:this.pointIndex++},this.pointsGroup.add(e),this.points.push(e),this.lanePath.addAnchor(t),e}updatePoint(t,e){t.position.copy(e),this.lanePath.updateAnchor(t.userData.index,new THREE.Vector2(e.x,e.z))}clearPoints(){this.centerlineObject.geometry=new THREE.Geometry,this.group.remove(this.pointsGroup),this.pointsGroup=new THREE.Group,this.points=[],this.pointIndex=0,this.lanePath=new u.a}loadPoints(t){this.clearPoints(),t.forEach(t=>this.addPoint(new THREE.Vector2(t.x,t.y))),this.redraw()}mouseDown(t){if(!this.enabled||0!=t.button)return;this.mouse.x=t.offsetX/this.canvas.clientWidth*2-1,this.mouse.y=-t.offsetY/this.canvas.clientHeight*2+1,this.raycaster.setFromCamera(this.mouse,this.camera);const e=this.raycaster.intersectObjects(this.points)[0];if(e)this.draggingPoint=e.object,this.dragOffset.copy(e.object.position).sub(e.point),t.stopImmediatePropagation();else{const t=this.raycaster.ray.intersectPlane(p);null!=t&&(this.addPoint(new THREE.Vector2(t.x,t.z)),this.redraw())}}mouseMove(t){if(!this.enabled||null==this.draggingPoint)return;this.mouse.x=t.offsetX/this.canvas.clientWidth*2-1,this.mouse.y=-t.offsetY/this.canvas.clientHeight*2+1,this.raycaster.setFromCamera(this.mouse,this.camera);const e=this.raycaster.ray.intersectPlane(p);null!=e&&(this.updatePoint(this.draggingPoint,e.add(this.dragOffset)),this.redraw())}mouseUp(t){this.enabled&&0==t.button&&(this.draggingPoint=null)}}const f=function(t,e){var n,i,a,s,o;this.object=t,this.domElement=void 0!==e?e:document,this.enabled=!0,this.target=new THREE.Vector3,this.minDistance=0,this.maxDistance=1/0,this.minZoom=0,this.maxZoom=1/0,this.minPolarAngle=0,this.maxPolarAngle=Math.PI,this.minAzimuthAngle=-1/0,this.maxAzimuthAngle=1/0,this.enableDamping=!1,this.dampingFactor=.25,this.enableZoom=!0,this.zoomSpeed=1,this.enableRotate=!0,this.rotateSpeed=1,this.enablePan=!0,this.keyPanSpeed=7,this.autoRotate=!1,this.autoRotateSpeed=2,this.enableKeys=!0,this.keys={LEFT:37,UP:38,RIGHT:39,BOTTOM:40},this.mouseButtons={ORBIT:THREE.MOUSE.LEFT,ZOOM:THREE.MOUSE.MIDDLE,PAN:THREE.MOUSE.RIGHT},this.target0=this.target.clone(),this.position0=this.object.position.clone(),this.zoom0=this.object.zoom,this.getPolarAngle=function(){return m.phi},this.getAzimuthalAngle=function(){return m.theta},this.saveState=function(){r.target0.copy(r.target),r.position0.copy(r.object.position),r.zoom0=r.object.zoom},this.reset=function(){r.target.copy(r.target0),r.object.position.copy(r.position0),r.object.zoom=r.zoom0,r.object.updateProjectionMatrix(),r.dispatchEvent(l),r.update(),u=d.NONE},this.rotateLeft=function(t){A(t)},this.update=(n=new THREE.Vector3,i=(new THREE.Quaternion).setFromUnitVectors(t.up,new THREE.Vector3(0,1,0)),a=i.clone().inverse(),s=new THREE.Vector3,o=new THREE.Quaternion,function(){var t=r.object.position;return n.copy(t).sub(r.target),n.applyQuaternion(i),m.setFromVector3(n),r.autoRotate&&u===d.NONE&&A(2*Math.PI/60/60*r.autoRotateSpeed),m.theta+=f.theta,m.phi+=f.phi,m.theta=Math.max(r.minAzimuthAngle,Math.min(r.maxAzimuthAngle,m.theta)),m.phi=Math.max(r.minPolarAngle,Math.min(r.maxPolarAngle,m.phi)),m.makeSafe(),m.radius*=g,m.radius=Math.max(r.minDistance,Math.min(r.maxDistance,m.radius)),r.target.add(y),n.setFromSpherical(m),n.applyQuaternion(a),t.copy(r.target).add(n),r.object.lookAt(r.target),!0===r.enableDamping?(f.theta*=1-r.dampingFactor,f.phi*=1-r.dampingFactor):f.set(0,0,0),g=1,y.set(0,0,0),!!(v||s.distanceToSquared(r.object.position)>p||8*(1-o.dot(r.object.quaternion))>p)&&(r.dispatchEvent(l),s.copy(r.object.position),o.copy(r.object.quaternion),v=!1,!0)}),this.dispose=function(){r.domElement.removeEventListener(\"contextmenu\",j,!1),r.domElement.removeEventListener(\"mousedown\",F,!1),r.domElement.removeEventListener(\"wheel\",z,!1),r.domElement.removeEventListener(\"touchstart\",B,!1),r.domElement.removeEventListener(\"touchend\",W,!1),r.domElement.removeEventListener(\"touchmove\",U,!1),document.removeEventListener(\"mousemove\",V,!1),document.removeEventListener(\"mouseup\",N,!1),window.removeEventListener(\"keydown\",k,!1)};var r=this,l={type:\"change\"},c={type:\"start\"},h={type:\"end\"},d={NONE:-1,ROTATE:0,DOLLY:1,PAN:2,TOUCH_ROTATE:3,TOUCH_DOLLY:4,TOUCH_PAN:5},u=d.NONE,p=1e-6,m=new THREE.Spherical,f=new THREE.Spherical,g=1,y=new THREE.Vector3,v=!1,E=new THREE.Vector2,x=new THREE.Vector2,T=new THREE.Vector2,S=new THREE.Vector2,P=new THREE.Vector2,C=new THREE.Vector2,b=new THREE.Vector2,_=new THREE.Vector2,w=new THREE.Vector2;function R(){return Math.pow(.95,r.zoomSpeed)}function A(t){f.theta-=t}function L(t){f.phi-=t}var I,M=(I=new THREE.Vector3,function(t,e){I.setFromMatrixColumn(e,0),I.multiplyScalar(-t),y.add(I)}),G=function(){var t=new THREE.Vector3;return function(e,n){t.setFromMatrixColumn(n,1),t.multiplyScalar(e),y.add(t)}}(),O=function(){var t=new THREE.Vector3;return function(e,n){var i=r.domElement===document?r.domElement.body:r.domElement;if(r.object.isPerspectiveCamera){var a=r.object.position;t.copy(a).sub(r.target);var s=t.length();s*=Math.tan(r.object.fov/2*Math.PI/180),M(2*e*s/i.clientHeight,r.object.matrix),G(2*n*s/i.clientHeight,r.object.matrix)}else r.object.isOrthographicCamera?(M(e*(r.object.right-r.object.left)/r.object.zoom/i.clientWidth,r.object.matrix),G(n*(r.object.top-r.object.bottom)/r.object.zoom/i.clientHeight,r.object.matrix)):(console.warn(\"WARNING: OrbitControls.js encountered an unknown camera type - pan disabled.\"),r.enablePan=!1)}}();function H(t){r.object.isPerspectiveCamera?g/=t:r.object.isOrthographicCamera?(r.object.zoom=Math.max(r.minZoom,Math.min(r.maxZoom,r.object.zoom*t)),r.object.updateProjectionMatrix(),v=!0):(console.warn(\"WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled.\"),r.enableZoom=!1)}function D(t){r.object.isPerspectiveCamera?g*=t:r.object.isOrthographicCamera?(r.object.zoom=Math.max(r.minZoom,Math.min(r.maxZoom,r.object.zoom/t)),r.object.updateProjectionMatrix(),v=!0):(console.warn(\"WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled.\"),r.enableZoom=!1)}function F(t){if(!1!==r.enabled){switch(t.preventDefault(),t.button){case r.mouseButtons.ORBIT:if(!1===r.enableRotate)return;!function(t){E.set(t.clientX,t.clientY)}(t),u=d.ROTATE;break;case r.mouseButtons.ZOOM:if(!1===r.enableZoom)return;!function(t){b.set(t.clientX,t.clientY)}(t),u=d.DOLLY;break;case r.mouseButtons.PAN:if(!1===r.enablePan)return;!function(t){S.set(t.clientX,t.clientY)}(t),u=d.PAN}u!==d.NONE&&(document.addEventListener(\"mousemove\",V,!1),document.addEventListener(\"mouseup\",N,!1),r.dispatchEvent(c))}}function V(t){if(!1!==r.enabled)switch(t.preventDefault(),u){case d.ROTATE:if(!1===r.enableRotate)return;!function(t){x.set(t.clientX,t.clientY),T.subVectors(x,E);var e=r.domElement===document?r.domElement.body:r.domElement;A(2*Math.PI*T.x/e.clientWidth*r.rotateSpeed),L(2*Math.PI*T.y/e.clientHeight*r.rotateSpeed),E.copy(x),r.update()}(t);break;case d.DOLLY:if(!1===r.enableZoom)return;!function(t){_.set(t.clientX,t.clientY),w.subVectors(_,b),w.y>0?H(R()):w.y<0&&D(R()),b.copy(_),r.update()}(t);break;case d.PAN:if(!1===r.enablePan)return;!function(t){P.set(t.clientX,t.clientY),C.subVectors(P,S),O(C.x,C.y),S.copy(P),r.update()}(t)}}function N(t){!1!==r.enabled&&(document.removeEventListener(\"mousemove\",V,!1),document.removeEventListener(\"mouseup\",N,!1),r.dispatchEvent(h),u=d.NONE)}function z(t){!1===r.enabled||!1===r.enableZoom||u!==d.NONE&&u!==d.ROTATE||(t.preventDefault(),t.stopPropagation(),function(t){t.deltaY<0?D(R()):t.deltaY>0&&H(R()),r.update()}(t),r.dispatchEvent(c),r.dispatchEvent(h))}function k(t){!1!==r.enabled&&!1!==r.enableKeys&&!1!==r.enablePan&&function(t){switch(t.keyCode){case r.keys.UP:O(0,r.keyPanSpeed),r.update();break;case r.keys.BOTTOM:O(0,-r.keyPanSpeed),r.update();break;case r.keys.LEFT:O(r.keyPanSpeed,0),r.update();break;case r.keys.RIGHT:O(-r.keyPanSpeed,0),r.update()}}(t)}function B(t){if(!1!==r.enabled){switch(t.touches.length){case 1:if(!1===r.enableRotate)return;!function(t){E.set(t.touches[0].pageX,t.touches[0].pageY)}(t),u=d.TOUCH_ROTATE;break;case 2:if(!1===r.enableZoom)return;!function(t){var e=t.touches[0].pageX-t.touches[1].pageX,n=t.touches[0].pageY-t.touches[1].pageY,i=Math.sqrt(e*e+n*n);b.set(0,i)}(t),u=d.TOUCH_DOLLY;break;case 3:if(!1===r.enablePan)return;!function(t){S.set(t.touches[0].pageX,t.touches[0].pageY)}(t),u=d.TOUCH_PAN;break;default:u=d.NONE}u!==d.NONE&&r.dispatchEvent(c)}}function U(t){if(!1!==r.enabled)switch(t.preventDefault(),t.stopPropagation(),t.touches.length){case 1:if(!1===r.enableRotate)return;if(u!==d.TOUCH_ROTATE)return;!function(t){x.set(t.touches[0].pageX,t.touches[0].pageY),T.subVectors(x,E);var e=r.domElement===document?r.domElement.body:r.domElement;A(2*Math.PI*T.x/e.clientWidth*r.rotateSpeed),L(2*Math.PI*T.y/e.clientHeight*r.rotateSpeed),E.copy(x),r.update()}(t);break;case 2:if(!1===r.enableZoom)return;if(u!==d.TOUCH_DOLLY)return;!function(t){var e=t.touches[0].pageX-t.touches[1].pageX,n=t.touches[0].pageY-t.touches[1].pageY,i=Math.sqrt(e*e+n*n);_.set(0,i),w.subVectors(_,b),w.y>0?D(R()):w.y<0&&H(R()),b.copy(_),r.update()}(t);break;case 3:if(!1===r.enablePan)return;if(u!==d.TOUCH_PAN)return;!function(t){P.set(t.touches[0].pageX,t.touches[0].pageY),C.subVectors(P,S),O(C.x,C.y),S.copy(P),r.update()}(t);break;default:u=d.NONE}}function W(t){!1!==r.enabled&&(r.dispatchEvent(h),u=d.NONE)}function j(t){!1!==r.enabled&&t.preventDefault()}r.domElement.addEventListener(\"contextmenu\",j,!1),r.domElement.addEventListener(\"mousedown\",F,!1),r.domElement.addEventListener(\"wheel\",z,!1),r.domElement.addEventListener(\"touchstart\",B,!1),r.domElement.addEventListener(\"touchend\",W,!1),r.domElement.addEventListener(\"touchmove\",U,!1),window.addEventListener(\"keydown\",k,!1),this.update()};(f.prototype=Object.create(THREE.EventDispatcher.prototype)).constructor=f,Object.defineProperties(f.prototype,{center:{get:function(){return console.warn(\"OrbitControls: .center has been renamed to .target\"),this.target}},noZoom:{get:function(){return console.warn(\"OrbitControls: .noZoom has been deprecated. Use .enableZoom instead.\"),!this.enableZoom},set:function(t){console.warn(\"OrbitControls: .noZoom has been deprecated. Use .enableZoom instead.\"),this.enableZoom=!t}},noRotate:{get:function(){return console.warn(\"OrbitControls: .noRotate has been deprecated. Use .enableRotate instead.\"),!this.enableRotate},set:function(t){console.warn(\"OrbitControls: .noRotate has been deprecated. Use .enableRotate instead.\"),this.enableRotate=!t}},noPan:{get:function(){return console.warn(\"OrbitControls: .noPan has been deprecated. Use .enablePan instead.\"),!this.enablePan},set:function(t){console.warn(\"OrbitControls: .noPan has been deprecated. Use .enablePan instead.\"),this.enablePan=!t}},noKeys:{get:function(){return console.warn(\"OrbitControls: .noKeys has been deprecated. Use .enableKeys instead.\"),!this.enableKeys},set:function(t){console.warn(\"OrbitControls: .noKeys has been deprecated. Use .enableKeys instead.\"),this.enableKeys=!t}},staticMoving:{get:function(){return console.warn(\"OrbitControls: .staticMoving has been deprecated. Use .enableDamping instead.\"),!this.enableDamping},set:function(t){console.warn(\"OrbitControls: .staticMoving has been deprecated. Use .enableDamping instead.\"),this.enableDamping=!t}},dynamicDampingFactor:{get:function(){return console.warn(\"OrbitControls: .dynamicDampingFactor has been renamed. Use .dampingFactor instead.\"),this.dampingFactor},set:function(t){console.warn(\"OrbitControls: .dynamicDampingFactor has been renamed. Use .dampingFactor instead.\"),this.dampingFactor=t}}});var g=f;const y=new THREE.Plane(new THREE.Vector3(0,1,0));let v=!1;class E{constructor(t,e){this.domElement=t,this.camera=e,this.enablePanning=!1,this.enabled=!0,this.mouseDown=this.mouseDown.bind(this),this.mouseMove=this.mouseMove.bind(this),this.mouseUp=this.mouseUp.bind(this),this.wheel=this.wheel.bind(this),this.domElement.addEventListener(\"mousedown\",this.mouseDown),this.domElement.addEventListener(\"mousemove\",this.mouseMove),this.domElement.addEventListener(\"mouseup\",this.mouseUp),this.domElement.addEventListener(\"wheel\",this.wheel)}reset(t){const e=new THREE.Vector3(0,0,-1);e.applyQuaternion(t.quaternion);const n=new THREE.Ray(t.position,e).intersectPlane(y);n?this.camera.position.set(n.x,50,n.z):this.camera.position.y=50,this.camera.rotation.set(-Math.PI/2,0,0)}mouseDown(t){this.enabled&&this.enablePanning&&2==t.button&&(v=!0)}mouseMove(t){if(v){const e=2*this.camera.position.y*Math.tan(this.camera.fov/2*Math.PI/180)/this.domElement.clientHeight;this.camera.position.x-=e*t.movementX,this.camera.position.z-=e*t.movementY}}mouseUp(t){2==t.button&&(v=!1)}wheel(t){this.enabled&&(t.preventDefault(),this.camera.position.y*=Math.pow(.995,-t.deltaY))}}const x=2.23694,T=3.28084;class S{constructor(t){this.car=t,this.units=\"metric\",\"complete\"==document.readyState?this.fetchDomElements.call(this):document.addEventListener(\"readystatechange\",t=>{\"complete\"==t.target.readyState&&this.fetchDomElements.call(this)})}fetchDomElements(){this.wheelDom=document.getElementById(\"wheel\"),this.wheelPieDom=document.getElementById(\"wheel-pie\"),this.wheelPieLeftDom=document.getElementById(\"wheel-pie-left\"),this.wheelPieRightDom=document.getElementById(\"wheel-pie-right\"),this.gearDom=document.getElementById(\"gear\"),this.gasDom=document.getElementById(\"gas\"),this.brakeDom=document.getElementById(\"brake\"),this.speedDom=document.getElementById(\"speed\"),this.stationDom=document.getElementById(\"station\"),this.latitudeDom=document.getElementById(\"latitude\"),this.planTimeDom=document.getElementById(\"plan-time\"),this.elapsedTimeDom=document.getElementById(\"elapsed-time\"),this.speedUnitsDom=document.getElementById(\"speed-units\"),this.stationUnitsDom=document.getElementById(\"station-units\"),this.latitudeUnitsDom=document.getElementById(\"latitude-units\"),[this.speedUnitsDom,this.stationUnitsDom,this.latitudeUnitsDom].forEach(t=>{t.addEventListener(\"click\",t=>{this.toggleUnits()})})}toggleUnits(){let t,e;\"metric\"==this.units?(this.units=\"imperial\",t=\"mph\",e=\"feet\"):(this.units=\"metric\",t=\"m/s\",e=\"meters\"),this.speedUnitsDom.innerHTML=t,this.stationUnitsDom.innerHTML=e,this.latitudeUnitsDom.innerHTML=e}update(t,e,n,i,a,o){if(!this.wheelDom)return;\"imperial\"==this.units&&(e*=x,n=null!==n?n*T:null,i=null!==i?i*T:null);const r=Math.clamp(this.car.wheelAngle/s.a.MAX_WHEEL_ANGLE*.95,-1,1);this.wheelDom.style.transform=`rotate(${r}turn)`,r>=0?(this.wheelPieRightDom.style.transform=`rotate(${r}turn)`,r<=.5?(this.wheelPieDom.style.clipPath=\"inset(0 0 0 50%)\",this.wheelPieLeftDom.style.transform=\"rotate(0)\"):(this.wheelPieDom.style.clipPath=\"inset(0 0 0 0)\",this.wheelPieLeftDom.style.transform=\"rotate(0.5turn)\")):(this.wheelPieRightDom.style.transform=`rotate(${.5+r}turn)`,r>=-.5?(this.wheelPieDom.style.clipPath=\"inset(0 50% 0 0)\",this.wheelPieLeftDom.style.transform=\"rotate(0.5turn)\"):(this.wheelPieDom.style.clipPath=\"inset(0 0 0 0)\",this.wheelPieLeftDom.style.transform=\"rotate(0)\")),this.gearDom.innerText=t.gas<0?\"R\":\"D\",this.brakeDom.style.clipPath=`inset(50% 50% 0 ${50-25*t.brake}%)`,this.gasDom.style.clipPath=`inset(50% ${50-25*Math.abs(t.gas)}% 0 50%)`,this.speedDom.innerHTML=e.toFixed(1),this.stationDom.innerHTML=null!==n?n.toFixed(1):\"&mdash;\",this.latitudeDom.innerHTML=null!==i?i.toFixed(2):\"&mdash;\",this.planTimeDom.innerHTML=null!==o?(1e3*o).toFixed(0):\"&mdash;\";let l=Math.floor(a/60),c=a%60;0==l?this.elapsedTimeDom.innerHTML=c.toFixed(1):(c=c<10?\"0\"+c.toFixed(1):c.toFixed(1),this.elapsedTimeDom.innerHTML=`${l}:${c}`)}}n(2);var P=class{constructor(t,e){const n=t.sampleStations(e,10,10),i=new Array(10),a=Math.floor(9.5);for(let t=0;t<10;t++){const e=n[t],s=i[t]=new Array(19);for(let t=0;t<19;t++){const n=(t-a)/a*3.7/2,i=e.rot,o=THREE.Vector2.fromAngle(i+Math.PI/2).multiplyScalar(n).add(e.pos),r=0==e.curv?0:1/(1/e.curv-n);s[t]={pos:o,rot:i,curv:r}}}this.lattice=i}},C=(n(6),n(5));class b{constructor(t){this.samples=new Array(t),this.numSamples=0,this.nextIndex=0,this.average=null}addSample(t){this.samples[this.nextIndex++]=t,this.nextIndex=this.nextIndex%this.samples.length,this.numSamples=Math.min(this.numSamples+1,this.samples.length);const e=2/(this.numSamples+1);let n=this.nextIndex%this.numSamples,i=this.samples[n];for(let t=1;t<this.numSamples;t++)n=(n+1)%this.numSamples,i=this.samples[n]*e+i*(1-e);this.average=i}}const _=\"dashPathPlannerConfig\",w={lattice:{numStations:10,numLatitudes:11,stationConnectivity:3,latitudeConnectivity:5},dCurvatureMax:s.a.MAX_STEER_SPEED/s.a.WHEEL_BASE,rearAxleToCenter:-s.a.REAR_AXLE_POS},R={spatialHorizon:100,centerlineStationInterval:.5,xyGridCellSize:.1,slGridCellSize:.05,gridMargin:10,pathSamplingStep:.5,cubicPathPenalty:10,lethalDilationS:s.a.HALF_CAR_LENGTH+1,hazardDilationS:12,lethalDilationL:s.a.HALF_CAR_WIDTH+.25,hazardDilationL:.5,obstacleHazardCost:3,laneWidth:3.7,laneShoulderCost:1,laneShoulderLatitude:1.85-s.a.HALF_CAR_WIDTH,laneCostSlope:5,stationReachDiscount:70,extraTimePenalty:64,hysteresisDiscount:40,speedLimit:20,speedLimitPenalty:2,hardAccelerationPenalty:6,hardDecelerationPenalty:6,lateralAccelerationLimit:3,softLateralAccelerationPenalty:4,linearLateralAccelerationPenalty:4,accelerationChangePenalty:2};class A{constructor(){this._config=Object.assign({},R),this.showConfigBox=document.getElementById(\"show-config-box\"),this.configBox=document.getElementById(\"config-box-content\"),this.configForm=document.getElementById(\"config-form\"),this._setUpButtons();let t={};try{t=JSON.parse(window.localStorage.getItem(_))||{}}catch(t){}for(const e of Object.keys(this._config).sort())void 0!==t[e]&&(this._config[e]=t[e]),this.configForm.appendChild(this._createConfigField(e,this._config[e]))}get config(){return Object.assign({},this._config,w)}_setUpButtons(){document.getElementById(\"show-config-button\").addEventListener(\"click\",t=>{this.showConfigBox.classList.add(\"is-hidden\"),this.configBox.classList.remove(\"is-hidden\")}),document.getElementById(\"hide-config-button\").addEventListener(\"click\",t=>{this.showConfigBox.classList.remove(\"is-hidden\"),this.configBox.classList.add(\"is-hidden\")}),document.getElementById(\"save-config-button\").addEventListener(\"click\",this._saveConfigFields.bind(this)),document.getElementById(\"restore-defaults-config-button\").addEventListener(\"click\",this._restoreDefaults.bind(this))}_createConfigField(t,e){const n=`<div class=\"field is-horizontal\">\\n          <div class=\"field-label is-small\" style=\"flex-grow: 100;\">\\n              <label class=\"label has-text-grey-light\" for=\"config-field-${t}\">${t}</label>\\n          </div>\\n          <div class=\"field-body\">\\n              <div class=\"field\">\\n                  <div class=\"control\" style=\"margin-right: 16px;\">\\n                      <input id=\"config-field-${t}\" name=\"${t}\" class=\"input is-small ${e!=R[t]?\"is-danger\":\"\"}\" type=\"text\" style=\"width: 60px; border-width: 2px;\" value=\"${e}\" />\\n                  </div>\\n              </div>\\n          </div>\\n      </div>`,i=document.createElement(\"template\");return i.innerHTML=n,i.content.firstChild}_saveConfigFields(){const t=new FormData(this.configForm);for(const[e,n]of t.entries()){this._config[e]=Number.parseFloat(n);const t=document.getElementById(`config-field-${e}`);n==R[e]?t.classList.remove(\"is-danger\"):t.classList.add(\"is-danger\")}try{window.localStorage.setItem(_,JSON.stringify(this._config))}catch(t){}}_restoreDefaults(){this._config=R;try{window.localStorage.removeItem(_)}catch(t){}for(;this.configForm.firstChild;)this.configForm.removeChild(this.configForm.firstChild);for(const t of Object.keys(this._config).sort())this.configForm.appendChild(this._createConfigField(t,this._config[t]))}}const L=1/60;document.addEventListener(\"DOMContentLoaded\",t=>{window.simulator=new class{constructor(t,e){this.geolocation=t,this.pathPlannerWorker=new Worker(\"dist/PathPlannerWorker.js\"),this.pathPlannerWorker.onmessage=this.receivePlannedPath.bind(this),this.pathPlannerConfigEditor=new A,this.physics=new a,this.car=this.physics.createCar(),this.renderer=new THREE.WebGLRenderer,this.renderer.setPixelRatio(window.devicePixelRatio),this.renderer.setSize(e.clientWidth,e.clientHeight),this.renderer.shadowMap.enabled=!0,e.appendChild(this.renderer.domElement),this.lastPlanParams=null,this.renderer.context.canvas.addEventListener(\"webglcontextlost\",t=>{console.log(\"Simulator: webgl context lost\"),console.log(t),console.log(this.lastPlanParams)}),this._setUpCameras(this.renderer.domElement),this.scene=new THREE.Scene,this.sceneFog=new THREE.FogExp2(1118481,.0025),this.scene.fog=this.sceneFog,this.scene.background=new THREE.Color(1118481),this.editor=new m(this.renderer.domElement,this.editorCamera,this.scene);const n=new h(this.geolocation);this.scene.add(n);const i=new d(this.car);this.scene.add(i),this.manualCarController=new c,this.autonomousCarController=null,this.dashboard=new S(this.car),this.plannerReady=!1,this.plannerReset=!1,this.plannerEnabled=!1,this.plannedPathGroup=new THREE.Group,this.scene.add(this.plannedPathGroup),this.paused=!1,this.prevTimestamp=null,this.frameCounter=0,this.fpsTime=0,this.fps=1/L,this.simulatedTime=0,this.lastPlanTime=null,this.averagePlanTime=new b(20),window.addEventListener(\"resize\",()=>{this._updateCameraAspects(e.clientWidth/e.clientHeight),this.renderer.setSize(e.clientWidth,e.clientHeight)}),this.manualModeButton=document.getElementById(\"mode-manual\"),this.manualModeButton.addEventListener(\"click\",this.enableManualMode.bind(this)),this.autonomousModeButton=document.getElementById(\"mode-autonomous\"),this.autonomousModeButton.addEventListener(\"click\",this.enableAutonomousMode.bind(this)),document.getElementById(\"editor-enable\").addEventListener(\"click\",this.enableEditor.bind(this)),document.getElementById(\"editor-save\").addEventListener(\"click\",this.finalizeEditor.bind(this)),document.getElementById(\"scenario-restart\").addEventListener(\"click\",this.restartScenario.bind(this)),this.simModeBoxes=Array.prototype.slice.call(document.getElementsByClassName(\"sim-mode-box\"),0),this.editModeBoxes=Array.prototype.slice.call(document.getElementsByClassName(\"edit-mode-box\"),0),this.fpsBox=document.getElementById(\"fps\"),this.enableManualMode(),this.changeCamera(\"chase\"),this.aroundAnchorIndex=null,this.obstacles=[],requestAnimationFrame(function t(e){if(null==this.prevTimestamp)return this.prevTimestamp=e,void requestAnimationFrame(t.bind(this));if(!this.editor.enabled||this.paused){const t=L;this.simulatedTime+=t;const e=this.car.position,n=this.car.rotation,i=this.autonomousCarController?this.autonomousCarController.control(this.car.pose,this.car.wheelAngle,this.car.velocity,t,\"autonomous\"==this.carControllerMode):{steer:0,brake:1,gas:0},a=this.manualCarController.control(this.car.pose,this.car.wheelAngle,this.car.velocity,t),s=\"autonomous\"==this.carControllerMode?i:a;this.car.update(s,t),this.physics.step(t);const o=this.car.position,r=this.car.rotation,l=this.car.rearAxlePosition,c=this.car.velocity,h={x:o.x-e.x,y:0,z:o.y-e.y};this.chaseCamera.position.add(h),this.chaseCameraControls.target.set(o.x,0,o.y),this.chaseCameraControls.rotateLeft(r-n),this.chaseCameraControls.update(),this.topDownCamera.position.setX(o.x),this.topDownCamera.position.setZ(o.y),this.topDownCamera.rotation.z=-r-Math.PI/2;let d=null,u=null;if(this.editor.lanePath.anchors.length>1){const[t,e,n]=this.editor.lanePath.stationLatitudeFromPosition(l,this.aroundAnchorIndex);this.aroundAnchorIndex=n,d=t,u=e}this.plannerReady&&this.startPlanner(this.car.pose,d),this.dashboard.update(s,c,d,u,this.simulatedTime,this.averagePlanTime.average)}this.frameCounter++,this.fpsTime+=e-this.prevTimestamp,this.fpsTime>=1e3&&(this.fps=this.frameCounter/(this.fpsTime/1e3),this.frameCounter=0,this.fpsTime=0,this.fpsBox.innerHTML=this.fps.toFixed(1)),this.renderer.render(this.scene,this.camera),this.prevTimestamp=e,requestAnimationFrame(t.bind(this))}.bind(this))}toss(){const t=this.car.pose,e=THREE.Vector2.fromAngle(t.rot),n=e.clone().multiplyScalar(50).add(new THREE.Vector2(e.y,e.x)).add(t.pos),i=new C.a(n,0,.5,.5),a=new THREE.PlaneGeometry(i.width,i.height),s=new THREE.MeshBasicMaterial({color:255,depthTest:!1,transparent:!0,opacity:.5}),o=new THREE.Mesh(a,s);o.rotation.x=-Math.PI/2,o.rotation.z=-i.rot,o.position.set(i.pos.x,0,i.pos.y),this.scene.add(o),this.obstacles.push(i)}_setUpCameras(t){this.chaseCamera=new THREE.PerspectiveCamera(45,t.clientWidth/t.clientHeight,1,1e4),this.chaseCameraControls=new g(this.chaseCamera,t),this.chaseCameraControls.maxPolarAngle=Math.PI/2.02,this.chaseCameraControls.enablePan=!1,this.chaseCameraControls.enabled=!1,this._resetChaseCamera(),this.freeCamera=new THREE.PerspectiveCamera(45,t.clientWidth/t.clientHeight,1,1e4),this.freeCameraControls=new g(this.freeCamera,t),this.freeCameraControls.maxPolarAngle=Math.PI/2.02,this.freeCameraControls.enabled=!0,this._resetFreeCamera(),this.topDownCamera=new THREE.PerspectiveCamera(45,t.clientWidth/t.clientHeight,1,1e4),this.topDownCamera.position.set(0,50,0),this.topDownCamera.lookAt(0,0,0),this.topDownControls=new E(t,this.topDownCamera),this.topDownControls.enabled=!1,this.editorCamera=new THREE.PerspectiveCamera(45,t.clientWidth/t.clientHeight,1,1e4),this.editorCamera.position.set(0,50,0),this.editorCamera.lookAt(0,0,0),this.editorCameraControls=new E(t,this.editorCamera),this.editorCameraControls.enabled=!1,this.editorCameraControls.enablePanning=!0,this.cameraButtons={},[\"free\",\"chase\",\"topDown\"].forEach(t=>{const e=document.getElementById(`camera-${t}`);e.addEventListener(\"click\",()=>this.changeCamera(t)),this.cameraButtons[t]=e})}_resetFreeCamera(){this.freeCameraControls.position0.copy(this.chaseCamera.position);const t=this.car.position;this.freeCameraControls.target0.set(t.x,0,t.y),this.freeCameraControls.reset()}_resetChaseCamera(){const t=this.car.position,e=THREE.Vector2.fromAngle(this.car.rotation).multiplyScalar(-20);this.chaseCamera.position.set(t.x+e.x,10,t.y+e.y),this.chaseCamera.lookAt(t.x,0,t.y)}_resetTopDownCamera(){this.topDownCamera.position.setY(50)}_updateCameraAspects(t){this.freeCamera.aspect=t,this.freeCamera.updateProjectionMatrix(),this.chaseCamera.aspect=t,this.chaseCamera.updateProjectionMatrix()}enableEditor(){this.editor.enabled=!0,this.previousCamera=this.camera,this.camera=this.editorCamera,this.editorCameraControls.enabled=!0,this.chaseCameraControls.enabled=!1,this.topDownControls.enabled=!1,this.freeCameraControls.enabled=!1,this.scene.fog=null,this.plannedPathGroup&&(this.plannedPathGroup.visible=!1),this.simModeBoxes.forEach(t=>t.classList.add(\"is-hidden\")),this.editModeBoxes.forEach(t=>t.classList.remove(\"is-hidden\"))}finalizeEditor(t=!0){this.editor.enabled=!1,this.editorCameraControls.enabled=!1,this.scene.fog=this.sceneFog,this.simModeBoxes.forEach(t=>t.classList.remove(\"is-hidden\")),this.editModeBoxes.forEach(t=>t.classList.add(\"is-hidden\"));const e=this.editor.lanePath.centerline,n=e[0].clone(),i=e[1].clone().sub(e[0]),a=Math.atan2(i.y,i.x);this.car.setPose(n.x,n.y,a),this.autonomousCarController=null,this.plannerRunning||(this.plannerReady=!0,this.plannerRunning=!0),this.plannerReset=!0,this.simulatedTime=0,t&&(this.camera=this.previousCamera,this.previousCamera==this.chaseCamera?this.chaseCameraControls.enabled=!0:this.previousCamera==this.topDownCamera?this.topDownControls.enabled=!0:this.previousCamera==this.freeCamera?this.freeCameraControls.enabled=!0:this.changeCamera(\"chase\")),this._resetFreeCamera(),this._resetChaseCamera(),this._resetTopDownCamera()}restartScenario(){this.editor.enabled||this.finalizeEditor(!1)}enableManualMode(){this.manualModeButton.classList.remove(\"is-outlined\"),this.manualModeButton.classList.add(\"is-selected\"),this.autonomousModeButton.classList.add(\"is-outlined\"),this.autonomousModeButton.classList.remove(\"is-selected\"),this.carControllerMode=\"manual\"}enableAutonomousMode(){this.autonomousModeButton.classList.remove(\"is-outlined\"),this.autonomousModeButton.classList.add(\"is-selected\"),this.manualModeButton.classList.add(\"is-outlined\"),this.manualModeButton.classList.remove(\"is-selected\"),this.carControllerMode=\"autonomous\"}changeCamera(t){if(!this.editor.enabled){switch(t){case\"free\":this.chaseCameraControls.enabled=!1,this.topDownControls.enabled=!1,this.freeCameraControls.enabled=!0,this.camera==this.freeCamera?this._resetFreeCamera():this.camera=this.freeCamera;break;case\"chase\":this.freeCameraControls.enabled=!1,this.topDownControls.enabled=!1,this.chaseCameraControls.enabled=!0,this.camera==this.chaseCamera?this._resetChaseCamera():this.camera=this.chaseCamera;break;case\"topDown\":this.freeCameraControls.enabled=!1,this.chaseCameraControls.enabled=!1,this.topDownControls.enabled=!0,this.camera==this.topDownCamera?this._resetTopDownCamera():this.camera=this.topDownCamera;break;default:return void console.log(`Unknown camera mode: ${t}`)}for(const e in this.cameraButtons){const n=this.cameraButtons[e].classList;e==t?(n.remove(\"is-outlined\"),n.add(\"is-selected\")):(n.add(\"is-outlined\"),n.remove(\"is-selected\"))}}}startPlanner(t,e){this.plannerReady=!1,this.lastPlanTime=performance.now();let n=t;!this.plannerReset&&this.autonomousCarController&&\"autonomous\"==this.carControllerMode&&(n=this.autonomousCarController.predictPoseAfterTime(t,this.averagePlanTime.average*this.fps*L));const i=this.plannerReset;this.plannerReset=!1,this.lastPlanParams={config:this.pathPlannerConfigEditor.config,vehiclePose:n,vehicleStation:e,lanePath:this.editor.lanePath,obstacles:this.obstacles,reset:i},this.pathPlannerWorker.postMessage(this.lastPlanParams)}receivePlannedPath(t){if(this.editor.enabled)return;const{fromVehicleSegment:e,fromVehicleParams:n,vehiclePose:i,vehicleStation:a,latticeStartStation:s}=t.data;let{path:l}=t.data;if(this.averagePlanTime.addSample((performance.now()-this.lastPlanTime)/1e3),this.plannerReady=!0,null===l||this.plannerReset)return;(l=e.concat(l)).forEach(t=>Object.setPrototypeOf(t.pos,THREE.Vector2.prototype));const c=new o(l);this.autonomousCarController?this.autonomousCarController.replacePath(c):this.autonomousCarController=new r(c,this.car),this.scene.remove(this.plannedPathGroup),this.plannedPathGroup=new THREE.Group,this.scene.add(this.plannedPathGroup);const h=new THREE.CircleGeometry(.15,32),d=new THREE.MeshBasicMaterial({color:65408,depthTest:!1,transparent:!0,opacity:.7});new P(this.editor.lanePath,s).lattice.forEach(t=>{t.forEach(t=>{const e=new THREE.Mesh(h,d);e.position.set(t.pos.x,0,t.pos.y),e.rotation.x=-Math.PI/2,this.plannedPathGroup.add(e)})});const u=new THREE.Geometry;u.setFromPoints(l.map(t=>new THREE.Vector3(t.pos.x,0,t.pos.y)));const p=new MeshLine;p.setGeometry(u);const m=new THREE.Mesh(p.geometry,new MeshLineMaterial({color:new THREE.Color(16728319),lineWidth:.15,depthTest:!1,transparent:!0,opacity:.5,resolution:new THREE.Vector2(this.renderer.domElement.clientWidth,this.renderer.domElement.clientHeight)}));m.renderOrder=1,this.plannedPathGroup.add(m);const f=new THREE.LineBasicMaterial({color:65280,depthTest:!1}),g=new THREE.Geometry;g.vertices.push(...c.poses.map(t=>new THREE.Vector3(t.frontPos.x,0,t.frontPos.y))),this.plannedPathGroup.add(new THREE.Line(g,f))}}([33.5239,-111.908756],document.getElementById(\"container\"))})}]);","extractedComments":[]}