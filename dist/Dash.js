!function(t){var e={};function n(i){if(e[i])return e[i].exports;var a=e[i]={i:i,l:!1,exports:{}};return t[i].call(a.exports,a,a.exports,n),a.l=!0,a.exports}n.m=t,n.c=e,n.d=function(t,e,i){n.o(t,e)||Object.defineProperty(t,e,{configurable:!1,enumerable:!0,get:i})},n.r=function(t){Object.defineProperty(t,"__esModule",{value:!0})},n.n=function(t){var e=t&&t.__esModule?function(){return t.default}:function(){return t};return n.d(e,"a",e),e},n.o=function(t,e){return Object.prototype.hasOwnProperty.call(t,e)},n.p="",n(n.s=8)}([function(t,e,n){"use strict";var i=n(3);e.a=i.a},function(t,e,n){"use strict";n.d(e,"a",function(){return c});const i=8,a=16,s=32,o=.01,r=new THREE.Matrix3,l=new THREE.Matrix3;class c{constructor(t,e,n=null){this.start=Object.assign({},t),this.end=Object.assign({},e),t.pos&&(this.start.x=t.pos.x,this.start.y=t.pos.y),e.pos&&(this.end.x=e.pos.x,this.end.y=e.pos.y);const i=this.end.x-this.start.x,a=this.end.y-this.start.y,s=Math.sin(this.start.rot),o=Math.cos(this.start.rot);this.goal={x:o*i+s*a,y:-s*i+o*a,rot:Math.wrapAngle(this.end.rot-this.start.rot),curv:this.end.curv},n?this.params=Object.assign({},n,{p0:this.start.curv,p3:this.end.curv}):this.guessInitialParams(),this.converged=!1}guessInitialParams(){const t=this.goal,e=this.start.curv/s,n=t.y/s,i=t.rot/s,a=t.curv/s;this.goal={x:t.x,y:0,rot:0,curv:0},this.params={p0:0,p1:0,p2:0,p3:0,sG:t.x};for(let t=0;t<s;t++)this.params.p0+=e,this.params.p3+=a,this.goal.y+=n,this.goal.rot+=i,this.goal.curv+=a,this.iterate();this.goal=t}optimize(){for(let t=0;t<a;t++)if(this.iterate())return this.converged=!0,!0;return this.converged=!1,!1}iterate(){const{p0:t,p1:e,p2:n,p3:a,sG:s}=this.params,c=s/i,h=s*s,d=h*s;let u,p,m,f,g,y,v=0,E=0,x=0,T=0,S=0,P=0,C=0,b=0;for(let o=0,r=0;o<=i;o++,r+=c){const l=0==o||o==i?1:o%2==0?2:4;u=(((-4.5*(t-3*e+3*n-a)/d*r/4+(9*t-22.5*e+18*n-4.5*a)/h/3)*r+(-5.5*t+9*e-4.5*n+a)/s/2)*r+t)*r,p=Math.cos(u);const c=r/s;v-=l*(m=Math.sin(u))*(f=((3.375*c-7.5)*c+4.5)*c*r),E-=l*m*(g=((-3.375*c+6)*c-2.25)*c*r),x-=l*m*(y=((3.375*(t-3*e+3*n-a)*c-3*(2*t-5*e+4*n-a))*c+.25*(11*t-18*e+9*n-2*a))*c*c),T+=l*p*f,S+=l*p*g,P+=l*p*y,C+=l*p,b+=l*m}const _=s/i/3,w=this.goal.x-C*_,R=this.goal.y-b*_,A=Math.wrapAngle(this.goal.rot-u);if(Math.abs(w)+Math.abs(R)+Math.abs(A)<o)return!0;r.set(v*_,E*_,p+x*_,T*_,S*_,m+P*_,f,g,y);const[L,I,M,G,O,H,D,F,V]=l.getInverse(r).elements;return this.params.p1+=L*w+G*R+D*A,this.params.p2+=I*w+O*R+F*A,this.params.sG+=M*w+H*R+V*A,!1}buildPath(t){const{p0:e,p1:n,p2:i,p3:a,sG:s}=this.params,o=s*s,r=e,l=(-5.5*e+9*n-4.5*i+a)/s,c=(9*e-22.5*n+18*i-4.5*a)/o,h=-4.5*(e-3*n+3*i-a)/(o*s),d=[{pos:new THREE.Vector2(this.start.x,this.start.y),rot:this.start.rot,curv:this.start.curv}],u=s/(t-1);let p=u,m=0,f=0,g=Math.cos(d[0].rot),y=Math.sin(d[0].rot);for(let e=1;e<t-1;e++){const t=(((h*p/4+c/3)*p+l/2)*p+r)*p+this.start.rot,n=((h*p+c)*p+l)*p+r,i=Math.cos(t),a=Math.sin(t);m=m*(e-1)/e+(i+g)/(2*e),f=f*(e-1)/e+(a+y)/(2*e),d.push({pos:new THREE.Vector2(p*m+this.start.x,p*f+this.start.y),rot:t,curv:n}),p+=u,g=i,y=a}return d.push({pos:new THREE.Vector2(this.end.x,this.end.y),rot:this.end.rot,curv:this.end.curv}),d}}},function(t,e,n){"use strict";const i="#version 300 es\nin vec2 position;\nin vec2 texture;\nout vec2 kernelPosition;\n\nvoid main(void) {\n  kernelPosition = texture;\n  gl_Position = vec4(position.xy, 0.0, 1.0);\n}\n";e.a=class{static alloc(t,e){if(!Number.isInteger(e)||e<1||e>4)throw new Error("Data stride must be an integer between 1 and 4.");const n=Math.pow(Math.ceil(Math.sqrt(t)),2),i=new Float32Array(n*e);return i.gpgpuSize=t,i.gpgpuStride=e,i}constructor(t,e={}){this._setUpGL(),this.outputTextures={},this.sharedTextures={},this.programs=t.map(t=>this._prepareProgram(t));for(const t in e){const{width:n,height:i,channels:a,data:s,...o}=e[t];this.sharedTextures[t]=this._createTexture(s,n,i,a,o)}}updateSharedTextures(t){this.sharedTextures={};for(const e in t){const{width:n,height:i,channels:a,data:s,...o}=t[e];this.sharedTextures[e]=this._createTexture(s,n,i,a,o)}}updateProgram(t,e){const n="number"==typeof t?this.programs[t]:t;if(!n)throw new Error(`Program with index ${t} does not exist.`);if(e.inputs)throw new Error("The `updateProgram` function cannot be used to update inputs. Use `updateProgramInputs` instead.");e.meta&&(n.meta=Object.assign(n.meta,e.meta)),void 0!==e.width&&void 0!==e.height&&this.updateProgramSize(n,e.width,e.height),"object"==typeof e.uniforms&&this.updateProgramUniforms(n,e.uniforms)}updateProgramInputs(t,e){const n=this.programs[t];if(!n)throw new Error(`Program with index ${t} does not exist.`);if(n.inputTextures.length!=e.length)throw new Error(`You must provide the same number of inputs as when the program was set up: got ${e.length} but expected ${n.inputTextures.length}.`);const i=n.inputWidth,a=n.inputHeight,s=n.config;void 0!==s.width&&void 0!==s.height||(n.inputWidth=void 0,n.inputHeight=void 0,n.inputDataSize=void 0),this._prepareProgramInputs(n,e),n.inputWidth==i&&n.inputHeight==a||(this.gl.useProgram(n.glProgram),this.gl.uniform2i(n.kernelSizeLocation,n.inputWidth,n.inputHeight),this._prepareProgramOutput(n))}updateProgramSize(t,e,n){const i="number"==typeof t?this.programs[t]:t;if(!i)throw new Error(`Program with index ${t} does not exist.`);if(0!=i.inputTextures.length)throw new Error("Size can only be updated on programs with no inputs.");e==i.inputWidth&&n==i.inputHeight||(i.inputWidth=e,i.inputHeight=n,i.inputDataSize=e*n,this.gl.useProgram(i.glProgram),this.gl.uniform2i(i.kernelSizeLocation,i.inputWidth,i.inputHeight),this._prepareProgramOutput(i))}updateProgramUniforms(t,e){const n="number"==typeof t?this.programs[t]:t;if(this.gl.useProgram(n.glProgram),!n)throw new Error(`Program with index ${t} does not exist.`);for(const t in e){const i=e[t];let a;if(a=n.uniforms[t])this._setUniform(a.type,a.location,i);else{if(!(a=n.uniformTextures[t]))throw new Error(`The uniform ${t} does not exist in this program.`);{if("object"!=typeof i||"texture"!=i.type)throw new Error(`Expected texture type for uniform ${t}.`);const{width:e,height:s,channels:o,data:r,...l}=a;n.uniformTextures[t].texture=this._createTexture(r,e,s,o,l)}}}}run(){const t=[];for(const e of this.programs){this.gl.useProgram(e.glProgram),this.gl.viewport(0,0,e.inputWidth,e.inputHeight),this.gl.bindFramebuffer(this.gl.FRAMEBUFFER,e.frameBuffer);for(const[t,n]of e.inputTextures.entries())this.gl.activeTexture(this.gl.TEXTURE0+t),this.gl.bindTexture(this.gl.TEXTURE_2D,n);for(const t in e.uniformTextures){const n=e.uniformTextures[t];this.gl.activeTexture(this.gl.TEXTURE0+n.index),this.gl.bindTexture(n.target,n.texture||this.sharedTextures[n.name]||this.outputTextures[n.name])}if("function"==typeof e.draw)e.draw(this.gl,e);else if(this.gl.bindBuffer(this.gl.ARRAY_BUFFER,this.textureBuffer),this.gl.enableVertexAttribArray(e.textureLocation),this.gl.vertexAttribPointer(e.textureLocation,2,this.gl.FLOAT,!1,0,0),this.gl.bindBuffer(this.gl.ARRAY_BUFFER,this.positionBuffer),this.gl.enableVertexAttribArray(e.positionLocation),this.gl.vertexAttribPointer(e.positionLocation,2,this.gl.FLOAT,!1,0,0),this.gl.bindBuffer(this.gl.ELEMENT_ARRAY_BUFFER,this.indexBuffer),e.drawProxy){const t=(()=>this.gl.drawElements(this.gl.TRIANGLES,6,this.gl.UNSIGNED_SHORT,0)).bind(this);e.drawProxy(this,e,t)}else this.gl.drawElements(this.gl.TRIANGLES,6,this.gl.UNSIGNED_SHORT,0);if(e.output&&e.output.name&&!e.output.read)t.push(null);else{const n=new Float32Array(e.inputWidth*e.inputHeight*4);this.gl.readPixels(0,0,e.inputWidth,e.inputHeight,this.gl.RGBA,this.gl.FLOAT,n),t.push(n.subarray(0,4*e.inputDataSize))}}return t}_setUpGL(){let t;if(self.document)t=document.createElement("canvas");else{if(!self.OffscreenCanvas)throw new Error("Could not create a canvas.");t=new OffscreenCanvas(0,0)}const e={alpha:!1,antialias:!1};if(this.gl=t.getContext("webgl2",e)||t.getContext("experimental-webgl2",e),!this.gl)throw new Error("Unable to initialize WebGL2. Your browser may not support it.");if(!this.gl.getExtension("EXT_color_buffer_float"))throw new Error("Required WebGL extension EXT_color_buffer_float not supported.");if(!this.gl.getExtension("OES_texture_float_linear"))throw new Error("Required WebGL extension OES_texture_float_linear not supported.");this.positionBuffer=this._newBuffer([-1,-1,1,-1,1,1,-1,1]),this.textureBuffer=this._newBuffer([0,0,1,0,1,1,0,1]),this.indexBuffer=this._newBuffer([1,2,0,3,0,2],Uint16Array,this.gl.ELEMENT_ARRAY_BUFFER)}_prepareProgram(t){const e={config:t};e.draw=t.draw,e.drawProxy=t.drawProxy,e.meta=Object.assign({},t.meta),t.width&&t.height&&(e.inputWidth=t.width,e.inputHeight=t.height,e.inputDataSize=t.width*t.height),e.output=t.output;const n=t.kernel;if("string"!=typeof n||0==n.length)throw new Error("Kernel code cannot be empty.");const a=t.inputs||[],s=t.uniforms||{};this._prepareProgramInputs(e,a);let o="";for(const t in a)o+=`uniform sampler2D _input${t};\n`;if(void 0===e.inputWidth||void 0===e.inputHeight)throw new Error("Unknown kernel size. You must provide either an input or the `width` and `height` parameters in the kernel config.");e.uniformTextures={},e.uniforms={};for(const t in s){const n=s[t];if("number"==typeof n)e.uniforms[t]={type:"float",value:n},o+=`uniform float ${t};\n`;else if(Array.isArray(n)){if(n.length<2||n.length>4)throw new Error("Array uniforms can only have lengths of 2, 3, or 4 elements (corresponding to vec2, vec3, and vec4).");const i=["vec2","vec3","vec4"][n.length-2];e.uniforms[t]={type:i,value:n},o+=`uniform ${i} ${t};\n`}else{const{type:i,width:a,height:s,channels:r,data:l,value:c,length:h,name:d,...u}=n;if("texture"==i||"outputTexture"==i||"sharedTexture"==i){let n,i;"3D"==u.textureType?(n=this.gl.TEXTURE_3D,i="sampler3D"):"2DArray"==u.textureType?(n=this.gl.TEXTURE_2D_ARRAY,i="sampler2DArray"):(n=this.gl.TEXTURE_2D,i="sampler2D"),e.uniformTextures[t]="texture"==i?{target:n,texture:l?this._createTexture(l,a,s,r,u):null}:{target:n,texture:null,name:d||t},o+=`uniform ${i} ${t};\n`}else e.uniforms[t]={type:i,value:c},o+=void 0!==h?`uniform ${i} ${t}[${h}];\n`:`uniform ${i} ${t};\n`}}const r=this.gl.createShader(this.gl.VERTEX_SHADER);if(this.gl.shaderSource(r,t.vertexShader||i),this.gl.compileShader(r),!this.gl.getShaderParameter(r,this.gl.COMPILE_STATUS))throw new Error("Could not build internal vertex shader (fatal).\n\n--- CODE DUMP ---\n"+i+"\n\n--- ERROR LOG ---\n"+this.gl.getShaderInfoLog(r));const l=`\nvoid main() {\n  kernelOut = vec4(kernel(${[...Array(a.length).keys()].map(t=>`texture(_input${t}, kernelPosition)`).join(", ")}));\n}\n    `,c=this.gl.createShader(this.gl.FRAGMENT_SHADER),h="#version 300 es\nprecision highp float;\nprecision highp int;\nprecision highp sampler2D;\nprecision highp sampler2DArray;\nprecision highp sampler3D;\nprecision highp samplerCube;\n\nin vec2 kernelPosition;\nout vec4 kernelOut;\nuniform ivec2 kernelSize;\n"+o+n+l;if(this.gl.shaderSource(c,h),this.gl.compileShader(c),!this.gl.getShaderParameter(c,this.gl.COMPILE_STATUS)){const t=h.split("\n");let e="ERROR: Could not build shader (fatal).\n\n------------------ KERNEL CODE DUMP ------------------\n";for(let n=0;n<t.length;n++)e+=`${n+1}> ${t[n]}\n`;throw e+="\n--------------------- ERROR  LOG ---------------------\n"+this.gl.getShaderInfoLog(c),new Error(e)}if(e.glProgram=this.gl.createProgram(),this.gl.attachShader(e.glProgram,r),this.gl.attachShader(e.glProgram,c),this.gl.linkProgram(e.glProgram),this.gl.useProgram(e.glProgram),!this.gl.getProgramParameter(e.glProgram,this.gl.LINK_STATUS))throw new Error("Failed to link GLSL program code.");let d=0;for(const t of e.inputTextures){const t=this.gl.getUniformLocation(e.glProgram,`_input${d}`);this.gl.uniform1i(t,d),d++}for(const t in e.uniformTextures){e.uniformTextures[t].index=d;const n=this.gl.getUniformLocation(e.glProgram,t);this.gl.uniform1i(n,d),d++}for(const t in e.uniforms){const{type:n,value:i}=e.uniforms[t],a=e.uniforms[t].location=this.gl.getUniformLocation(e.glProgram,t);void 0!==i&&this._setUniform(n,a,i),delete e.uniforms[t].value}return e.kernelSizeLocation=this.gl.getUniformLocation(e.glProgram,"kernelSize"),this.gl.uniform2i(e.kernelSizeLocation,e.inputWidth,e.inputHeight),e.positionLocation=this.gl.getAttribLocation(e.glProgram,"position"),e.textureLocation=this.gl.getAttribLocation(e.glProgram,"texture"),e.frameBuffer=this.gl.createFramebuffer(),this._prepareProgramOutput(e),e}_prepareProgramInputs(t,e){t.inputTextures=[];for(const[n,i]of e.entries()){if(void 0===i.gpgpuSize||void 0===i.gpgpuStride)throw new Error("GPGPU inputs must be created by the `alloc` function.");const e=Math.sqrt(i.length/i.gpgpuStride);if(e<=0||e%1!=0)throw new Error("GPGPU input size is expected to be a perfect square.");if(void 0===t.inputWidth||void 0===t.inputHeight)t.inputWidth=e,t.inputHeight=e,t.inputDataSize=i.gpgpuSize;else if(e!=t.inputWidth||e!=t.inputHeight)throw new Error(`All GPGPU inputs must be of the same size. Received ${i.gpgpuSize} (internal ${e*e}) but expected ${t.inputDataSize} (internal ${t.inputWidth*t.inputHeight}).`);t.inputTextures.push(this._createTexture(i,e,e,i.gpgpuStride))}}_prepareProgramOutput(t){this.gl.bindFramebuffer(this.gl.FRAMEBUFFER,t.frameBuffer);const e=this._createTexture(null,t.inputWidth,t.inputHeight,4,t.output);if(this.gl.framebufferTexture2D(this.gl.FRAMEBUFFER,this.gl.COLOR_ATTACHMENT0,this.gl.TEXTURE_2D,e,0),!(this.gl.checkFramebufferStatus(this.gl.FRAMEBUFFER)==this.gl.FRAMEBUFFER_COMPLETE))throw new Error("Error attaching float texture to framebuffer. Your device is probably incompatible.");t.output&&t.output.name&&(this.outputTextures[t.output.name]=e)}_setUniform(t,e,n){switch(t){case"int":this.gl.uniform1i(e,n);break;case"float":Array.isArray(n)?this.gl.uniform1fv(e,n):this.gl.uniform1f(e,n);break;case"vec2":this.gl.uniform2fv(e,n);break;case"vec3":this.gl.uniform3fv(e,n);break;case"vec4":this.gl.uniform4fv(e,n);break;case"mat3":this.gl.uniformMatrix3fv(e,n);break;default:throw new Error(`Unknown uniform type ${t}.`)}}_newBuffer(t,e,n){const i=this.gl.createBuffer();return this.gl.bindBuffer(n||this.gl.ARRAY_BUFFER,i),this.gl.bufferData(n||this.gl.ARRAY_BUFFER,new(e||Float32Array)(t),this.gl.STATIC_DRAW),i}_createTexture(t,e,n,i,a={}){const s=this.gl.createTexture();let o,r;switch(i){case 1:o=this.gl.R32F,r=this.gl.RED;break;case 2:o=this.gl.RG32F,r=this.gl.RG;break;case 3:o=this.gl.RGB32F,r=this.gl.RGB;break;case 4:o=this.gl.RGBA32F,r=this.gl.RGBA;break;default:throw"Texture channels must between 1 and 4."}const l="3D"==a.textureType?this.gl.TEXTURE_3D:"2DArray"==a.textureType?this.gl.TEXTURE_2D_ARRAY:this.gl.TEXTURE_2D;return this.gl.bindTexture(l,s),this.gl.texParameteri(l,this.gl.TEXTURE_WRAP_S,this.gl.CLAMP_TO_EDGE),this.gl.texParameteri(l,this.gl.TEXTURE_WRAP_T,this.gl.CLAMP_TO_EDGE),this.gl.texParameteri(l,this.gl.TEXTURE_MIN_FILTER,"linear"==a.filter?this.gl.LINEAR:this.gl.NEAREST),this.gl.texParameteri(l,this.gl.TEXTURE_MAG_FILTER,"linear"==a.filter?this.gl.LINEAR:this.gl.NEAREST),"3D"==a.textureType||"2DArray"==a.textureType?this.gl.texImage3D(l,0,o,e,n,a.depth,0,r,this.gl.FLOAT,t):this.gl.texImage2D(l,0,o,e,n,0,r,this.gl.FLOAT,t),this.gl.bindTexture(l,null),s}}},function(t,e,n){"use strict";n.d(e,"a",function(){return i});class i{constructor(t=0,e=0,n=0){this.setPose(t,e,n)}static getFrontAxlePosition(t,e){return THREE.Vector2.fromAngle(e).multiplyScalar(i.WHEEL_BASE).add(t)}static getFakeAxlePosition(t,e){return i.frontToRearAxlePosition(t,e)}static centerToRearAxlePosition(t,e){return THREE.Vector2.fromAngle(e).multiplyScalar(i.REAR_AXLE_POS).add(t)}static frontToRearAxlePosition(t,e){return THREE.Vector2.fromAngle(e).multiplyScalar(-i.WHEEL_BASE).add(t)}get pose(){return{pos:this.rearAxlePosition,rot:this.rotation,velocity:this.velocity,curv:this.curvature,dCurv:0,ddCurv:0}}get curvature(){return Math.tan(this.wheelAngle)/i.WHEEL_BASE}get rearAxlePosition(){const{x:t,y:e}=this.position,n=this.rotation;return new THREE.Vector2(t+Math.cos(n)*i.REAR_AXLE_POS,e+Math.sin(n)*i.REAR_AXLE_POS)}get frontAxlePosition(){const{x:t,y:e}=this.position,n=this.rotation;return new THREE.Vector2(t+Math.cos(n)*i.FRONT_AXLE_POS,e+Math.sin(n)*i.FRONT_AXLE_POS)}setPose(t,e,n){t-=i.REAR_AXLE_POS*Math.cos(n),e-=i.REAR_AXLE_POS*Math.sin(n),this.position=new THREE.Vector2(t,e),this.rotation=Math.wrapAngle(n),this.velocity=0,this.acceleration=0,this.wheelAngle=0,this.wheelAngularVelocity=0,this.dCurv=0,this.ddCurv=0}step(t){const e=this.curvature,n=this.dCurv,a=(.5*i.DRAG_COEFF*i.FRONTAL_AREA*i.DENSITY_OF_AIR*Math.abs(this.velocity)+i.ROLL_RESIST)*-this.velocity;this.velocity+=(this.acceleration+a/i.MASS)*t;const s=this.velocity*this.velocity,o=Math.clamp(Math.atan(i.MAX_LATERAL_ACCEL*i.WHEEL_BASE/s),.07,i.MAX_WHEEL_ANGLE);this.wheelAngle=Math.clamp(Math.wrapAngle(this.wheelAngle+this.wheelAngularVelocity*t),-o,o);const r=this.velocity*this.curvature;this.rotation=Math.wrapAngle(this.rotation+r*t);const l=this.velocity*t;this.position=THREE.Vector2.fromAngle(this.rotation).multiplyScalar(l).add(this.position),this.dCurv=(this.curvature-e)/l,this.ddCurv=(this.dCurv-n)/l}update(t,e){const n=Math.clamp(t.gas,-1,1),a=Math.clamp(t.brake,0,1),s=Math.clamp(t.steer,-1,1);if(a>0){this.acceleration=-Math.sign(this.velocity)*i.MAX_BRAKE_DECEL*a;const t=this.velocity+this.acceleration*e;Math.sign(t)!=Math.sign(this.velocity)&&(this.velocity=0,this.acceleration=0)}else this.acceleration=i.MAX_GAS_ACCEL*n;this.wheelAngularVelocity=0!=s?s*i.MAX_STEER_SPEED:Math.clamp(-this.wheelAngle/i.MAX_WHEEL_ANGLE*this.velocity*this.velocity*e,-i.MAX_STEER_SPEED,i.MAX_STEER_SPEED)}}i.HALF_CAR_LENGTH=2.5,i.HALF_CAR_WIDTH=1,i.HALF_WHEEL_LENGTH=.33,i.HALF_WHEEL_WIDTH=.12,i.MAX_WHEEL_ANGLE=32/180*Math.PI,i.MASS=1600,i.DRAG_COEFF=.7,i.DENSITY_OF_AIR=1.8580608,i.FRONTAL_AREA=1.85,i.ROLL_RESIST=0,i.MAX_STEER_SPEED=.8,i.MAX_GAS_ACCEL=3.5,i.MAX_BRAKE_DECEL=6.5,i.WHEEL_LATERAL_POS=.843,i.FRONT_AXLE_POS=1.56,i.REAR_AXLE_POS=-1.37,i.WHEEL_BASE=i.FRONT_AXLE_POS-i.REAR_AXLE_POS,i.MAX_LATERAL_ACCEL=9.81},function(t,e,n){"use strict";new THREE.Geometry,new THREE.Geometry,new THREE.Geometry;function i(t,e,n,i,a){const s=.5*(i-e),o=.5*(a-n),r=t*t;return(2*n-2*i+s+o)*(t*r)+(-3*n+3*i-2*s-o)*r+s*t+n}function a(t,e,n,a,s){return new THREE.Vector2(i(t,e.x,n.x,a.x,s.x),i(t,e.y,n.y,a.y,s.y))}function s(t,e,n,i,s){let o=t-1e-4,r=t+1e-4;o<0&&(o=0),r>1&&(r=1);const l=a(o,e,n,i,s);return a(r,e,n,i,s).sub(l).normalize()}function o(t,e,n,i,s){0==t&&(t=1e-4),1==t&&(t=.9999);let o=t-1e-4,r=t+1e-4;o<0&&(o=0),r>1&&(r=1);const l=a(o,e,n,i,s),c=a(t,e,n,i,s),h=a(r,e,n,i,s);return(Math.atan2(h.y-c.y,h.x-c.x)-Math.atan2(c.y-l.y,c.x-l.x))/c.distanceTo(l)}e.a=class{constructor(){this.anchors=[],this.centerlines=[],this.sampleLengths=[],this.arcLengths=[],this.rotations=[],this.leftBoundaries=[],this.rightBoundaries=[]}get centerline(){return[].concat(...this.centerlines)}get centerlineRotations(){return[].concat(...this.rotations)}get centerlineLengths(){return[].concat(...this.arclengths)}get leftBoundary(){return[].concat(...this.leftBoundaries)}get rightBoundary(){return[].concat(...this.rightBoundaries)}sampleStations(t,e,n){const i=[];let r=0,l=0,c=0,h=t;for(;c+this.arcLengths[r]<h;)if(c+=this.arcLengths[r],++r>=this.arcLengths.length)throw new Error(`Exhausted lane path before reaching ${e} centerline samples at ${n}m intervals.`);for(let t=0;t<e;t++){let t=this.sampleLengths[r][l];for(;c+t<h;){if(c+=t,++l>=this.sampleLengths[r].length&&(l=0,++r>=this.sampleLengths.length))throw new Error(`Exhausted lane path before reaching ${e} centerline samples at ${n}m intervals.`);t=this.sampleLengths[r][l]}const[d,u,p,m]=this.anchorsForSplineIndex(r),f=(l+(h-c)/t)/this.sampleLengths[r].length,g=a(f,d,u,p,m),y=s(f,d,u,p,m),v=Math.atan2(y.y,y.x),E=o(f,d,u,p,m);i.push({pos:g,rot:v,curv:E}),h+=n}return i}stationLatitudeFromPosition(t,e=null){const[n,i,a,s]=this._findClosestSample(t,e);let o,r,l,c;if(0==n&&0==i)o=this.centerlines[n][i],r=this.centerlines[n][i+1],l=0,c=this.sampleLengths[n][i];else if(n==this.centerlines.length-1&&i==this.centerlines[n].length-1)o=this.centerlines[n][i-1],r=this.centerlines[n][i],l=s,c=a;else{o=0==i?this.centerlines[n-1][this.centerlines[n-1].length-1]:this.centerlines[n][i-1],r=i==this.centerlines[n].length-1?this.centerlines[n+1][0]:this.centerlines[n][i+1];const e=this.centerlines[n][i];t.clone().sub(o).dot(e.clone().sub(o))/o.distanceToSquared(e)<1?(r=e,l=s,c=a):(o=e,l=a,c=a+this.sampleLengths[n][i])}const h=Math.clamp(t.clone().sub(o).dot(r.clone().sub(o))/o.distanceToSquared(r),0,1),d=r.clone().sub(o).multiplyScalar(h).add(o);return[l+(c-l)*h,Math.sign((r.x-o.x)*(t.y-o.y)-(r.y-o.y)*(t.x-o.x))*t.distanceTo(d),n]}_findClosestSample(t,e=null){let n,i,a,s,o=Number.POSITIVE_INFINITY,r=0,l=0,c=0,h=this.centerlines.length-1;if(null!==e&&(c=Math.max(0,e-1),h=Math.min(this.centerlines.length-1,e+1)),c>0){for(let t=0;t<c;t++)r+=this.arcLengths[t];l=r-this.sampleLengths[c-1][this.sampleLengths[c-1].length-1]}for(let e=c;e<=h;e++){const c=this.centerlines[e];for(let h=0;h<c.length;h++){const d=t.distanceToSquared(c[h]);d<o&&(o=d,n=e,i=h,a=r,s=l),l=r,r+=this.sampleLengths[e][h]}}return[n,i,a,s]}addAnchor(t){const e=this.anchors.push(t)-1;for(let t=e-2;t<e;t++)this.resample(t)}updateAnchor(t,e){this.anchors[t]=e;for(let e=t-2;e<=t+1;e++)this.resample(e)}resample(t){if(t<0||t>this.anchors.length-2)return;const[e,n,i,o]=this.anchorsForSplineIndex(t),r=[],l=[],c=[],h=[],d=[];let u=null;const p=Math.ceil(n.distanceTo(i)/1),m=t==this.anchors.length-2?p+1:p;for(let t=0;t<m;t++){const m=t/p,f=a(m,e,n,i,o);r.push(f),null!=u&&l.push(u.distanceTo(f)),u=f;const g=s(m,e,n,i,o);c.push(Math.atan2(g.y,g.x));const y=new THREE.Vector2(-g.y,g.x);h.push(y.clone().multiplyScalar(-1.85).add(f)),d.push(y.clone().multiplyScalar(1.85).add(f))}l.push(u.distanceTo(i)),this.centerlines[t]=r,this.sampleLengths[t]=l,this.rotations[t]=c,this.leftBoundaries[t]=h,this.rightBoundaries[t]=d,this.arcLengths[t]=l.reduce((t,e)=>t+e)}anchorsForSplineIndex(t){let e;return void 0===(e=0==t?[this.anchors[0]].concat(this.anchors.slice(0,3)):this.anchors.slice(t-1,t+3))[3]&&(e[3]=e[2]),e}}},function(t,e,n){"use strict";e.a=class{constructor(t,e,n,i){this.pos=t,this.rot=e,this.width=n,this.height=i,this.updateVertices()}updateVertices(){this.vertices=[];const t=Math.cos(this.rot),e=Math.sin(this.rot),n=this.width/2,i=this.height/2,a=n*t,s=n*e,o=i*t,r=i*e,l=[-a-r+this.pos.x,-s+o+this.pos.y],c=[-a+r+this.pos.x,-s-o+this.pos.y],h=[a+r+this.pos.x,s-o+this.pos.y],d=[a-r+this.pos.x,s+o+this.pos.y];this.vertices=[l[0],l[1],c[0],c[1],h[0],h[1],h[0],h[1],d[0],d[1],l[0],l[1]]}}},function(t,e,n){"use strict";var i=n(2),a=(n(0),n(1));class s{constructor(t,e,n){this.start=Object.assign({},t),this.end=Object.assign({},e),t.pos&&(this.start.x=t.pos.x,this.start.y=t.pos.y),e.pos&&(this.end.x=e.pos.x,this.end.y=e.pos.y);const i=this.end.x-this.start.x,a=this.end.y-this.start.y,s=Math.sin(this.start.rot),o=Math.cos(this.start.rot);this.goal={x:o*i+s*a,y:-s*i+o*a,rot:Math.wrapAngle(this.end.rot-this.start.rot),curv:this.end.curv},this.params=Object.assign({},n,{p0:this.start.curv,p1:this.start.dCurv||0,p2:this.start.ddCurv||0,p5:this.end.curv})}buildPath(t){const{p0:e,p1:n,p2:i,p3:a,p4:s,p5:o,sG:r}=this.params,l=r*r,c=l*r,h=e,d=n,u=i/2,p=(-71.875*e+81*a-10.125*s+o-21.25*n*r-2.75*i*l)/c,m=(166.5*e-202.5*a+40.5*s-4.5*o+45*n*r+4.5*i*l)/(l*l),f=(-95.625*e+121.5*a-30.375*s+4.5*o-24.75*n*r-2.25*i*l)/(l*c),g=[{pos:new THREE.Vector2(this.start.x,this.start.y),rot:this.start.rot,curv:this.start.curv}],y=r/(t-1);let v=y,E=0,x=0,T=Math.cos(g[0].rot),S=Math.sin(g[0].rot);for(let e=1;e<t-1;e++){const t=(((((f*v/6+m/5)*v+p/4)*v+u/3)*v+d/2)*v+h)*v+this.start.rot,n=((((f*v+m)*v+p)*v+u)*v+d)*v+h,i=Math.cos(t),a=Math.sin(t);E=E*(e-1)/e+(i+T)/(2*e),x=x*(e-1)/e+(a+S)/(2*e),g.push({pos:new THREE.Vector2(v*E+this.start.x,v*x+this.start.y),rot:t,curv:n}),v+=y,T=i,S=a}return g.push({pos:new THREE.Vector2(this.end.x,this.end.y),rot:this.end.rot,curv:this.end.curv}),g}}let o,r;var l={setUp:()=>({kernel:"\n  vec4 kernel() {\n    return vec4(1, 0, 0, 1);\n  }\n",vertexShader:"#version 300 es\nuniform mat3 xform;\nin vec2 position;\n\nvoid main(void) {\n  gl_Position = vec4((xform * vec3(position, 1)).xy, 0, 1);\n}\n",output:{name:"xyObstacleGrid"},draw:(t,e)=>{if(t.clearColor(0,0,0,0),t.clear(t.COLOR_BUFFER_BIT),o.length>0){t.bindBuffer(t.ARRAY_BUFFER,t.createBuffer()),t.bufferData(t.ARRAY_BUFFER,o,t.STATIC_DRAW),t.enableVertexAttribArray(e.positionLocation),t.vertexAttribPointer(e.positionLocation,2,t.FLOAT,!1,0,0);const n=t.getUniformLocation(e.glProgram,"xform");t.uniformMatrix3fv(n,!1,r.elements),t.drawArrays(t.TRIANGLES,0,o.length/2)}}}),update(t,e,n,i,a,s){o=new Float32Array(Array.prototype.concat.apply([],s.map(t=>t.vertices)));const l=new THREE.Matrix3;l.set(1,0,-i.x,0,1,-i.y,0,0,1);const c=new THREE.Matrix3;return c.set(2/(e*t.xyGridCellSize),0,0,0,2/(n*t.xyGridCellSize),0,0,0,1),r=c.multiply(l).multiply(a),{width:e,height:n}}};var c={setUp:()=>({kernel:"\n\nvec4 kernel() {\n  float centerlineWidth = float(textureSize(centerline, 0).x);\n\n  vec2 sl = (kernelPosition - 0.5) * vec2(kernelSize) * vec2(slGridCellSize) + slCenterPoint;\n  float centerlineCoord = sl.x / centerlineStationInterval / centerlineWidth * (centerlineWidth - 1.0) / centerlineWidth + (0.5 / centerlineWidth);\n  if (centerlineCoord < 0.0 || centerlineCoord > 1.0) return vec4(0);\n\n  vec3 centerlineSample = texture(centerline, vec2(centerlineCoord, 0)).xyz;\n  float perpindicular = centerlineSample.z + radians(90.0);\n  vec2 xy = centerlineSample.xy + sl.yy * vec2(cos(perpindicular), sin(perpindicular));\n\n  vec2 xyTexCoords = (xy - xyCenterPoint) / vec2(textureSize(xyObstacleGrid, 0)) / vec2(xyGridCellSize) + 0.5;\n  return texture(xyObstacleGrid, xyTexCoords);\n}\n\n",output:{name:"slObstacleGrid"},uniforms:{xyObstacleGrid:{type:"outputTexture"},slGridCellSize:{type:"float"},xyGridCellSize:{type:"float"},slCenterPoint:{type:"vec2"},xyCenterPoint:{type:"vec2"},centerlineStationInterval:{type:"float"},centerline:{type:"sharedTexture"}}}),update:(t,e,n,i,a)=>({width:e,height:n,uniforms:{slGridCellSize:t.slGridCellSize,xyGridCellSize:t.xyGridCellSize,slCenterPoint:[i.x,i.y],xyCenterPoint:[a.x,a.y],centerlineStationInterval:t.centerlineStationInterval}})};const h="\n\n// TODO: test performance of returning early if non-zero pixel found\nvec4 kernel() {\n  float val = 0.0;\n\n  for (int d = 0; d <= lethalDilation; d++) {\n    val = max(val, texture(slObstacleGrid, kernelPosition + delta * vec2(d)).r);\n    val = max(val, texture(slObstacleGrid, kernelPosition + delta * vec2(-d)).r);\n  }\n\n  for (int d = lethalDilation + 1; d <= lethalDilation + hazardDilation; d++) {\n    val = max(val, texture(slObstacleGrid, kernelPosition + delta * vec2(d)).r * 0.5);\n    val = max(val, texture(slObstacleGrid, kernelPosition + delta * vec2(-d)).r * 0.5);\n  }\n\n  val = max(val, step(0.1, val) * 0.5);\n\n  return vec4(val, 0, 0, 1);\n}\n\n";var d={setUp:()=>[{kernel:h,output:{name:"slObstacleGridStationDilated"},uniforms:{slObstacleGrid:{type:"outputTexture"},delta:{type:"vec2"},lethalDilation:{type:"int"},hazardDilation:{type:"int"}}},{kernel:h,output:{name:"slObstacleGridDilated"},uniforms:{slObstacleGrid:{type:"outputTexture",name:"slObstacleGridStationDilated"},delta:{type:"vec2"},lethalDilation:{type:"int"},hazardDilation:{type:"int"}}}],update:(t,e,n)=>[{width:e,height:n,uniforms:{delta:[1/e,0],lethalDilation:Math.ceil(t.lethalDilationS/t.slGridCellSize),hazardDilation:Math.ceil(t.hazardDilationS/t.slGridCellSize)}},{width:e,height:n,uniforms:{delta:[0,1/n],lethalDilation:Math.ceil(t.lethalDilationL/t.slGridCellSize),hazardDilation:Math.ceil(t.hazardDilationL/t.slGridCellSize)}}]};var u={setUp:()=>({kernel:"\n\nvec4 kernel() {\n  vec2 xy = (kernelPosition - 0.5) * vec2(kernelSize) * vec2(xyGridCellSize) + xyCenterPoint;\n\n  int numSamples = textureSize(centerline, 0).x;\n  int closest = 0;\n  float closestDist = distance(xy, texelFetch(centerline, ivec2(0, 0), 0).xy);\n  for (int i = 1; i < numSamples; i++) {\n    float dist = distance(xy, texelFetch(centerline, ivec2(i, 0), 0).xy);\n    if (dist < closestDist) {\n      closestDist = dist;\n      closest = i;\n    }\n  }\n\n  vec2 closestPos = texelFetch(centerline, ivec2(closest, 0), 0).xy;\n  vec2 prev, next;\n  int prevIndex, nextIndex;\n\n  if (closest == 0) {\n    prevIndex = 0;\n    nextIndex = 1;\n    prev = closestPos;\n    next = texelFetch(centerline, ivec2(1, 0), 0).xy;\n  } else if (closest == numSamples - 1) {\n    prevIndex = closest - 1;\n    nextIndex = closest;\n    prev = texelFetch(centerline, ivec2(prevIndex, 0), 0).xy;\n    next = closestPos;\n  } else {\n    vec2 before = texelFetch(centerline, ivec2(closest - 1, 0), 0).xy;\n    vec2 after = texelFetch(centerline, ivec2(closest + 1, 0), 0).xy;\n\n    if (distance(before, xy) < distance(after, xy)) {\n      prevIndex = closest - 1;\n      nextIndex = closest;\n      prev = before;\n      next = closestPos;\n    } else {\n      prevIndex = closest;\n      nextIndex = closest + 1;\n      prev = closestPos;\n      next = after;\n    }\n  }\n\n  float dist = distance(prev, next);\n  float progress = clamp(dot(xy - prev, next - prev) / dist / dist, 0.0, 1.0);\n  vec2 projectedPos = (next - prev) * vec2(progress) + prev;\n\n  return vec4(\n    (float(prevIndex) + progress) * centerlineStationInterval,\n    sign(determinant(mat2(next - prev, xy - prev))) * distance(xy, projectedPos),\n    0,\n    0\n  );\n}\n\n",output:{name:"xyslMap",filter:"linear"},uniforms:{centerline:{type:"sharedTexture"},xyCenterPoint:{type:"vec2"},xyGridCellSize:{type:"float"},centerlineStationInterval:{type:"float"}}}),update:(t,e,n,i)=>({width:e,height:n,uniforms:{xyCenterPoint:[i.x,i.y],xyGridCellSize:t.xyGridCellSize,centerlineStationInterval:t.centerlineStationInterval}})};var p={setUp:()=>[{kernel:"\n\nconst int NEWTON_ITERATIONS = 16;\nconst int RELAXATION_ITERATIONS = 16;\nconst float CONVERGENCE_ERROR = 0.01;\n\n// These two consts must stay in sync.\nconst int SIMPSONS_INTERVALS = 8;\n//const float SIMPSONS_COEFFS[SIMPSONS_INTERVALS + 1] = float[](1.0, 4.0, 2.0, 4.0, 2.0, 4.0, 2.0, 4.0, 2.0, 4.0, 2.0, 4.0, 2.0, 4.0, 2.0, 4.0, 1.0);\nconst float SIMPSONS_COEFFS[SIMPSONS_INTERVALS + 1] = float[](1.0, 4.0, 2.0, 4.0, 2.0, 4.0, 2.0, 4.0, 1.0);\n\nconst float PI = 3.1415926535897932384626433832795;\nconst float TWO_PI = PI + PI;\n\nconst float RELAXATION_ITERATIONS_F = float(RELAXATION_ITERATIONS);\nconst float SIMPSONS_INTERVALS_F = float(SIMPSONS_INTERVALS);\n\nfloat wrapAngle(float angle) {\n  angle = mod(angle, TWO_PI);\n  if (angle <= -PI) return angle + TWO_PI;\n  else if (angle > PI) return angle - TWO_PI;\n  return angle;\n}\n\nvec4 iterate(vec4 goal, float p0, float p1, float p2, float p3, float sG) {\n  float ds = sG / SIMPSONS_INTERVALS_F;\n  float sG_2 = sG * sG;\n  float sG_3 = sG_2 * sG;\n\n  vec3 dX_p = vec3(0.0);\n  vec3 dY_p = vec3(0.0);\n  vec2 guess = vec2(0.0);\n  float s = 0.0;\n\n  float theta, cosTheta, sinTheta;\n  vec3 dT_p;\n\n  for (int i = 0; i <= SIMPSONS_INTERVALS; i++) {\n    float coeff = SIMPSONS_COEFFS[i];\n\n    float a = p0;\n    float b = (-5.5 * p0 + 9.0 * p1 - 4.5 * p2 + p3) / sG;\n    float c = (9.0 * p0 - 22.5 * p1 + 18.0 * p2 - 4.5 * p3) / sG_2;\n    float d = (-4.5 * (p0 - 3.0 * p1 + 3.0 * p2 - p3)) / sG_3;\n\n    theta = (((d * s / 4.0 + c / 3.0) * s + b / 2.0) * s + a) * s;\n    cosTheta = cos(theta);\n    sinTheta = sin(theta);\n\n    float s_sG = s / sG;\n\n    dT_p = vec3(\n      // p1\n      ((3.375 * s_sG - 7.5) * s_sG + 4.5) * s_sG * s,\n\n      // p2\n      ((-3.375 * s_sG + 6.0) * s_sG - 2.25) * s_sG * s,\n\n      // sG\n      ((3.375 * (p0 - 3.0 * p1 + 3.0 * p2 - p3) * s_sG - 3.0 * (2.0 * p0 - 5.0 * p1 + 4.0 * p2 - p3)) * s_sG + 0.25 * (11.0 * p0 - 18.0 * p1 + 9.0 * p2 - 2.0 * p3)) * s_sG * s_sG\n    );\n\n    dX_p -= coeff * sinTheta * dT_p;\n    dY_p += coeff * cosTheta * dT_p;\n\n    guess += coeff * vec2(cosTheta, sinTheta);\n\n    s += ds;\n  }\n\n  float hOver3 = sG / SIMPSONS_INTERVALS_F / 3.0;\n\n  vec3 delta;\n  delta.xy = goal.xy - guess * hOver3;\n  delta.z = wrapAngle(goal.z - theta);\n\n  if (abs(delta.x) + abs(delta.y) + abs(delta.z) < CONVERGENCE_ERROR)\n    return vec4(p1, p2, sG, 1.0);\n\n  dX_p.xyz *= hOver3;\n  dY_p.xyz *= hOver3;\n  dX_p.z += cosTheta;\n  dY_p.z += sinTheta;\n\n  mat3 invJacobian = inverse(transpose(mat3(dX_p, dY_p, dT_p)));\n\n  vec3 deltaP = invJacobian * delta;\n  vec4 params = vec4(p1, p2, sG, 0.0);\n  params.xyz += deltaP;\n\n  return params;\n}\n\n/* Input:\n *   start: (vec4)\n *     x: x position,\n *     y: y position,\n *     z: theta rotation,\n *     w: k curvature\n *   end: (vec4)\n *     x: x position,\n *     y: y position,\n *     z: theta rotation,\n *     w: k curvature\n *\n * Output: (vec4)\n *   x: p1,\n *   y: p2,\n *   z: sG,\n *   w: 1 if converged, 0 if not\n */\n\nvec4 optimize(vec4 start, vec4 end) {\n  // Translate and rotate start and end so that start is at the origin\n  float sinRot = sin(start.z);\n  float cosRot = cos(start.z);\n\n  vec4 diff = end - start;\n  vec4 goal;\n  goal.xy = mat2(cosRot, -sinRot, sinRot, cosRot) * diff.xy;\n  goal.z = wrapAngle(diff.z);\n  goal.w = end.w;\n\n  vec4 originalGoal = goal;\n  vec4 dGoal;\n  dGoal.x = 0.0;\n  dGoal.yzw = goal.yzw / RELAXATION_ITERATIONS_F;\n  float dK0 = start.w / RELAXATION_ITERATIONS_F;\n\n  // Relax the goal to (x, 0, 0, 0)\n  goal.yzw = vec3(0, 0, 0);\n\n  // Relax the params to (0, 0, 0, 0, goal.x)\n  float p0 = 0.0;\n  float p1 = 0.0;\n  float p2 = 0.0;\n  float p3 = 0.0;\n  float sG = goal.x;\n\n  if (sG < 0.1) return vec4(0.0);\n\n  for (int i = 0; i < RELAXATION_ITERATIONS; i++) {\n    p0 += dK0;\n    p3 += dGoal.w;\n    goal += dGoal;\n    \n    vec4 result = iterate(goal, p0, p1, p2, p3, sG);\n    p1 = result.x;\n    p2 = result.y;\n    sG = result.z;\n  }\n\n  goal = originalGoal;\n\n  for (int i = 0; i < NEWTON_ITERATIONS; i++) {\n    vec4 result = iterate(goal, p0, p1, p2, p3, sG);\n    if (result.w == 1.0) {\n      result.w = step(0.0, result.z);\n      return result;\n    }\n\n    p1 = result.x;\n    p2 = result.y;\n    sG = result.z;\n  }\n\n  return vec4(p1, p2, sG, 0.0);\n}\n\n\n\n// width: station * latitude index\n// height: station_conn * lattice_conn\n//\n// lattice:\n// width: latitudes\n// height: stations\n\nvec4 kernel() {\n  ivec2 indexes = ivec2(kernelPosition * vec2(kernelSize));\n\n  int endStation = indexes.x / numLatitudes;\n  int endLatitude = int(mod(float(indexes.x), float(numLatitudes)));\n\n  int startStation = endStation - stationConnectivity + indexes.y / latitudeConnectivity;\n  int startLatitude = endLatitude - latitudeConnectivity / 2 + int(mod(float(indexes.y), float(latitudeConnectivity)));\n\n  if (startStation < 0 || startStation >= numStations || startLatitude < 0 || startLatitude >= numLatitudes)\n    return vec4(0.0);\n\n  vec4 start = texelFetch(lattice, ivec2(startLatitude, startStation), 0);\n  vec4 end = texelFetch(lattice, ivec2(endLatitude, endStation), 0);\n\n  return optimize(start, end);\n}\n\n",output:{name:"cubicPaths",read:!0},uniforms:{lattice:{type:"sharedTexture"},numStations:{type:"int"},numLatitudes:{type:"int"},stationConnectivity:{type:"int"},latitudeConnectivity:{type:"int"}}},{kernel:"\n\nconst int NEWTON_ITERATIONS = 16;\nconst int RELAXATION_ITERATIONS = 16;\nconst float CONVERGENCE_ERROR = 0.01;\n\n// These two consts must stay in sync.\nconst int SIMPSONS_INTERVALS = 8;\n//const float SIMPSONS_COEFFS[SIMPSONS_INTERVALS + 1] = float[](1.0, 4.0, 2.0, 4.0, 2.0, 4.0, 2.0, 4.0, 2.0, 4.0, 2.0, 4.0, 2.0, 4.0, 2.0, 4.0, 1.0);\nconst float SIMPSONS_COEFFS[SIMPSONS_INTERVALS + 1] = float[](1.0, 4.0, 2.0, 4.0, 2.0, 4.0, 2.0, 4.0, 1.0);\n\nconst float PI = 3.1415926535897932384626433832795;\nconst float TWO_PI = PI + PI;\n\nconst float RELAXATION_ITERATIONS_F = float(RELAXATION_ITERATIONS);\nconst float SIMPSONS_INTERVALS_F = float(SIMPSONS_INTERVALS);\n\nfloat wrapAngle(float angle) {\n  angle = mod(angle, TWO_PI);\n  if (angle <= -PI) return angle + TWO_PI;\n  else if (angle > PI) return angle - TWO_PI;\n  return angle;\n}\n\nvec4 iterate(vec4 goal, float p0, float p1, float p2, float p3, float sG) {\n  float ds = sG / SIMPSONS_INTERVALS_F;\n  float sG_2 = sG * sG;\n  float sG_3 = sG_2 * sG;\n\n  vec3 dX_p = vec3(0.0);\n  vec3 dY_p = vec3(0.0);\n  vec2 guess = vec2(0.0);\n  float s = 0.0;\n\n  float theta, cosTheta, sinTheta;\n  vec3 dT_p;\n\n  for (int i = 0; i <= SIMPSONS_INTERVALS; i++) {\n    float coeff = SIMPSONS_COEFFS[i];\n\n    float a = p0;\n    float b = (-5.5 * p0 + 9.0 * p1 - 4.5 * p2 + p3) / sG;\n    float c = (9.0 * p0 - 22.5 * p1 + 18.0 * p2 - 4.5 * p3) / sG_2;\n    float d = (-4.5 * (p0 - 3.0 * p1 + 3.0 * p2 - p3)) / sG_3;\n\n    theta = (((d * s / 4.0 + c / 3.0) * s + b / 2.0) * s + a) * s;\n    cosTheta = cos(theta);\n    sinTheta = sin(theta);\n\n    float s_sG = s / sG;\n\n    dT_p = vec3(\n      // p1\n      ((3.375 * s_sG - 7.5) * s_sG + 4.5) * s_sG * s,\n\n      // p2\n      ((-3.375 * s_sG + 6.0) * s_sG - 2.25) * s_sG * s,\n\n      // sG\n      ((3.375 * (p0 - 3.0 * p1 + 3.0 * p2 - p3) * s_sG - 3.0 * (2.0 * p0 - 5.0 * p1 + 4.0 * p2 - p3)) * s_sG + 0.25 * (11.0 * p0 - 18.0 * p1 + 9.0 * p2 - 2.0 * p3)) * s_sG * s_sG\n    );\n\n    dX_p -= coeff * sinTheta * dT_p;\n    dY_p += coeff * cosTheta * dT_p;\n\n    guess += coeff * vec2(cosTheta, sinTheta);\n\n    s += ds;\n  }\n\n  float hOver3 = sG / SIMPSONS_INTERVALS_F / 3.0;\n\n  vec3 delta;\n  delta.xy = goal.xy - guess * hOver3;\n  delta.z = wrapAngle(goal.z - theta);\n\n  if (abs(delta.x) + abs(delta.y) + abs(delta.z) < CONVERGENCE_ERROR)\n    return vec4(p1, p2, sG, 1.0);\n\n  dX_p.xyz *= hOver3;\n  dY_p.xyz *= hOver3;\n  dX_p.z += cosTheta;\n  dY_p.z += sinTheta;\n\n  mat3 invJacobian = inverse(transpose(mat3(dX_p, dY_p, dT_p)));\n\n  vec3 deltaP = invJacobian * delta;\n  vec4 params = vec4(p1, p2, sG, 0.0);\n  params.xyz += deltaP;\n\n  return params;\n}\n\n/* Input:\n *   start: (vec4)\n *     x: x position,\n *     y: y position,\n *     z: theta rotation,\n *     w: k curvature\n *   end: (vec4)\n *     x: x position,\n *     y: y position,\n *     z: theta rotation,\n *     w: k curvature\n *\n * Output: (vec4)\n *   x: p1,\n *   y: p2,\n *   z: sG,\n *   w: 1 if converged, 0 if not\n */\n\nvec4 optimize(vec4 start, vec4 end) {\n  // Translate and rotate start and end so that start is at the origin\n  float sinRot = sin(start.z);\n  float cosRot = cos(start.z);\n\n  vec4 diff = end - start;\n  vec4 goal;\n  goal.xy = mat2(cosRot, -sinRot, sinRot, cosRot) * diff.xy;\n  goal.z = wrapAngle(diff.z);\n  goal.w = end.w;\n\n  vec4 originalGoal = goal;\n  vec4 dGoal;\n  dGoal.x = 0.0;\n  dGoal.yzw = goal.yzw / RELAXATION_ITERATIONS_F;\n  float dK0 = start.w / RELAXATION_ITERATIONS_F;\n\n  // Relax the goal to (x, 0, 0, 0)\n  goal.yzw = vec3(0, 0, 0);\n\n  // Relax the params to (0, 0, 0, 0, goal.x)\n  float p0 = 0.0;\n  float p1 = 0.0;\n  float p2 = 0.0;\n  float p3 = 0.0;\n  float sG = goal.x;\n\n  if (sG < 0.1) return vec4(0.0);\n\n  for (int i = 0; i < RELAXATION_ITERATIONS; i++) {\n    p0 += dK0;\n    p3 += dGoal.w;\n    goal += dGoal;\n    \n    vec4 result = iterate(goal, p0, p1, p2, p3, sG);\n    p1 = result.x;\n    p2 = result.y;\n    sG = result.z;\n  }\n\n  goal = originalGoal;\n\n  for (int i = 0; i < NEWTON_ITERATIONS; i++) {\n    vec4 result = iterate(goal, p0, p1, p2, p3, sG);\n    if (result.w == 1.0) {\n      result.w = step(0.0, result.z);\n      return result;\n    }\n\n    p1 = result.x;\n    p2 = result.y;\n    sG = result.z;\n  }\n\n  return vec4(p1, p2, sG, 0.0);\n}\n\n\n\nvec4 kernel() {\n  ivec2 indexes = ivec2(kernelPosition * vec2(kernelSize));\n\n  vec4 start = vec4(0, 0, 0, curvVehicle);\n  vec4 end = texelFetch(lattice, indexes, 0);\n\n  return optimize(start, end);\n}\n\n",output:{name:"cubicPathsFromVehicle",read:!0},uniforms:{lattice:{type:"sharedTexture"},curvVehicle:{type:"float"}}}],update:(t,e)=>[{width:t.lattice.numStations*t.lattice.numLatitudes,height:t.lattice.stationConnectivity*t.lattice.latitudeConnectivity,uniforms:{numStations:t.lattice.numStations,numLatitudes:t.lattice.numLatitudes,stationConnectivity:t.lattice.stationConnectivity,latitudeConnectivity:t.lattice.latitudeConnectivity}},{width:t.lattice.numLatitudes,height:t.lattice.stationConnectivity,uniforms:{curvVehicle:e.curv}}]};var m={setUp:()=>({kernel:"\n\nconst int NEWTON_ITERATIONS = 32;\nconst int RELAXATION_ITERATIONS = 32;\nconst float CONVERGENCE_ERROR = 0.01;\n\n// These two consts must stay in sync.\nconst int SIMPSONS_INTERVALS = 8;\nconst float SIMPSONS_COEFFS[SIMPSONS_INTERVALS + 1] = float[](1.0, 4.0, 2.0, 4.0, 2.0, 4.0, 2.0, 4.0, 1.0);\n\nconst float PI = 3.1415926535897932384626433832795;\nconst float TWO_PI = PI + PI;\n\nconst float RELAXATION_ITERATIONS_F = float(RELAXATION_ITERATIONS);\nconst float SIMPSONS_INTERVALS_F = float(SIMPSONS_INTERVALS);\n\nfloat wrapAngle(float angle) {\n  angle = mod(angle, TWO_PI);\n  if (angle <= -PI) return angle + TWO_PI;\n  else if (angle > PI) return angle - TWO_PI;\n  return angle;\n}\n\nvec4 iterate(vec4 goal, float p0, float p1, float p2, float p3, float p4, float p5, float sG) {\n  float ds = sG / SIMPSONS_INTERVALS_F;\n  float sG_2 = sG * sG;\n  float sG_3 = sG_2 * sG;\n\n  vec3 dX_p = vec3(0.0);\n  vec3 dY_p = vec3(0.0);\n  vec2 guess = vec2(0.0);\n  float s = 0.0;\n\n  float theta, cosTheta, sinTheta;\n  vec3 dT_p;\n\n  for (int i = 0; i <= SIMPSONS_INTERVALS; i++) {\n    float coeff = SIMPSONS_COEFFS[i];\n\n    float a = p0;\n    float b = p1;\n    float c = p2 / 2.0;\n    float d = (-71.875 * p0 + 81.0 * p3 - 10.125 * p4 + p5 - 21.25 * p1 * sG - 2.75 * p2 * sG_2) / sG_3;\n    float e = (166.5 * p0 - 202.5 * p3 + 40.5 * p4 - 4.5 * p5 + 45.0 * p1 * sG + 4.5 * p2 * sG_2) / (sG_2 * sG_2);\n    float f = (-95.625 * p0 + 121.5 * p3 - 30.375 * p4 + 4.5 * p5 - 24.75 * p1 * sG - 2.25 * p2 * sG_2) / (sG_2 * sG_3);\n\n    theta = (((((f * s / 6.0 + e / 5.0) * s + d / 4.0) * s + c / 3.0) * s + b / 2.0) * s + a) * s;\n    cosTheta = cos(theta);\n    sinTheta = sin(theta);\n\n    float s_2 = s * s;\n    float s_sG = s / sG;\n    float s_sG_2 = s_sG * s_sG;\n    float s_sG_3 = s_sG_2 * s_sG;\n    float s_sG_4 = s_sG_3 * s_sG;\n    float s_sG_5 = s_sG_4 * s_sG;\n\n    dT_p = vec3(\n      // p3\n      ((20.25 * s_sG - 40.5) * s_sG + 20.25) * s_sG_3 * s,\n\n      // p4\n      ((-5.0625 * s_sG + 8.1) * s_sG - 2.53125) * s_sG_3 * s,\n\n      // sG\n      (53.90625 * p0 - 60.75 * p3 + 7.59375 * p4 - 0.75 * p5) * s_sG_4 + 10.625 * p1 * s * s_sG_3 + 0.6875 * p2 * s_2 * s_sG_2 + (-133.2 * p0 + 162.0 * p3 - 32.4 * p4 + 3.6 * p5) * s_sG_5 + (-27.0) * p1 * s * s_sG_4 - 1.8 * p2 * s_2 * s_sG_3 + (79.6875 * p0 - 101.25 * p3 + 25.3125 * p4 - 3.75 * p5) * s_sG_5 * s_sG + 16.5 * p1 * s * s_sG_5 + 1.125 * p2 * s_2 * s_sG_4\n    );\n\n    dX_p -= coeff * sinTheta * dT_p;\n    dY_p += coeff * cosTheta * dT_p;\n\n    guess += coeff * vec2(cosTheta, sinTheta);\n\n    s += ds;\n  }\n\n  float hOver3 = sG / SIMPSONS_INTERVALS_F / 3.0;\n\n  vec3 delta;\n  delta.xy = goal.xy - guess * hOver3;\n  delta.z = wrapAngle(goal.z - theta);\n\n  if (abs(delta.x) + abs(delta.y) + abs(delta.z) < CONVERGENCE_ERROR)\n    return vec4(p3, p4, sG, 1.0);\n\n  dX_p.xyz *= hOver3;\n  dY_p.xyz *= hOver3;\n  dX_p.z += cosTheta;\n  dY_p.z += sinTheta;\n\n  mat3 invJacobian = inverse(transpose(mat3(dX_p, dY_p, dT_p)));\n\n  vec3 deltaP = invJacobian * delta;\n  vec4 params = vec4(p3, p4, sG, 0.0);\n  params.xyz += deltaP;\n\n  return params;\n}\n\nvec4 optimize(vec4 start, vec4 end) {\n  // Translate and rotate start and end so that start is at the origin\n  float sinRot = sin(start.z);\n  float cosRot = cos(start.z);\n\n  vec4 diff = end - start;\n  vec4 goal;\n  goal.xy = mat2(cosRot, -sinRot, sinRot, cosRot) * diff.xy;\n  goal.z = wrapAngle(diff.z);\n  goal.w = end.w;\n\n  vec4 originalGoal = goal;\n  vec4 dGoal;\n  dGoal.x = 0.0;\n  dGoal.yzw = goal.yzw / RELAXATION_ITERATIONS_F;\n  float d_K0 = start.w / RELAXATION_ITERATIONS_F;\n  float d_dK0 = dCurvVehicle / RELAXATION_ITERATIONS_F;\n  float d_ddK0 = ddCurvVehicle / RELAXATION_ITERATIONS_F;\n\n  // Relax the goal to (x, 0, 0, 0)\n  goal.yzw = vec3(0, 0, 0);\n\n  // Relax the params to (0, 0, 0, 0, goal.x)\n  float p0 = 0.0;\n  float p1 = 0.0;\n  float p2 = 0.0;\n  float p3 = 0.0;\n  float p4 = 0.0;\n  float p5 = 0.0;\n  float sG = goal.x;\n\n  if (sG < 0.1) return vec4(0.0);\n\n  for (int i = 0; i < RELAXATION_ITERATIONS; i++) {\n    p0 += d_K0;\n    p1 += d_dK0;\n    p2 += d_ddK0;\n    p5 += dGoal.w;\n    goal += dGoal;\n    \n    vec4 result = iterate(goal, p0, p1, p2, p3, p4, p5, sG);\n    p3 = result.x;\n    p4 = result.y;\n    sG = result.z;\n  }\n\n  goal = originalGoal;\n\n  for (int i = 0; i < NEWTON_ITERATIONS; i++) {\n    vec4 result = iterate(goal, p0, p1, p2, p3, p4, p5, sG);\n    if (result.w == 1.0) {\n      result.w = step(0.0, result.z);\n      return result;\n    }\n\n    p3 = result.x;\n    p4 = result.y;\n    sG = result.z;\n  }\n\n  return vec4(p3, p4, sG, 0.0);\n}\n\nvec4 kernel() {\n  ivec2 latticeIndexes = ivec2(kernelPosition * vec2(kernelSize));\n\n  vec4 start = vec4(0, 0, 0, curvVehicle);\n  vec4 end = texelFetch(lattice, latticeIndexes, 0);\n\n  return optimize(start, end);\n}\n\n",output:{name:"quinticPathsFromVehicle",read:!0},uniforms:{lattice:{type:"sharedTexture"},curvVehicle:{type:"float"},dCurvVehicle:{type:"float"},ddCurvVehicle:{type:"float"}}}),update:(t,e)=>({width:t.lattice.numLatitudes,height:t.lattice.stationConnectivity,uniforms:{curvVehicle:e.curv,dCurvVehicle:e.dCurv,ddCurvVehicle:e.ddCurv}})};const f="\n\nconst float smallV = 0.01;\nvec4 pathSamples[128];\nfloat pathSampleCurvRates[128];\n\nfloat calculateAcceleration(int index, float initialVelocitySq, float distance) {\n  if (index <= 4) {\n    // [aMaxHard, aMinHard, aMaxSoft, aMinSoft, 0]\n    return accelerationProfiles[index];\n  } else {\n    float finalVelocity = finalVelocityProfiles[index - 5];\n    if (distance < 0.001) return 0.0;\n    return clamp((finalVelocity * finalVelocity - initialVelocitySq) / (2.0 * distance), accelerationProfiles[1], accelerationProfiles[0]);\n  }\n}\n\nfloat sampleStaticCost(vec4 xytk) {\n  vec2 xyTexCoords = (xytk.xy - xyCenterPoint) / vec2(textureSize(xyslMap, 0)) / vec2(xyGridCellSize) + 0.5;\n  vec2 sl = texture(xyslMap, xyTexCoords).xy;\n\n  vec2 slTexCoords = (sl - slCenterPoint) / vec2(textureSize(slObstacleGrid, 0)) / vec2(slGridCellSize) + 0.5;\n  float obstacleCost = texture(slObstacleGrid, slTexCoords).r;\n\n  if (obstacleCost >= 0.75) return -1.0; // Infinite cost\n  obstacleCost = step(0.25, obstacleCost) * obstacleHazardCost;\n\n  float absLatitude = abs(sl.y);\n  float laneCost = max(absLatitude * laneCostSlope, step(laneShoulderLatitude, absLatitude) * laneShoulderCost);\n\n  return obstacleCost + laneCost;\n}\n\nfloat sampleDynamicCost(vec4 xytk, float time, float velocity, float acceleration) {\n  return 1.0;\n}\n\nfloat calculateAverageStaticCost(int numSamples) {\n  float averageStaticCost = 0.0;\n\n  for (int i = 0; i < numSamples; i++) {\n    float cost = sampleStaticCost(pathSamples[i]);\n\n    if (cost < 0.0) return cost;\n\n    averageStaticCost += cost;\n  }\n\n  averageStaticCost /= float(numSamples);\n\n  return averageStaticCost;\n}\n\nfloat calculateAverageDynamicCost(int numSamples, float pathLength, float initialVelocity, float acceleration) {\n  float s = 0.0;\n  float ds = pathLength / float(numSamples - 1);\n  float averageDynamicCost = 0.0;\n  float maxVelocity = 0.0;\n  float maxLateralAcceleration = 0.0;\n\n  for (int i = 0; i < numSamples; i++) {\n    vec4 pathSample = pathSamples[i]; // vec4(x-pos, y-pos, theta (rotation), kappa (curvature))\n\n    float velocitySq = 2.0 * acceleration * s + initialVelocity * initialVelocity;\n    float velocity = max(smallV, sqrt(max(0.0, velocitySq)));\n    maxVelocity = max(maxVelocity, velocity);\n    maxLateralAcceleration = max(maxLateralAcceleration, abs(pathSample.w * velocity * velocity));\n\n    float time = 2.0 * s / (initialVelocity + velocity);\n\n    float dCurv = pathSampleCurvRates[i] * velocity;\n    if (dCurv > dCurvatureMax) return -1.0;\n\n    float cost = sampleDynamicCost(pathSample, time, velocity, acceleration);\n    if (cost < 0.0) return cost;\n\n    averageDynamicCost += cost;\n    s += ds;\n  }\n\n  averageDynamicCost /= float(numSamples);\n\n  // Apply speeding penality if any velocity along the trajectory is over the speed limit\n  averageDynamicCost += step(speedLimit, maxVelocity) * speedLimitPenalty;\n\n  // Apply hard acceleration/deceleration penalties if the acceleration/deceleration exceeds the soft limits\n  averageDynamicCost += step(accelerationProfiles[2] + 0.0001, acceleration) * hardAccelerationPenalty;\n  averageDynamicCost += (1.0 - step(accelerationProfiles[3], acceleration)) * hardDecelerationPenalty;\n\n  // Penalize lateral acceleration\n  averageDynamicCost += step(lateralAccelerationLimit, maxLateralAcceleration) * softLateralAccelerationPenalty;\n  averageDynamicCost += linearLateralAccelerationPenalty * maxLateralAcceleration;\n\n  return averageDynamicCost;\n}\n\nvec3 calculateAVT(int accelerationIndex, float initialVelocity, float initialTime, float pathLength) {\n  float initialVelocitySq = initialVelocity * initialVelocity;\n  float acceleration = calculateAcceleration(accelerationIndex, initialVelocitySq, pathLength);\n\n  float finalVelocitySq = 2.0 * acceleration * pathLength + initialVelocitySq;\n  float finalVelocity = max(smallV, sqrt(max(0.0, finalVelocitySq)));\n\n  float finalTime = initialTime;\n\n  if (acceleration == 0.0) {\n    finalTime += pathLength / finalVelocity;\n  } else if (finalVelocitySq <= 0.0) { // Calculate final time if the vehicle stops before the end of the trajectory\n    float distanceLeft = pathLength - (smallV * smallV - initialVelocitySq) / (2.0 * acceleration);\n    finalTime += (finalVelocity - initialVelocity) / acceleration + distanceLeft / smallV;\n  } else {\n    finalTime += 2.0 * pathLength / (finalVelocity + initialVelocity);\n  }\n\n  return vec3(acceleration, finalVelocity, finalTime);\n}\n\n",g="\n\nint sampleCubicPath(vec4 start, vec4 end, vec4 cubicPathParams) {\n  float p0 = start.w;\n  float p1 = cubicPathParams.x;\n  float p2 = cubicPathParams.y;\n  float p3 = end.w;\n  float sG = cubicPathParams.z;\n\n  if (sG <= 0.0) return 0;\n\n  int numSamples = int(ceil(sG / pathSamplingStep)) + 1;\n\n  float sG_2 = sG * sG;\n  float sG_3 = sG_2 * sG;\n\n  float a = p0;\n  float b = (-5.5 * p0 + 9.0 * p1 - 4.5 * p2 + p3) / sG;\n  float c = (9.0 * p0 - 22.5 * p1 + 18.0 * p2 - 4.5 * p3) / sG_2;\n  float d = (-4.5 * (p0 - 3.0 * p1 + 3.0 * p2 - p3)) / sG_3;\n\n  pathSamples[0] = start;\n\n  float ds = sG / float(numSamples - 1);\n  float s = ds;\n  vec2 dxy = vec2(0);\n  vec2 prevCosSin = vec2(cos(start.z), sin(start.z));\n\n  for (int i = 1; i < numSamples; i++) {\n    float rot = (((d * s / 4.0 + c / 3.0) * s + b / 2.0) * s + a) * s + start.z;\n    float curv = ((d * s + c) * s + b) * s + a;\n\n    vec2 cosSin = vec2(cos(rot), sin(rot));\n    dxy = dxy * vec2(float(i - 1) / float(i)) + (cosSin + prevCosSin) / vec2(2 * i);\n\n    pathSamples[i] = vec4(dxy * vec2(s) + start.xy, rot, curv);\n    pathSampleCurvRates[i] = b + s * (2.0 * c + 3.0 * d * s);\n\n    s += ds;\n    prevCosSin = cosSin;\n  }\n\n  return numSamples;\n}\n\n",y="\n\nint sampleQuinticPath(vec4 start, vec4 end, vec4 quinticPathParams) {\n  float p0 = start.w;\n  float p1 = dCurvVehicle;\n  float p2 = ddCurvVehicle;\n  float p3 = quinticPathParams.x;\n  float p4 = quinticPathParams.y;\n  float p5 = end.w;\n  float sG = quinticPathParams.z;\n\n  if (sG <= 0.0) return 0;\n\n  int numSamples = int(ceil(sG / pathSamplingStep)) + 1;\n\n  float sG_2 = sG * sG;\n  float sG_3 = sG_2 * sG;\n\n  float a = p0;\n  float b = p1;\n  float c = p2 / 2.0;\n  float d = (-71.875 * p0 + 81.0 * p3 - 10.125 * p4 + p5 - 21.25 * p1 * sG - 2.75 * p2 * sG_2) / sG_3;\n  float e = (166.5 * p0 - 202.5 * p3 + 40.5 * p4 - 4.5 * p5 + 45.0 * p1 * sG + 4.5 * p2 * sG_2) / (sG_2 * sG_2);\n  float f = (-95.625 * p0 + 121.5 * p3 - 30.375 * p4 + 4.5 * p5 - 24.75 * p1 * sG - 2.25 * p2 * sG_2) / (sG_2 * sG_3);\n\n  pathSamples[0] = start;\n\n  float ds = sG / float(numSamples - 1);\n  float s = ds;\n  vec2 dxy = vec2(0);\n  vec2 prevCosSin = vec2(cos(start.z), sin(start.z));\n\n  for (int i = 1; i < numSamples; i++) {\n    float rot = (((((f * s / 6.0 + e / 5.0) * s + d / 4.0) * s + c / 3.0) * s + b / 2.0) * s + a) * s + start.z;\n    float curv = ((((f * s + e) * s + d) * s + c) * s + b) * s + a;\n\n    vec2 cosSin = vec2(cos(rot), sin(rot));\n    dxy = dxy * vec2(float(i - 1) / float(i)) + (cosSin + prevCosSin) / vec2(2 * i);\n\n    pathSamples[i] = vec4(dxy * vec2(s) + start.xy, rot, curv);\n    pathSampleCurvRates[i] = b + s * (2.0 * c + s * (3.0 * d + s * (4.0 * e + 5.0 * f * s)));\n\n    s += ds;\n    prevCosSin = cosSin;\n  }\n\n  return numSamples;\n}\n\n",v={xyslMap:{type:"outputTexture"},slObstacleGrid:{type:"outputTexture",name:"slObstacleGridDilated"},accelerationProfiles:{type:"float",length:5},finalVelocityProfiles:{type:"float",length:3},xyCenterPoint:{type:"vec2"},xyGridCellSize:{type:"float"},slCenterPoint:{type:"vec2"},slGridCellSize:{type:"float"},laneCostSlope:{type:"float"},laneShoulderCost:{type:"float"},laneShoulderLatitude:{type:"float"},obstacleHazardCost:{type:"float"},speedLimit:{type:"float"},speedLimitPenalty:{type:"float"},hardAccelerationPenalty:{type:"float"},hardDecelerationPenalty:{type:"float"},lateralAccelerationLimit:{type:"float"},softLateralAccelerationPenalty:{type:"float"},linearLateralAccelerationPenalty:{type:"float"},dCurvatureMax:{type:"float"},pathSamplingStep:{type:"float"},rearAxleToCenter:{type:"float"}};function E(t,e,n){return{accelerationProfiles:[3.5,-6.5,2,-3,0],finalVelocityProfiles:[.999*t.speedLimit,1,.01],xyCenterPoint:[e.x,e.y],xyGridCellSize:t.xyGridCellSize,slCenterPoint:[n.x,n.y],slGridCellSize:t.slGridCellSize,laneCostSlope:t.laneCostSlope,laneShoulderCost:t.laneShoulderCost,laneShoulderLatitude:t.laneShoulderLatitude,obstacleHazardCost:t.obstacleHazardCost,speedLimit:t.speedLimit,speedLimitPenalty:t.speedLimitPenalty,hardAccelerationPenalty:t.hardAccelerationPenalty,hardDecelerationPenalty:t.hardDecelerationPenalty,lateralAccelerationLimit:t.lateralAccelerationLimit,softLateralAccelerationPenalty:t.softLateralAccelerationPenalty,linearLateralAccelerationPenalty:t.linearLateralAccelerationPenalty,dCurvatureMax:t.dCurvatureMax,pathSamplingStep:t.pathSamplingStep,rearAxleToCenter:t.rearAxleToCenter}}function x(t){return f+("cubic"==t?g:y)+`\n\n/* Calculate cost of a {cubic|quintic} path from vehicle to (stationConnectivity * numLatitudes * numAccelerations) nodes\n *   width: numLatitudes\n *   height: station * numAccelerations\n */\nvec4 kernel() {\n  ivec2 indexes = ivec2(kernelPosition * vec2(kernelSize));\n\n  int latitude = indexes.x;\n  int station = indexes.y / numAccelerations;\n  int accelerationIndex = int(mod(float(indexes.y), float(numAccelerations)));\n\n  vec4 pathStart = vec4(0, 0, 0, curvVehicle);\n  vec4 pathEnd = texelFetch(lattice, ivec2(latitude, station), 0);\n\n  vec4 pathParams = texelFetch(pathsFromVehicle, ivec2(latitude, station), 0);\n\n  // If the path didn't converge\n  if (pathParams.w == 0.0) return vec4(-1);\n\n  int numSamples = ${"cubic"==t?"sampleCubicPath":"sampleQuinticPath"}(pathStart, pathEnd, pathParams);\n  float pathLength = pathParams.z;\n\n  if (numSamples < 2) return vec4(-1);\n\n  float averageStaticCost = calculateAverageStaticCost(numSamples);\n  if (averageStaticCost < 0.0) return vec4(-1);\n\n  int slIndex = station * kernelSize.x + latitude;\n  float hysteresisAdjustment = (slIndex == firstLatticePoint || slIndex == secondLatticePoint) ?  0.0 : hysteresisDiscount;\n  averageStaticCost += hysteresisAdjustment;\n\n  vec3 avt = calculateAVT(accelerationIndex, velocityVehicle, 0.0, pathLength);\n  float acceleration = avt.x;\n  float finalVelocity = avt.y;\n  float finalTime = avt.z;\n\n  float averageDynamicCost = calculateAverageDynamicCost(numSamples, pathLength, velocityVehicle, acceleration);\n  if (averageDynamicCost < 0.0) return vec4(-1);\n\n  averageDynamicCost += accelerationChangePenalty;\n\n  // The cost of a trajectory is the average sample cost scaled by the path length\n  float totalCost = (averageStaticCost + averageDynamicCost + ${"cubic"==t?"(cubicPathPenalty * velocityVehicle * velocityVehicle)":"0.0"}) * pathLength;\n\n  return vec4(totalCost, finalVelocity, finalTime, ${"cubic"==t?"-2":"-1"});\n}\n\n`}var T={setUp:()=>[{kernel:x("cubic"),output:{name:"cubicPathFromVehicleCosts"},uniforms:{...v,lattice:{type:"sharedTexture"},pathsFromVehicle:{type:"outputTexture",name:"cubicPathsFromVehicle"},firstLatticePoint:{type:"int"},secondLatticePoint:{type:"int"},velocityVehicle:{type:"float"},curvVehicle:{type:"float"},numAccelerations:{type:"int"},cubicPathPenalty:{type:"float"},hysteresisDiscount:{type:"float"},accelerationChangePenalty:{type:"float"}}},{kernel:x("quintic"),output:{name:"quinticPathFromVehicleCosts"},uniforms:{...v,lattice:{type:"sharedTexture"},pathsFromVehicle:{type:"outputTexture",name:"quinticPathsFromVehicle"},firstLatticePoint:{type:"int"},secondLatticePoint:{type:"int"},velocityVehicle:{type:"float"},curvVehicle:{type:"float"},dCurvVehicle:{type:"float"},ddCurvVehicle:{type:"float"},numAccelerations:{type:"int"},hysteresisDiscount:{type:"float"},accelerationChangePenalty:{type:"float"}}}],update:(t,e,n,i,a,s)=>[{width:t.lattice.numLatitudes,height:8*t.lattice.stationConnectivity,uniforms:{...E(t,n,i),firstLatticePoint:a,secondLatticePoint:s,velocityVehicle:e.velocity,curvVehicle:e.curv,numAccelerations:8,cubicPathPenalty:t.cubicPathPenalty,hysteresisDiscount:t.hysteresisDiscount,accelerationChangePenalty:t.accelerationChangePenalty}},{width:t.lattice.numLatitudes,height:8*t.lattice.stationConnectivity,uniforms:{...E(t,n,i),firstLatticePoint:a,secondLatticePoint:s,velocityVehicle:e.velocity,curvVehicle:e.curv,dCurvVehicle:e.dCurv,ddCurvVehicle:e.ddCurv,numAccelerations:8,hysteresisDiscount:t.hysteresisDiscount,accelerationChangePenalty:t.accelerationChangePenalty}}]};const S=f+g+y+"\n\nvec4 kernel() {\n  ivec2 indexes = ivec2(kernelPosition * vec2(kernelSize));\n\n  int latitude = indexes.y;\n\n  int numPerTime = numAccelerations * numVelocities;\n  int timeIndex = indexes.x / numPerTime;\n  indexes.x -= timeIndex * numPerTime;\n  int velocityIndex = indexes.x / numAccelerations;\n  int accelerationIndex = int(mod(float(indexes.x), float(numAccelerations)));\n\n  int minLatitude = max(latitude - latitudeConnectivity / 2, 0);\n  int maxLatitude = min(latitude + latitudeConnectivity / 2, numLatitudes - 1);\n\n  int slIndex = station * numLatitudes + latitude;\n\n  vec4 pathEnd = texelFetch(lattice, ivec2(latitude, station), 0);\n\n  float minVelocity = velocityRanges[velocityIndex];\n  float maxVelocity = velocityRanges[velocityIndex + 1];\n\n  float minTime = timeRanges[timeIndex];\n  float maxTime = timeRanges[timeIndex + 1];\n\n  vec4 bestTrajectory = vec4(-1); // -1 means infinite cost\n  float bestCost = 1000000000.0;\n\n  float hysteresisAdjustment = (slIndex == firstLatticePoint || slIndex == secondLatticePoint) ?  0.0 : hysteresisDiscount;\n\n  for (int prevStation = max(station - stationConnectivity, 0); prevStation < station; prevStation++) {\n    int stationConnectivityIndex = prevStation - station + stationConnectivity;\n\n    for (int prevLatitude = minLatitude; prevLatitude <= maxLatitude; prevLatitude++) {\n      int latitudeConnectivityIndex = prevLatitude - latitude + latitudeConnectivity / 2;\n      int connectivityIndex = stationConnectivityIndex * latitudeConnectivity + latitudeConnectivityIndex;\n\n      vec4 pathStart = texelFetch(lattice, ivec2(prevLatitude, prevStation), 0);\n      vec4 cubicPathParams = texelFetch(cubicPaths, ivec2(slIndex, connectivityIndex), 0);\n\n      // If the path didn't converge\n      if (cubicPathParams.w == 0.0) continue;\n\n      int numSamples = sampleCubicPath(pathStart, pathEnd, cubicPathParams);\n      float pathLength = cubicPathParams.z;\n\n      if (numSamples < 2) continue;\n\n      float averageStaticCost = calculateAverageStaticCost(numSamples);\n      if (averageStaticCost < 0.0) continue;\n\n      averageStaticCost += hysteresisAdjustment;\n\n      for (int prevVelocity = 0; prevVelocity < numVelocities; prevVelocity++) {\n        for (int prevTime = 0; prevTime < numTimes; prevTime++) {\n          for (int prevAccel = 0; prevAccel < numAccelerations; prevAccel++) {\n            int avtIndex = prevTime * numPerTime + prevVelocity * numAccelerations + prevAccel;\n\n            // Cost table entry:\n            //   x: cost so far\n            //   y: end velocity\n            //   z: end time\n            //   w: parent index\n            vec4 costTableEntry = texelFetch(costTable, ivec3(avtIndex, prevLatitude, prevStation), 0);\n\n            // If cost entry is infinity\n            if (costTableEntry.x < 0.0) continue;\n\n            vec3 avt = calculateAVT(accelerationIndex, costTableEntry.y, costTableEntry.z, pathLength);\n            float acceleration = avt.x;\n            float finalVelocity = avt.y;\n            float finalTime = avt.z;\n\n            // If the calculated final velocity does not match this fragment's velocity range, then skip this trajectory\n            if (finalVelocity < minVelocity || finalVelocity >= maxVelocity) continue;\n\n            // If the calculated final time does not match this fragment's time range, then skip this trajectory\n            if (finalTime < minTime || finalTime >= maxTime) continue;\n\n            float averageDynamicCost = calculateAverageDynamicCost(numSamples, pathLength, costTableEntry.y, acceleration);\n            if (averageDynamicCost < 0.0) continue;\n\n            if (accelerationIndex != prevAccel)\n              averageDynamicCost += accelerationChangePenalty;\n\n            // The cost of a trajectory is the average sample cost scaled by the path length\n            float totalCost = (averageStaticCost + averageDynamicCost) * pathLength + costTableEntry.x;\n\n            float terminalCost = totalCost + extraTimePenalty * finalTime;\n            if (terminalCost >= bestCost) continue;\n            bestCost = terminalCost;\n\n            int incomingIndex = avtIndex + numPerTime * numTimes * (prevLatitude + numLatitudes * prevStation);\n            bestTrajectory = vec4(totalCost, finalVelocity, finalTime, incomingIndex);\n          }\n        }\n      }\n    }\n  }\n\n  if (station < stationConnectivity) {\n    ivec2 slaIndex = ivec2(latitude, station * numAccelerations + accelerationIndex);\n\n    vec4 costTableEntry = texelFetch(cubicPathFromVehicleCosts, slaIndex, 0);\n    float terminalCost;\n\n    if (costTableEntry.x >= 0.0) {\n      terminalCost = costTableEntry.x + extraTimePenalty * costTableEntry.z;\n\n      if (terminalCost < bestCost) {\n        bestCost = terminalCost;\n        bestTrajectory = costTableEntry;\n      }\n    }\n\n    costTableEntry = texelFetch(quinticPathFromVehicleCosts, slaIndex, 0);\n\n    if (costTableEntry.x >= 0.0) {\n      terminalCost = costTableEntry.x + extraTimePenalty * costTableEntry.z;\n\n      if (terminalCost < bestCost) {\n        bestCost = terminalCost;\n        bestTrajectory = costTableEntry;\n      }\n    }\n  }\n\n  return bestTrajectory;\n}\n\n";var P={setUp:()=>({kernel:S,output:{name:"graphSearch"},uniforms:{...v,lattice:{type:"sharedTexture"},costTable:{type:"sharedTexture",textureType:"2DArray"},cubicPaths:{type:"outputTexture"},cubicPathFromVehicleCosts:{type:"outputTexture"},quinticPathFromVehicleCosts:{type:"outputTexture"},firstLatticePoint:{type:"int"},secondLatticePoint:{type:"int"},velocityVehicle:{type:"float"},curvVehicle:{type:"float"},dCurvVehicle:{type:"float"},ddCurvVehicle:{type:"float"},extraTimePenalty:{type:"float"},hysteresisDiscount:{type:"float"},accelerationChangePenalty:{type:"float"},numStations:{type:"int"},numLatitudes:{type:"int"},numAccelerations:{type:"int"},numVelocities:{type:"int"},numTimes:{type:"int"},stationConnectivity:{type:"int"},latitudeConnectivity:{type:"int"},velocityRanges:{type:"float",length:5},timeRanges:{type:"float",length:3},station:{type:"int"}},drawProxy:(t,e,n)=>{const i=e.meta.lattice.numLatitudes,a=new Float32Array(64*i*e.meta.lattice.numStations*4);for(let s=0;s<e.meta.lattice.numStations;s++)t.updateProgramUniforms(e,{station:s}),n(),t.gl.readPixels(0,0,64,i,t.gl.RGBA,t.gl.FLOAT,a,64*s*i*4),t.gl.bindTexture(t.gl.TEXTURE_2D_ARRAY,t.sharedTextures.costTable),t.gl.copyTexSubImage3D(t.gl.TEXTURE_2D_ARRAY,0,0,0,s,0,0,64,i);t._graphSearchCostTable=a}}),update:(t,e,n,i,a,s)=>({width:64,height:t.lattice.numLatitudes,meta:{lattice:t.lattice},uniforms:{...E(t,n,i),firstLatticePoint:a,secondLatticePoint:s,velocityVehicle:e.velocity,curvVehicle:e.curv,dCurvVehicle:e.dCurv,ddCurvVehicle:e.ddCurv,extraTimePenalty:t.extraTimePenalty,hysteresisDiscount:t.hysteresisDiscount,accelerationChangePenalty:t.accelerationChangePenalty,numStations:t.lattice.numStations,numLatitudes:t.lattice.numLatitudes,numAccelerations:8,numVelocities:4,numTimes:2,stationConnectivity:t.lattice.stationConnectivity,latitudeConnectivity:t.lattice.latitudeConnectivity,velocityRanges:[0,t.speedLimit/3,2*t.speedLimit/3,t.speedLimit,1e6],timeRanges:[0,10,1e6]}})};n.d(e,"a",function(){return w});const C=8,b=4,_=2;class w{constructor(){this.previousStartStation=null,this.previousFirstLatticePoint=-1,this.previousSecondLatticePoint=-1;performance.now();const t=[l.setUp(),c.setUp(),...d.setUp(),u.setUp(),...p.setUp(),m.setUp(),...T.setUp(),P.setUp()].map(t=>Object.assign({},t,{width:1,height:1}));this.gpgpu=new i.a(t)}reset(){this.previousStartStation=null,this.previousFirstLatticePoint=-1,this.previousSecondLatticePoint=-1}plan(t,e,n,i){const a=n.sampleStations(e,Math.ceil(this.config.spatialHorizon/this.config.centerlineStationInterval)+1,this.config.centerlineStationInterval),s=function({pos:t,rot:e}){const n=new THREE.Matrix3;n.set(1,0,-t.x,0,1,-t.y,0,0,1);const i=Math.cos(e),a=Math.sin(e),s=new THREE.Matrix3;return s.set(i,a,0,-a,i,0,0,0,1),s.multiply(n)}(t),o=a.map(e=>({pos:e.pos.clone().applyMatrix3(s),rot:e.rot-t.rot,curv:e.curv})),r=new Float32Array(3*o.length),h=new THREE.Vector2(0,0),f=new THREE.Vector2(0,0);for(let t=0;t<o.length;t++){const e=o[t],n=e.pos;r[3*t+0]=n.x,r[3*t+1]=n.y,r[3*t+2]=e.rot,h.max(n),f.min(n)}const g=h.clone().sub(f),y=f.clone().add(h).divideScalar(2),v=Math.ceil((g.x+2*this.config.gridMargin)/this.config.xyGridCellSize),E=Math.ceil((g.y+2*this.config.gridMargin)/this.config.xyGridCellSize),x=new THREE.Vector2(this.config.spatialHorizon/2,0),S=Math.ceil(this.config.spatialHorizon/this.config.slGridCellSize),w=Math.ceil((this.config.laneWidth+2*this.config.gridMargin)/this.config.slGridCellSize),R=this._latticeStationInterval();let A;null===this.previousStartStation||e+R/2>this.previousStartStation?(A=(null===this.previousStartStation?e:this.previousStartStation)+R,this.previousStartStation=A,this.previousFirstLatticePoint-=this.config.lattice.numLatitudes,this.previousSecondLatticePoint-=this.config.lattice.numLatitudes):A=this.previousStartStation;const L=this._buildLattice(n,A,t.rot,s);for(const[e,n]of[l.update(this.config,v,E,y,s,i),c.update(this.config,S,w,x,y),...d.update(this.config,S,w),u.update(this.config,v,E,y),...p.update(this.config,t),m.update(this.config,t),...T.update(this.config,t,y,x,this.previousFirstLatticePoint,this.previousSecondLatticePoint),P.update(this.config,t,y,x,this.previousFirstLatticePoint,this.previousSecondLatticePoint)].entries())this.gpgpu.updateProgram(e,n);this.gpgpu.updateSharedTextures({centerline:{width:o.length,height:1,channels:3,filter:"linear",data:r},costTable:{width:C*b*_,height:this.config.lattice.numLatitudes,depth:this.config.lattice.numStations,channels:4,textureType:"2DArray"},lattice:{width:this.config.lattice.numLatitudes,height:this.config.lattice.numStations,channels:4,data:L}});performance.now();const I=this.gpgpu.run(),M=this.gpgpu._graphSearchCostTable,G=I[5],O=I[6],H=I[7];let D,F=[Number.POSITIVE_INFINITY];const V=M.length/4;for(let t=0;t<V;t++){const e=this._unpackCostTableIndex(t),n=[M[4*t],M[4*t+1],M[4*t+2],M[4*t+3]];n[0]<0||(n[0]+=this._terminalCost(e,n),n[0]<F[0]&&(D=t,F=n))}const N=(new THREE.Matrix3).getInverse(s);let z=null,k=null,B=null,U=-1,W=-1;return isFinite(F[0])&&([z,k,B,U,W]=this._reconstructTrajectory(D,M,G,O,H,t,L),U==this.previousFirstLatticePoint&&W==this.previousSecondLatticePoint?(z=null,k=null,B=null):(k.forEach(e=>{e.pos=e.pos.applyMatrix3(N),e.rot+=t.rot}),z.forEach(e=>{e.pos=e.pos.applyMatrix3(N),e.rot+=t.rot}))),this.previousFirstLatticePoint=U,this.previousSecondLatticePoint=W,{path:z,fromVehicleSegment:k,fromVehicleParams:B,latticeStartStation:this.previousStartStation}}_buildLattice(t,e,n,i){const a=t.sampleStations(e,this.config.lattice.numStations,this._latticeStationInterval()),s=Math.floor(this.config.lattice.numLatitudes/2),o=new Float32Array(this.config.lattice.numStations*this.config.lattice.numLatitudes*4);let r=0;for(let t=0;t<this.config.lattice.numStations;t++){const e=a[t];for(let t=0;t<this.config.lattice.numLatitudes;t++){const a=(t-s)/s*this.config.laneWidth/2,l=e.rot-n,c=THREE.Vector2.fromAngle(l+Math.PI/2).multiplyScalar(a).add(e.pos.clone().applyMatrix3(i)),h=0==e.curv?0:1/(1/e.curv-a);o[r++]=c.x,o[r++]=c.y,o[r++]=l,o[r++]=h}}return o}_latticeStationInterval(){return this.config.spatialHorizon/this.config.lattice.numStations}_terminalCost([t,e,n,i,a],[s,o,r,l]){if(t!=this.config.lattice.numStations-1&&o>.05)return Number.POSITIVE_INFINITY;return this.config.spatialHorizon/this.config.lattice.numStations*(t+1)*-this.config.stationReachDiscount+r*this.config.extraTimePenalty}_unpackCostTableIndex(t){if(t<0)return[-1,t+2,null,null,null];const e=C*b,n=e*_,i=this.config.lattice.numLatitudes*n,a=Math.floor(t/i);t-=a*i;const s=Math.floor(t/n);t-=s*n;const o=Math.floor(t/e);return t-=o*e,[a,s,o,Math.floor(t/C),t%C]}_reconstructTrajectory(t,e,n,i,o,r,l){let c=this._unpackCostTableIndex(t);c.push(e[4*t+1]);const h=[c];let d=0;for(;c[0]>=0&&d++<100;){t=e[4*t+3];const n=(c=this._unpackCostTableIndex(t))[0]>=0?e[4*t+1]:r.velocity;c.push(n),h.unshift(c)}if(d>=100)throw new Error("Infinite loop encountered while reconstructing trajectory.");const u=[];let p=[],m=null;for(let t=0;t<h.length-1;t++){const[e,c,d,f,g,y]=h[t],[v,E,x,T,S,P]=h[t+1];let C,b;if(e<0){const t={pos:new THREE.Vector2(0,0),rot:0,curv:r.curv},e=4*(v*this.config.lattice.numLatitudes+E),n={pos:new THREE.Vector2(l[e],l[e+1]),rot:l[e+2],curv:l[e+3]};if(0==c){C=i[e+2];const s={p1:i[e],p2:i[e+1],sG:C};b=new a.a(t,n,s),m={type:"cubic",params:s}}else{C=o[e+2];const i={p3:o[e],p4:o[e+1],sG:C};b=new s(t,n,i),m={type:"quintic",params:i}}}else{const t=4*(e*this.config.lattice.numLatitudes+c),i=4*(v*this.config.lattice.numLatitudes+E),s={pos:new THREE.Vector2(l[t],l[t+1]),rot:l[t+2],curv:l[t+3]},o={pos:new THREE.Vector2(l[i],l[i+1]),rot:l[i+2],curv:l[i+3]},r=v*this.config.lattice.numLatitudes+E,h=4*(((e-v+this.config.lattice.stationConnectivity)*this.config.lattice.latitudeConnectivity+c-E+Math.floor(this.config.lattice.latitudeConnectivity/2))*this.config.lattice.numStations*this.config.lattice.numLatitudes+r);C=n[h+2],b=new a.a(s,o,{p1:n[h],p2:n[h+1],sG:C})}const _=b.buildPath(Math.ceil(C/this.config.pathSamplingStep)),w=y*y,R=(P*P-w)/2/C,A=C/(_.length-1);let L=0;for(let t=0;t<_.length;t++)_[t].velocity=Math.sqrt(2*R*L+w),_[t].acceleration=R,L+=A;e<0?p=_:(t>0&&_.shift(),u.push(..._))}let f=null,g=null;return h.length>=2&&(f=h[1][0]*this.config.lattice.numLatitudes+h[1][1]),h.length>=3&&(g=h[2][0]*this.config.lattice.numLatitudes+h[2][1]),[u,p,m,f,g]}}},,function(t,e,n){"use strict";n.r(e);var i=n(3);class a{constructor(){this.cars=[]}step(t){this.cars.forEach(e=>e.step(t))}createCar(){const t=new i.a;return this.cars.push(t),t}}var s=n(0);class o{constructor(t,e=0,n=0){this.poses=t;for(let i=0;i<t.length;i++){const a=t[i];if(void 0===a.rot){let s;if(0==i)s=e;else if(i==t.length-1)s=n;else{const e=t[i-1].pos,n=t[i+1].pos;s=Math.atan2(n.y-e.y,n.x-e.x)}a.rot=s}a.frontPos=s.a.getFrontAxlePosition(a.pos,a.rot),a.fakePos=s.a.getFakeAxlePosition(a.pos,a.rot)}}}n(1);class r{constructor(t,e){this.path=t,this.car=e,this.nextIndex=1,this.prevVelocity=0,this.prevAccel=0}reset(){this.prevVelocity=0,this.prevAccel=0}replacePath(t){this.path=t,this.nextIndex=1}predictPoseAfterTime(t,e){const n=this.path.poses;let[i,a]=this.findNextIndex(t.pos),s=t.velocity;if(s<=.01)return t;for(;e>0;){const t=n[i-1],o=n[i],r=o.pos.distanceTo(t.pos),l=r*(1-a),c=s+o.velocity,h=2*l/(0==c?.01:c);if(h>=e||i+1>=n.length){const n=a+c/2*e/r,i=Math.wrapAngle(t.rot+Math.wrapAngle(o.rot-t.rot)*n);return{pos:o.pos.clone().sub(t.pos).multiplyScalar(n).add(o.pos),rot:i,curv:t.curv+(o.curv-t.curv)*n,dCurv:0,ddCurv:0,velocity:o.velocity}}s=o.velocity,e-=h,a=0,i++}}control(t,e,n,i,a=!1){const o=this.path.poses,[r,l,c]=this.findNextIndex(t.pos);this.nextIndex=r;const h=o[r-1],d=o[r];let u=0,p=0,m=0;if(r>=o.length-1&&l>=1)p=1;else{const t=4,o=.5,r=.5,f=.5,g=(n-this.prevVelocity)/i,y=d.pos.distanceTo(h.pos),v=t*(Math.sqrt(2*d.acceleration*y*Math.clamp(l,0,1)+h.velocity*h.velocity)-n)+o*(d.acceleration-g)+r*d.acceleration,E=this.prevAccel*(1-f)+v*f;E>0?u=Math.min(E/s.a.MAX_GAS_ACCEL,1):p=Math.min(-E/s.a.MAX_BRAKE_DECEL,1),this.prevVelocity=n;const x=h.curv+(d.curv-h.curv)*l,T=Math.atan(x*s.a.WHEEL_BASE)-e;if(m=Math.clamp(T/i/s.a.MAX_STEER_SPEED,-1,1),a){const t=.1,e=Math.wrapAngle(h.rot+Math.wrapAngle(d.rot-h.rot)*l),n=new THREE.Vector2(c.x-s.a.REAR_AXLE_POS*Math.cos(e),c.y-s.a.REAR_AXLE_POS*Math.sin(e));Math.abs(Math.wrapAngle(e-this.car.rotation))>.5&&console.log("wut"),this.car.rotation+=t*Math.wrapAngle(e-this.car.rotation),this.car.position=this.car.position.clone().multiplyScalar(1-t).add(n.multiplyScalar(t))}}return{gas:u,brake:p,steer:m}}findNextIndex(t){const e=this.path.poses,n=Math.max(0,this.nextIndex-20),i=Math.min(e.length-1,this.nextIndex+20);let a=t.distanceToSquared(e[n].pos),s=n;for(let o=n+1;o<i;o++){const n=t.distanceToSquared(e[o].pos);n<a&&(a=n,s=o)}if(s==e.length-1){const[n,i]=l(t,e[s-1].pos,e[s].pos);return[s,i,n]}if(0==s){const[n,i]=l(t,e[s].pos,e[s+1].pos);return[s+1,i,n]}{const[n,i]=l(t,e[s-1].pos,e[s].pos),[a,o]=l(t,e[s].pos,e[s+1].pos);return t.distanceToSquared(n)<t.distanceToSquared(a)?[s,i,n]:[s+1,o,a]}}}function l(t,e,n){const i=e.distanceToSquared(n),a=t.clone().sub(e).dot(n.clone().sub(e))/i;return[n.clone().sub(e).multiplyScalar(a).add(e),a]}class c{constructor(){this.carKeys={forward:!1,backward:!1,left:!1,right:!1,brake:!1},document.addEventListener("keydown",t=>{switch(t.key){case"w":case"W":this.carKeys.forward=!0;break;case"s":case"S":this.carKeys.backward=!0;break;case"a":case"A":this.carKeys.left=!0;break;case"d":case"D":this.carKeys.right=!0;break;case" ":this.carKeys.brake=!0}}),document.addEventListener("keyup",t=>{switch(t.key){case"w":case"W":this.carKeys.forward=!1;break;case"s":case"S":this.carKeys.backward=!1;break;case"a":case"A":this.carKeys.left=!1;break;case"d":case"D":this.carKeys.right=!1;break;case" ":this.carKeys.brake=!1}})}control(){let t=0,e=0,n=0;return this.carKeys.forward&&(t+=1),this.carKeys.backward&&(t-=1),this.carKeys.left&&(n-=1),this.carKeys.right&&(n+=1),this.carKeys.brake&&(e+=1),{gas:t,brake:e,steer:n}}}class h extends THREE.Object3D{constructor(t){super(),this.geolocation=t,this.tilesGroup=null;const e=this.tileSizeInMeters(),n=new THREE.GridHelper(4*h.HALF_NUM_TILES*e,4*h.HALF_NUM_TILES,3355443,3355443);n.renderOrder=-1,n.material.depthTest=!1,n.position.add(new THREE.Vector3(-e/2,0,-e/2)),this.add(n),this.drawTiles()}static geoToWorld(t){const e=t[0]*Math.PI/180;return[(t[1]+180)/360*256,(1-Math.log(Math.tan(e)+1/Math.cos(e))/Math.PI)/2*256]}static worldToTile(t){return[Math.floor(t[0]*h.SCALE/256),Math.floor(t[1]*h.SCALE/256)]}drawTiles(){null!=this.tileGroup&&this.remove(this.tilesGroup),this.tileGroup=new THREE.Group;const t=h.worldToTile(h.geoToWorld(this.geolocation)),e=this.tileSizeInMeters();for(let n=-h.HALF_NUM_TILES;n<h.HALF_NUM_TILES;n++)for(let i=-h.HALF_NUM_TILES;i<h.HALF_NUM_TILES;i++){const a=(new THREE.TextureLoader).load(`https://khms0.google.com/kh/v=748?x=${t[0]+n}&y=${t[1]+i}&z=${h.ZOOM}`);a.anisotropy=16;const s=new THREE.PlaneBufferGeometry(e,e),o=new THREE.MeshBasicMaterial({map:a,color:16777215}),r=new THREE.Mesh(s,o);r.rotation.x=-Math.PI/2,r.position.x=n*e,r.position.z=i*e,this.tileGroup.add(r)}this.add(this.tileGroup)}tileSizeInMeters(){return 2*Math.PI*h.EARTH_RADIUS*Math.cos(this.geolocation[0]*Math.PI/180)/Math.pow(2,h.ZOOM)}}h.EARTH_RADIUS=6378137,h.TILE_PIXELS=256,h.ZOOM=20,h.SCALE=1<<h.ZOOM,h.HALF_NUM_TILES=20;class d extends THREE.Object3D{constructor(t){super(),this.car=t;const e=new THREE.Mesh(new THREE.PlaneGeometry(2*s.a.HALF_CAR_LENGTH,2*s.a.HALF_CAR_WIDTH),new THREE.MeshBasicMaterial({color:33023,depthTest:!1,transparent:!0,opacity:.5}));e.rotation.x=-Math.PI/2,this.add(e);const n=new THREE.PlaneGeometry(2*s.a.HALF_WHEEL_LENGTH,2*s.a.HALF_WHEEL_WIDTH),i=new THREE.MeshBasicMaterial({color:16744448,depthTest:!1,transparent:!0,opacity:.7});this.lfWheel=new THREE.Mesh(n,i),this.lfWheel.renderOrder=1,this.lfWheel.position.set(s.a.FRONT_AXLE_POS,0,s.a.WHEEL_LATERAL_POS),this.lfWheel.rotation.x=-Math.PI/2,this.add(this.lfWheel),this.rfWheel=new THREE.Mesh(n,i),this.rfWheel.renderOrder=1,this.rfWheel.position.set(s.a.FRONT_AXLE_POS,0,-s.a.WHEEL_LATERAL_POS),this.rfWheel.rotation.x=-Math.PI/2,this.add(this.rfWheel);const a=new THREE.Mesh(n,i);a.renderOrder=1,a.position.set(s.a.REAR_AXLE_POS,0,s.a.WHEEL_LATERAL_POS),a.rotation.x=-Math.PI/2,this.add(a);const o=new THREE.Mesh(n,i);o.renderOrder=1,o.position.set(s.a.REAR_AXLE_POS,0,-s.a.WHEEL_LATERAL_POS),o.rotation.x=-Math.PI/2,this.add(o)}updateMatrix(){this.updateCar(),super.updateMatrix()}updateCar(){const t=this.car.position;this.position.set(t.x,0,t.y),this.rotation.y=-this.car.rotation;const e=this.car.wheelAngle;this.lfWheel.rotation.z=-e,this.rfWheel.rotation.z=-e}}var u=n(4);const p=new THREE.Plane(new THREE.Vector3(0,1,0));class m{constructor(t,e,n){this.canvas=t,this.camera=e,this.raycaster=new THREE.Raycaster,this.mouse=new THREE.Vector2,this.dragOffset=new THREE.Vector3,this.draggingPoint=null,this.pointIndex=0,this.centerlineGeometry=new THREE.Geometry,this.leftBoundaryGeometry=new THREE.Geometry,this.rightBoundaryGeometry=new THREE.Geometry,this.points=[],this.enabled=!1,this.group=new THREE.Group,this.pointsGroup=new THREE.Group,this.group.add(this.pointsGroup),n.add(this.group),this.lanePath=new u.a,this.mouseDown=this.mouseDown.bind(this),this.mouseMove=this.mouseMove.bind(this),this.mouseUp=this.mouseUp.bind(this),t.addEventListener("mousedown",this.mouseDown),t.addEventListener("mousemove",this.mouseMove),t.addEventListener("mouseup",this.mouseUp),t.addEventListener("contextmenu",t=>this.enabled&&t.preventDefault());const i=document.getElementById("editor-clear-options");document.getElementById("editor-clear").addEventListener("click",t=>{t.stopPropagation(),i.classList.toggle("is-hidden")}),document.addEventListener("click",()=>i.classList.add("is-hidden")),this.centerlineObject=new THREE.Mesh(new THREE.Geometry,new MeshLineMaterial({color:new THREE.Color(16512),lineWidth:.2,depthTest:!1,transparent:!0,opacity:.7,resolution:new THREE.Vector2(this.canvas.clientWidth,this.canvas.clientHeight)})),this.centerlineObject.rotation.x=Math.PI/2,this.centerlineObject.renderOrder=1,this.group.add(this.centerlineObject),this.leftBoundaryObject=new THREE.Mesh(new THREE.Geometry,new MeshLineMaterial({color:new THREE.Color(16744448),lineWidth:.15,depthTest:!1,transparent:!0,opacity:.7,resolution:new THREE.Vector2(this.canvas.clientWidth,this.canvas.clientHeight)})),this.leftBoundaryObject.rotation.x=Math.PI/2,this.leftBoundaryObject.renderOrder=1,this.group.add(this.leftBoundaryObject),this.rightBoundaryObject=new THREE.Mesh(new THREE.Geometry,new MeshLineMaterial({color:new THREE.Color(16744448),lineWidth:.15,depthTest:!1,transparent:!0,opacity:.7,resolution:new THREE.Vector2(this.canvas.clientWidth,this.canvas.clientHeight)})),this.rightBoundaryObject.rotation.x=Math.PI/2,this.rightBoundaryObject.renderOrder=1,this.group.add(this.rightBoundaryObject)}redraw(){this.centerlineGeometry.setFromPoints(this.lanePath.centerline);const t=new MeshLine;t.setGeometry(this.centerlineGeometry),this.centerlineObject.geometry=t.geometry,this.leftBoundaryGeometry.setFromPoints(this.lanePath.leftBoundary);const e=new MeshLine;e.setGeometry(this.leftBoundaryGeometry),this.leftBoundaryObject.geometry=e.geometry,this.rightBoundaryGeometry.setFromPoints(this.lanePath.rightBoundary);const n=new MeshLine;n.setGeometry(this.rightBoundaryGeometry),this.rightBoundaryObject.geometry=n.geometry}addPoint(t){const e=new THREE.Mesh(new THREE.CircleGeometry(.4,32),new THREE.MeshBasicMaterial({color:33023,depthTest:!1,transparent:!0,opacity:.7}));return e.rotation.x=-Math.PI/2,e.position.set(t.x,0,t.y),e.userData={index:this.pointIndex++},this.pointsGroup.add(e),this.points.push(e),this.lanePath.addAnchor(t),e}updatePoint(t,e){t.position.copy(e),this.lanePath.updateAnchor(t.userData.index,new THREE.Vector2(e.x,e.z))}clearPoints(){this.centerlineObject.geometry=new THREE.Geometry,this.group.remove(this.pointsGroup),this.pointsGroup=new THREE.Group,this.points=[],this.pointIndex=0,this.lanePath=new u.a}loadPoints(t){this.clearPoints(),t.forEach(t=>this.addPoint(new THREE.Vector2(t.x,t.y))),this.redraw()}mouseDown(t){if(!this.enabled||0!=t.button)return;this.mouse.x=t.offsetX/this.canvas.clientWidth*2-1,this.mouse.y=-t.offsetY/this.canvas.clientHeight*2+1,this.raycaster.setFromCamera(this.mouse,this.camera);const e=this.raycaster.intersectObjects(this.points)[0];if(e)this.draggingPoint=e.object,this.dragOffset.copy(e.object.position).sub(e.point),t.stopImmediatePropagation();else{const t=this.raycaster.ray.intersectPlane(p);null!=t&&(this.addPoint(new THREE.Vector2(t.x,t.z)),this.redraw())}}mouseMove(t){if(!this.enabled||null==this.draggingPoint)return;this.mouse.x=t.offsetX/this.canvas.clientWidth*2-1,this.mouse.y=-t.offsetY/this.canvas.clientHeight*2+1,this.raycaster.setFromCamera(this.mouse,this.camera);const e=this.raycaster.ray.intersectPlane(p);null!=e&&(this.updatePoint(this.draggingPoint,e.add(this.dragOffset)),this.redraw())}mouseUp(t){this.enabled&&0==t.button&&(this.draggingPoint=null)}}const f=function(t,e){var n,i,a,s,o;this.object=t,this.domElement=void 0!==e?e:document,this.enabled=!0,this.target=new THREE.Vector3,this.minDistance=0,this.maxDistance=1/0,this.minZoom=0,this.maxZoom=1/0,this.minPolarAngle=0,this.maxPolarAngle=Math.PI,this.minAzimuthAngle=-1/0,this.maxAzimuthAngle=1/0,this.enableDamping=!1,this.dampingFactor=.25,this.enableZoom=!0,this.zoomSpeed=1,this.enableRotate=!0,this.rotateSpeed=1,this.enablePan=!0,this.keyPanSpeed=7,this.autoRotate=!1,this.autoRotateSpeed=2,this.enableKeys=!0,this.keys={LEFT:37,UP:38,RIGHT:39,BOTTOM:40},this.mouseButtons={ORBIT:THREE.MOUSE.LEFT,ZOOM:THREE.MOUSE.MIDDLE,PAN:THREE.MOUSE.RIGHT},this.target0=this.target.clone(),this.position0=this.object.position.clone(),this.zoom0=this.object.zoom,this.getPolarAngle=function(){return m.phi},this.getAzimuthalAngle=function(){return m.theta},this.saveState=function(){r.target0.copy(r.target),r.position0.copy(r.object.position),r.zoom0=r.object.zoom},this.reset=function(){r.target.copy(r.target0),r.object.position.copy(r.position0),r.object.zoom=r.zoom0,r.object.updateProjectionMatrix(),r.dispatchEvent(l),r.update(),u=d.NONE},this.rotateLeft=function(t){A(t)},this.update=(n=new THREE.Vector3,i=(new THREE.Quaternion).setFromUnitVectors(t.up,new THREE.Vector3(0,1,0)),a=i.clone().inverse(),s=new THREE.Vector3,o=new THREE.Quaternion,function(){var t=r.object.position;return n.copy(t).sub(r.target),n.applyQuaternion(i),m.setFromVector3(n),r.autoRotate&&u===d.NONE&&A(2*Math.PI/60/60*r.autoRotateSpeed),m.theta+=f.theta,m.phi+=f.phi,m.theta=Math.max(r.minAzimuthAngle,Math.min(r.maxAzimuthAngle,m.theta)),m.phi=Math.max(r.minPolarAngle,Math.min(r.maxPolarAngle,m.phi)),m.makeSafe(),m.radius*=g,m.radius=Math.max(r.minDistance,Math.min(r.maxDistance,m.radius)),r.target.add(y),n.setFromSpherical(m),n.applyQuaternion(a),t.copy(r.target).add(n),r.object.lookAt(r.target),!0===r.enableDamping?(f.theta*=1-r.dampingFactor,f.phi*=1-r.dampingFactor):f.set(0,0,0),g=1,y.set(0,0,0),!!(v||s.distanceToSquared(r.object.position)>p||8*(1-o.dot(r.object.quaternion))>p)&&(r.dispatchEvent(l),s.copy(r.object.position),o.copy(r.object.quaternion),v=!1,!0)}),this.dispose=function(){r.domElement.removeEventListener("contextmenu",j,!1),r.domElement.removeEventListener("mousedown",F,!1),r.domElement.removeEventListener("wheel",z,!1),r.domElement.removeEventListener("touchstart",B,!1),r.domElement.removeEventListener("touchend",W,!1),r.domElement.removeEventListener("touchmove",U,!1),document.removeEventListener("mousemove",V,!1),document.removeEventListener("mouseup",N,!1),window.removeEventListener("keydown",k,!1)};var r=this,l={type:"change"},c={type:"start"},h={type:"end"},d={NONE:-1,ROTATE:0,DOLLY:1,PAN:2,TOUCH_ROTATE:3,TOUCH_DOLLY:4,TOUCH_PAN:5},u=d.NONE,p=1e-6,m=new THREE.Spherical,f=new THREE.Spherical,g=1,y=new THREE.Vector3,v=!1,E=new THREE.Vector2,x=new THREE.Vector2,T=new THREE.Vector2,S=new THREE.Vector2,P=new THREE.Vector2,C=new THREE.Vector2,b=new THREE.Vector2,_=new THREE.Vector2,w=new THREE.Vector2;function R(){return Math.pow(.95,r.zoomSpeed)}function A(t){f.theta-=t}function L(t){f.phi-=t}var I,M=(I=new THREE.Vector3,function(t,e){I.setFromMatrixColumn(e,0),I.multiplyScalar(-t),y.add(I)}),G=function(){var t=new THREE.Vector3;return function(e,n){t.setFromMatrixColumn(n,1),t.multiplyScalar(e),y.add(t)}}(),O=function(){var t=new THREE.Vector3;return function(e,n){var i=r.domElement===document?r.domElement.body:r.domElement;if(r.object.isPerspectiveCamera){var a=r.object.position;t.copy(a).sub(r.target);var s=t.length();s*=Math.tan(r.object.fov/2*Math.PI/180),M(2*e*s/i.clientHeight,r.object.matrix),G(2*n*s/i.clientHeight,r.object.matrix)}else r.object.isOrthographicCamera?(M(e*(r.object.right-r.object.left)/r.object.zoom/i.clientWidth,r.object.matrix),G(n*(r.object.top-r.object.bottom)/r.object.zoom/i.clientHeight,r.object.matrix)):(console.warn("WARNING: OrbitControls.js encountered an unknown camera type - pan disabled."),r.enablePan=!1)}}();function H(t){r.object.isPerspectiveCamera?g/=t:r.object.isOrthographicCamera?(r.object.zoom=Math.max(r.minZoom,Math.min(r.maxZoom,r.object.zoom*t)),r.object.updateProjectionMatrix(),v=!0):(console.warn("WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled."),r.enableZoom=!1)}function D(t){r.object.isPerspectiveCamera?g*=t:r.object.isOrthographicCamera?(r.object.zoom=Math.max(r.minZoom,Math.min(r.maxZoom,r.object.zoom/t)),r.object.updateProjectionMatrix(),v=!0):(console.warn("WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled."),r.enableZoom=!1)}function F(t){if(!1!==r.enabled){switch(t.preventDefault(),t.button){case r.mouseButtons.ORBIT:if(!1===r.enableRotate)return;!function(t){E.set(t.clientX,t.clientY)}(t),u=d.ROTATE;break;case r.mouseButtons.ZOOM:if(!1===r.enableZoom)return;!function(t){b.set(t.clientX,t.clientY)}(t),u=d.DOLLY;break;case r.mouseButtons.PAN:if(!1===r.enablePan)return;!function(t){S.set(t.clientX,t.clientY)}(t),u=d.PAN}u!==d.NONE&&(document.addEventListener("mousemove",V,!1),document.addEventListener("mouseup",N,!1),r.dispatchEvent(c))}}function V(t){if(!1!==r.enabled)switch(t.preventDefault(),u){case d.ROTATE:if(!1===r.enableRotate)return;!function(t){x.set(t.clientX,t.clientY),T.subVectors(x,E);var e=r.domElement===document?r.domElement.body:r.domElement;A(2*Math.PI*T.x/e.clientWidth*r.rotateSpeed),L(2*Math.PI*T.y/e.clientHeight*r.rotateSpeed),E.copy(x),r.update()}(t);break;case d.DOLLY:if(!1===r.enableZoom)return;!function(t){_.set(t.clientX,t.clientY),w.subVectors(_,b),w.y>0?H(R()):w.y<0&&D(R()),b.copy(_),r.update()}(t);break;case d.PAN:if(!1===r.enablePan)return;!function(t){P.set(t.clientX,t.clientY),C.subVectors(P,S),O(C.x,C.y),S.copy(P),r.update()}(t)}}function N(t){!1!==r.enabled&&(document.removeEventListener("mousemove",V,!1),document.removeEventListener("mouseup",N,!1),r.dispatchEvent(h),u=d.NONE)}function z(t){!1===r.enabled||!1===r.enableZoom||u!==d.NONE&&u!==d.ROTATE||(t.preventDefault(),t.stopPropagation(),function(t){t.deltaY<0?D(R()):t.deltaY>0&&H(R()),r.update()}(t),r.dispatchEvent(c),r.dispatchEvent(h))}function k(t){!1!==r.enabled&&!1!==r.enableKeys&&!1!==r.enablePan&&function(t){switch(t.keyCode){case r.keys.UP:O(0,r.keyPanSpeed),r.update();break;case r.keys.BOTTOM:O(0,-r.keyPanSpeed),r.update();break;case r.keys.LEFT:O(r.keyPanSpeed,0),r.update();break;case r.keys.RIGHT:O(-r.keyPanSpeed,0),r.update()}}(t)}function B(t){if(!1!==r.enabled){switch(t.touches.length){case 1:if(!1===r.enableRotate)return;!function(t){E.set(t.touches[0].pageX,t.touches[0].pageY)}(t),u=d.TOUCH_ROTATE;break;case 2:if(!1===r.enableZoom)return;!function(t){var e=t.touches[0].pageX-t.touches[1].pageX,n=t.touches[0].pageY-t.touches[1].pageY,i=Math.sqrt(e*e+n*n);b.set(0,i)}(t),u=d.TOUCH_DOLLY;break;case 3:if(!1===r.enablePan)return;!function(t){S.set(t.touches[0].pageX,t.touches[0].pageY)}(t),u=d.TOUCH_PAN;break;default:u=d.NONE}u!==d.NONE&&r.dispatchEvent(c)}}function U(t){if(!1!==r.enabled)switch(t.preventDefault(),t.stopPropagation(),t.touches.length){case 1:if(!1===r.enableRotate)return;if(u!==d.TOUCH_ROTATE)return;!function(t){x.set(t.touches[0].pageX,t.touches[0].pageY),T.subVectors(x,E);var e=r.domElement===document?r.domElement.body:r.domElement;A(2*Math.PI*T.x/e.clientWidth*r.rotateSpeed),L(2*Math.PI*T.y/e.clientHeight*r.rotateSpeed),E.copy(x),r.update()}(t);break;case 2:if(!1===r.enableZoom)return;if(u!==d.TOUCH_DOLLY)return;!function(t){var e=t.touches[0].pageX-t.touches[1].pageX,n=t.touches[0].pageY-t.touches[1].pageY,i=Math.sqrt(e*e+n*n);_.set(0,i),w.subVectors(_,b),w.y>0?D(R()):w.y<0&&H(R()),b.copy(_),r.update()}(t);break;case 3:if(!1===r.enablePan)return;if(u!==d.TOUCH_PAN)return;!function(t){P.set(t.touches[0].pageX,t.touches[0].pageY),C.subVectors(P,S),O(C.x,C.y),S.copy(P),r.update()}(t);break;default:u=d.NONE}}function W(t){!1!==r.enabled&&(r.dispatchEvent(h),u=d.NONE)}function j(t){!1!==r.enabled&&t.preventDefault()}r.domElement.addEventListener("contextmenu",j,!1),r.domElement.addEventListener("mousedown",F,!1),r.domElement.addEventListener("wheel",z,!1),r.domElement.addEventListener("touchstart",B,!1),r.domElement.addEventListener("touchend",W,!1),r.domElement.addEventListener("touchmove",U,!1),window.addEventListener("keydown",k,!1),this.update()};(f.prototype=Object.create(THREE.EventDispatcher.prototype)).constructor=f,Object.defineProperties(f.prototype,{center:{get:function(){return console.warn("OrbitControls: .center has been renamed to .target"),this.target}},noZoom:{get:function(){return console.warn("OrbitControls: .noZoom has been deprecated. Use .enableZoom instead."),!this.enableZoom},set:function(t){console.warn("OrbitControls: .noZoom has been deprecated. Use .enableZoom instead."),this.enableZoom=!t}},noRotate:{get:function(){return console.warn("OrbitControls: .noRotate has been deprecated. Use .enableRotate instead."),!this.enableRotate},set:function(t){console.warn("OrbitControls: .noRotate has been deprecated. Use .enableRotate instead."),this.enableRotate=!t}},noPan:{get:function(){return console.warn("OrbitControls: .noPan has been deprecated. Use .enablePan instead."),!this.enablePan},set:function(t){console.warn("OrbitControls: .noPan has been deprecated. Use .enablePan instead."),this.enablePan=!t}},noKeys:{get:function(){return console.warn("OrbitControls: .noKeys has been deprecated. Use .enableKeys instead."),!this.enableKeys},set:function(t){console.warn("OrbitControls: .noKeys has been deprecated. Use .enableKeys instead."),this.enableKeys=!t}},staticMoving:{get:function(){return console.warn("OrbitControls: .staticMoving has been deprecated. Use .enableDamping instead."),!this.enableDamping},set:function(t){console.warn("OrbitControls: .staticMoving has been deprecated. Use .enableDamping instead."),this.enableDamping=!t}},dynamicDampingFactor:{get:function(){return console.warn("OrbitControls: .dynamicDampingFactor has been renamed. Use .dampingFactor instead."),this.dampingFactor},set:function(t){console.warn("OrbitControls: .dynamicDampingFactor has been renamed. Use .dampingFactor instead."),this.dampingFactor=t}}});var g=f;const y=new THREE.Plane(new THREE.Vector3(0,1,0));let v=!1;class E{constructor(t,e){this.domElement=t,this.camera=e,this.enablePanning=!1,this.enabled=!0,this.mouseDown=this.mouseDown.bind(this),this.mouseMove=this.mouseMove.bind(this),this.mouseUp=this.mouseUp.bind(this),this.wheel=this.wheel.bind(this),this.domElement.addEventListener("mousedown",this.mouseDown),this.domElement.addEventListener("mousemove",this.mouseMove),this.domElement.addEventListener("mouseup",this.mouseUp),this.domElement.addEventListener("wheel",this.wheel)}reset(t){const e=new THREE.Vector3(0,0,-1);e.applyQuaternion(t.quaternion);const n=new THREE.Ray(t.position,e).intersectPlane(y);n?this.camera.position.set(n.x,50,n.z):this.camera.position.y=50,this.camera.rotation.set(-Math.PI/2,0,0)}mouseDown(t){this.enabled&&this.enablePanning&&2==t.button&&(v=!0)}mouseMove(t){if(v){const e=2*this.camera.position.y*Math.tan(this.camera.fov/2*Math.PI/180)/this.domElement.clientHeight;this.camera.position.x-=e*t.movementX,this.camera.position.z-=e*t.movementY}}mouseUp(t){2==t.button&&(v=!1)}wheel(t){this.enabled&&(t.preventDefault(),this.camera.position.y*=Math.pow(.995,-t.deltaY))}}const x=2.23694,T=3.28084;class S{constructor(t){this.car=t,this.units="metric","complete"==document.readyState?this.fetchDomElements.call(this):document.addEventListener("readystatechange",t=>{"complete"==t.target.readyState&&this.fetchDomElements.call(this)})}fetchDomElements(){this.wheelDom=document.getElementById("wheel"),this.wheelPieDom=document.getElementById("wheel-pie"),this.wheelPieLeftDom=document.getElementById("wheel-pie-left"),this.wheelPieRightDom=document.getElementById("wheel-pie-right"),this.gearDom=document.getElementById("gear"),this.gasDom=document.getElementById("gas"),this.brakeDom=document.getElementById("brake"),this.speedDom=document.getElementById("speed"),this.stationDom=document.getElementById("station"),this.latitudeDom=document.getElementById("latitude"),this.planTimeDom=document.getElementById("plan-time"),this.elapsedTimeDom=document.getElementById("elapsed-time"),this.speedUnitsDom=document.getElementById("speed-units"),this.stationUnitsDom=document.getElementById("station-units"),this.latitudeUnitsDom=document.getElementById("latitude-units"),[this.speedUnitsDom,this.stationUnitsDom,this.latitudeUnitsDom].forEach(t=>{t.addEventListener("click",t=>{this.toggleUnits()})})}toggleUnits(){let t,e;"metric"==this.units?(this.units="imperial",t="mph",e="feet"):(this.units="metric",t="m/s",e="meters"),this.speedUnitsDom.innerHTML=t,this.stationUnitsDom.innerHTML=e,this.latitudeUnitsDom.innerHTML=e}update(t,e,n,i,a,o){if(!this.wheelDom)return;"imperial"==this.units&&(e*=x,n=null!==n?n*T:null,i=null!==i?i*T:null);const r=Math.clamp(this.car.wheelAngle/s.a.MAX_WHEEL_ANGLE*.95,-1,1);this.wheelDom.style.transform=`rotate(${r}turn)`,r>=0?(this.wheelPieRightDom.style.transform=`rotate(${r}turn)`,r<=.5?(this.wheelPieDom.style.clipPath="inset(0 0 0 50%)",this.wheelPieLeftDom.style.transform="rotate(0)"):(this.wheelPieDom.style.clipPath="inset(0 0 0 0)",this.wheelPieLeftDom.style.transform="rotate(0.5turn)")):(this.wheelPieRightDom.style.transform=`rotate(${.5+r}turn)`,r>=-.5?(this.wheelPieDom.style.clipPath="inset(0 50% 0 0)",this.wheelPieLeftDom.style.transform="rotate(0.5turn)"):(this.wheelPieDom.style.clipPath="inset(0 0 0 0)",this.wheelPieLeftDom.style.transform="rotate(0)")),this.gearDom.innerText=t.gas<0?"R":"D",this.brakeDom.style.clipPath=`inset(50% 50% 0 ${50-25*t.brake}%)`,this.gasDom.style.clipPath=`inset(50% ${50-25*Math.abs(t.gas)}% 0 50%)`,this.speedDom.innerHTML=e.toFixed(1),this.stationDom.innerHTML=null!==n?n.toFixed(1):"&mdash;",this.latitudeDom.innerHTML=null!==i?i.toFixed(2):"&mdash;",this.planTimeDom.innerHTML=null!==o?(1e3*o).toFixed(0):"&mdash;";let l=Math.floor(a/60),c=a%60;0==l?this.elapsedTimeDom.innerHTML=c.toFixed(1):(c=c<10?"0"+c.toFixed(1):c.toFixed(1),this.elapsedTimeDom.innerHTML=`${l}:${c}`)}}n(2);var P=class{constructor(t,e){const n=t.sampleStations(e,10,10),i=new Array(10),a=Math.floor(9.5);for(let t=0;t<10;t++){const e=n[t],s=i[t]=new Array(19);for(let t=0;t<19;t++){const n=(t-a)/a*3.7/2,i=e.rot,o=THREE.Vector2.fromAngle(i+Math.PI/2).multiplyScalar(n).add(e.pos),r=0==e.curv?0:1/(1/e.curv-n);s[t]={pos:o,rot:i,curv:r}}}this.lattice=i}},C=(n(6),n(5));class b{constructor(t){this.samples=new Array(t),this.numSamples=0,this.nextIndex=0,this.average=null}addSample(t){this.samples[this.nextIndex++]=t,this.nextIndex=this.nextIndex%this.samples.length,this.numSamples=Math.min(this.numSamples+1,this.samples.length);const e=2/(this.numSamples+1);let n=this.nextIndex%this.numSamples,i=this.samples[n];for(let t=1;t<this.numSamples;t++)n=(n+1)%this.numSamples,i=this.samples[n]*e+i*(1-e);this.average=i}}const _="dashPathPlannerConfig",w={lattice:{numStations:10,numLatitudes:11,stationConnectivity:3,latitudeConnectivity:5},dCurvatureMax:s.a.MAX_STEER_SPEED/s.a.WHEEL_BASE,rearAxleToCenter:-s.a.REAR_AXLE_POS},R={spatialHorizon:100,centerlineStationInterval:.5,xyGridCellSize:.1,slGridCellSize:.05,gridMargin:10,pathSamplingStep:.5,cubicPathPenalty:10,lethalDilationS:s.a.HALF_CAR_LENGTH+1,hazardDilationS:12,lethalDilationL:s.a.HALF_CAR_WIDTH+.25,hazardDilationL:.5,obstacleHazardCost:3,laneWidth:3.7,laneShoulderCost:1,laneShoulderLatitude:1.85-s.a.HALF_CAR_WIDTH,laneCostSlope:5,stationReachDiscount:70,extraTimePenalty:64,hysteresisDiscount:40,speedLimit:20,speedLimitPenalty:2,hardAccelerationPenalty:6,hardDecelerationPenalty:6,lateralAccelerationLimit:3,softLateralAccelerationPenalty:4,linearLateralAccelerationPenalty:4,accelerationChangePenalty:2};class A{constructor(){this._config=Object.assign({},R),this.showConfigBox=document.getElementById("show-config-box"),this.configBox=document.getElementById("config-box-content"),this.configForm=document.getElementById("config-form"),this._setUpButtons();let t={};try{t=JSON.parse(window.localStorage.getItem(_))||{}}catch(t){}for(const e of Object.keys(this._config).sort())void 0!==t[e]&&(this._config[e]=t[e]),this.configForm.appendChild(this._createConfigField(e,this._config[e]))}get config(){return Object.assign({},this._config,w)}_setUpButtons(){document.getElementById("show-config-button").addEventListener("click",t=>{this.showConfigBox.classList.add("is-hidden"),this.configBox.classList.remove("is-hidden")}),document.getElementById("hide-config-button").addEventListener("click",t=>{this.showConfigBox.classList.remove("is-hidden"),this.configBox.classList.add("is-hidden")}),document.getElementById("save-config-button").addEventListener("click",this._saveConfigFields.bind(this)),document.getElementById("restore-defaults-config-button").addEventListener("click",this._restoreDefaults.bind(this))}_createConfigField(t,e){const n=`<div class="field is-horizontal">\n          <div class="field-label is-small" style="flex-grow: 100;">\n              <label class="label has-text-grey-light" for="config-field-${t}">${t}</label>\n          </div>\n          <div class="field-body">\n              <div class="field">\n                  <div class="control" style="margin-right: 16px;">\n                      <input id="config-field-${t}" name="${t}" class="input is-small ${e!=R[t]?"is-danger":""}" type="text" style="width: 60px; border-width: 2px;" value="${e}" />\n                  </div>\n              </div>\n          </div>\n      </div>`,i=document.createElement("template");return i.innerHTML=n,i.content.firstChild}_saveConfigFields(){const t=new FormData(this.configForm);for(const[e,n]of t.entries()){this._config[e]=Number.parseFloat(n);const t=document.getElementById(`config-field-${e}`);n==R[e]?t.classList.remove("is-danger"):t.classList.add("is-danger")}try{window.localStorage.setItem(_,JSON.stringify(this._config))}catch(t){}}_restoreDefaults(){this._config=R;try{window.localStorage.removeItem(_)}catch(t){}for(;this.configForm.firstChild;)this.configForm.removeChild(this.configForm.firstChild);for(const t of Object.keys(this._config).sort())this.configForm.appendChild(this._createConfigField(t,this._config[t]))}}const L=1/60;document.addEventListener("DOMContentLoaded",t=>{window.simulator=new class{constructor(t,e){this.geolocation=t,this.pathPlannerWorker=new Worker("dist/PathPlannerWorker.js"),this.pathPlannerWorker.onmessage=this.receivePlannedPath.bind(this),this.pathPlannerConfigEditor=new A,this.physics=new a,this.car=this.physics.createCar(),this.renderer=new THREE.WebGLRenderer,this.renderer.setPixelRatio(window.devicePixelRatio),this.renderer.setSize(e.clientWidth,e.clientHeight),this.renderer.shadowMap.enabled=!0,e.appendChild(this.renderer.domElement),this.lastPlanParams=null,this.renderer.context.canvas.addEventListener("webglcontextlost",t=>{console.log("Simulator: webgl context lost"),console.log(t),console.log(this.lastPlanParams)}),this._setUpCameras(this.renderer.domElement),this.scene=new THREE.Scene,this.sceneFog=new THREE.FogExp2(1118481,.0025),this.scene.fog=this.sceneFog,this.scene.background=new THREE.Color(1118481),this.editor=new m(this.renderer.domElement,this.editorCamera,this.scene);const n=new h(this.geolocation);this.scene.add(n);const i=new d(this.car);this.scene.add(i),this.manualCarController=new c,this.autonomousCarController=null,this.dashboard=new S(this.car),this.plannerReady=!1,this.plannerReset=!1,this.plannerEnabled=!1,this.plannedPathGroup=new THREE.Group,this.scene.add(this.plannedPathGroup),this.paused=!1,this.prevTimestamp=null,this.frameCounter=0,this.fpsTime=0,this.fps=1/L,this.simulatedTime=0,this.lastPlanTime=null,this.averagePlanTime=new b(20),window.addEventListener("resize",()=>{this._updateCameraAspects(e.clientWidth/e.clientHeight),this.renderer.setSize(e.clientWidth,e.clientHeight)}),this.manualModeButton=document.getElementById("mode-manual"),this.manualModeButton.addEventListener("click",this.enableManualMode.bind(this)),this.autonomousModeButton=document.getElementById("mode-autonomous"),this.autonomousModeButton.addEventListener("click",this.enableAutonomousMode.bind(this)),document.getElementById("editor-enable").addEventListener("click",this.enableEditor.bind(this)),document.getElementById("editor-save").addEventListener("click",this.finalizeEditor.bind(this)),document.getElementById("scenario-restart").addEventListener("click",this.restartScenario.bind(this)),this.simModeBoxes=Array.prototype.slice.call(document.getElementsByClassName("sim-mode-box"),0),this.editModeBoxes=Array.prototype.slice.call(document.getElementsByClassName("edit-mode-box"),0),this.fpsBox=document.getElementById("fps"),this.enableManualMode(),this.changeCamera("chase"),this.aroundAnchorIndex=null,this.obstacles=[],requestAnimationFrame(function t(e){if(null==this.prevTimestamp)return this.prevTimestamp=e,void requestAnimationFrame(t.bind(this));if(!this.editor.enabled||this.paused){const t=L;this.simulatedTime+=t;const e=this.car.position,n=this.car.rotation,i=this.autonomousCarController?this.autonomousCarController.control(this.car.pose,this.car.wheelAngle,this.car.velocity,t,"autonomous"==this.carControllerMode):{steer:0,brake:1,gas:0},a=this.manualCarController.control(this.car.pose,this.car.wheelAngle,this.car.velocity,t),s="autonomous"==this.carControllerMode?i:a;this.car.update(s,t),this.physics.step(t);const o=this.car.position,r=this.car.rotation,l=this.car.rearAxlePosition,c=this.car.velocity,h={x:o.x-e.x,y:0,z:o.y-e.y};this.chaseCamera.position.add(h),this.chaseCameraControls.target.set(o.x,0,o.y),this.chaseCameraControls.rotateLeft(r-n),this.chaseCameraControls.update(),this.topDownCamera.position.setX(o.x),this.topDownCamera.position.setZ(o.y),this.topDownCamera.rotation.z=-r-Math.PI/2;let d=null,u=null;if(this.editor.lanePath.anchors.length>1){const[t,e,n]=this.editor.lanePath.stationLatitudeFromPosition(l,this.aroundAnchorIndex);this.aroundAnchorIndex=n,d=t,u=e}this.plannerReady&&this.startPlanner(this.car.pose,d),this.dashboard.update(s,c,d,u,this.simulatedTime,this.averagePlanTime.average)}this.frameCounter++,this.fpsTime+=e-this.prevTimestamp,this.fpsTime>=1e3&&(this.fps=this.frameCounter/(this.fpsTime/1e3),this.frameCounter=0,this.fpsTime=0,this.fpsBox.innerHTML=this.fps.toFixed(1)),this.renderer.render(this.scene,this.camera),this.prevTimestamp=e,requestAnimationFrame(t.bind(this))}.bind(this))}toss(){const t=this.car.pose,e=THREE.Vector2.fromAngle(t.rot),n=e.clone().multiplyScalar(50).add(new THREE.Vector2(e.y,e.x)).add(t.pos),i=new C.a(n,0,.5,.5),a=new THREE.PlaneGeometry(i.width,i.height),s=new THREE.MeshBasicMaterial({color:255,depthTest:!1,transparent:!0,opacity:.5}),o=new THREE.Mesh(a,s);o.rotation.x=-Math.PI/2,o.rotation.z=-i.rot,o.position.set(i.pos.x,0,i.pos.y),this.scene.add(o),this.obstacles.push(i)}_setUpCameras(t){this.chaseCamera=new THREE.PerspectiveCamera(45,t.clientWidth/t.clientHeight,1,1e4),this.chaseCameraControls=new g(this.chaseCamera,t),this.chaseCameraControls.maxPolarAngle=Math.PI/2.02,this.chaseCameraControls.enablePan=!1,this.chaseCameraControls.enabled=!1,this._resetChaseCamera(),this.freeCamera=new THREE.PerspectiveCamera(45,t.clientWidth/t.clientHeight,1,1e4),this.freeCameraControls=new g(this.freeCamera,t),this.freeCameraControls.maxPolarAngle=Math.PI/2.02,this.freeCameraControls.enabled=!0,this._resetFreeCamera(),this.topDownCamera=new THREE.PerspectiveCamera(45,t.clientWidth/t.clientHeight,1,1e4),this.topDownCamera.position.set(0,50,0),this.topDownCamera.lookAt(0,0,0),this.topDownControls=new E(t,this.topDownCamera),this.topDownControls.enabled=!1,this.editorCamera=new THREE.PerspectiveCamera(45,t.clientWidth/t.clientHeight,1,1e4),this.editorCamera.position.set(0,50,0),this.editorCamera.lookAt(0,0,0),this.editorCameraControls=new E(t,this.editorCamera),this.editorCameraControls.enabled=!1,this.editorCameraControls.enablePanning=!0,this.cameraButtons={},["free","chase","topDown"].forEach(t=>{const e=document.getElementById(`camera-${t}`);e.addEventListener("click",()=>this.changeCamera(t)),this.cameraButtons[t]=e})}_resetFreeCamera(){this.freeCameraControls.position0.copy(this.chaseCamera.position);const t=this.car.position;this.freeCameraControls.target0.set(t.x,0,t.y),this.freeCameraControls.reset()}_resetChaseCamera(){const t=this.car.position,e=THREE.Vector2.fromAngle(this.car.rotation).multiplyScalar(-20);this.chaseCamera.position.set(t.x+e.x,10,t.y+e.y),this.chaseCamera.lookAt(t.x,0,t.y)}_resetTopDownCamera(){this.topDownCamera.position.setY(50)}_updateCameraAspects(t){this.freeCamera.aspect=t,this.freeCamera.updateProjectionMatrix(),this.chaseCamera.aspect=t,this.chaseCamera.updateProjectionMatrix()}enableEditor(){this.editor.enabled=!0,this.previousCamera=this.camera,this.camera=this.editorCamera,this.editorCameraControls.enabled=!0,this.chaseCameraControls.enabled=!1,this.topDownControls.enabled=!1,this.freeCameraControls.enabled=!1,this.scene.fog=null,this.plannedPathGroup&&(this.plannedPathGroup.visible=!1),this.simModeBoxes.forEach(t=>t.classList.add("is-hidden")),this.editModeBoxes.forEach(t=>t.classList.remove("is-hidden"))}finalizeEditor(t=!0){this.editor.enabled=!1,this.editorCameraControls.enabled=!1,this.scene.fog=this.sceneFog,this.simModeBoxes.forEach(t=>t.classList.remove("is-hidden")),this.editModeBoxes.forEach(t=>t.classList.add("is-hidden"));const e=this.editor.lanePath.centerline,n=e[0].clone(),i=e[1].clone().sub(e[0]),a=Math.atan2(i.y,i.x);this.car.setPose(n.x,n.y,a),this.autonomousCarController=null,this.plannerRunning||(this.plannerReady=!0,this.plannerRunning=!0),this.plannerReset=!0,this.simulatedTime=0,t&&(this.camera=this.previousCamera,this.previousCamera==this.chaseCamera?this.chaseCameraControls.enabled=!0:this.previousCamera==this.topDownCamera?this.topDownControls.enabled=!0:this.previousCamera==this.freeCamera?this.freeCameraControls.enabled=!0:this.changeCamera("chase")),this._resetFreeCamera(),this._resetChaseCamera(),this._resetTopDownCamera()}restartScenario(){this.editor.enabled||this.finalizeEditor(!1)}enableManualMode(){this.manualModeButton.classList.remove("is-outlined"),this.manualModeButton.classList.add("is-selected"),this.autonomousModeButton.classList.add("is-outlined"),this.autonomousModeButton.classList.remove("is-selected"),this.carControllerMode="manual"}enableAutonomousMode(){this.autonomousModeButton.classList.remove("is-outlined"),this.autonomousModeButton.classList.add("is-selected"),this.manualModeButton.classList.add("is-outlined"),this.manualModeButton.classList.remove("is-selected"),this.carControllerMode="autonomous"}changeCamera(t){if(!this.editor.enabled){switch(t){case"free":this.chaseCameraControls.enabled=!1,this.topDownControls.enabled=!1,this.freeCameraControls.enabled=!0,this.camera==this.freeCamera?this._resetFreeCamera():this.camera=this.freeCamera;break;case"chase":this.freeCameraControls.enabled=!1,this.topDownControls.enabled=!1,this.chaseCameraControls.enabled=!0,this.camera==this.chaseCamera?this._resetChaseCamera():this.camera=this.chaseCamera;break;case"topDown":this.freeCameraControls.enabled=!1,this.chaseCameraControls.enabled=!1,this.topDownControls.enabled=!0,this.camera==this.topDownCamera?this._resetTopDownCamera():this.camera=this.topDownCamera;break;default:return void console.log(`Unknown camera mode: ${t}`)}for(const e in this.cameraButtons){const n=this.cameraButtons[e].classList;e==t?(n.remove("is-outlined"),n.add("is-selected")):(n.add("is-outlined"),n.remove("is-selected"))}}}startPlanner(t,e){this.plannerReady=!1,this.lastPlanTime=performance.now();let n=t;!this.plannerReset&&this.autonomousCarController&&"autonomous"==this.carControllerMode&&(n=this.autonomousCarController.predictPoseAfterTime(t,this.averagePlanTime.average*this.fps*L));const i=this.plannerReset;this.plannerReset=!1,this.lastPlanParams={config:this.pathPlannerConfigEditor.config,vehiclePose:n,vehicleStation:e,lanePath:this.editor.lanePath,obstacles:this.obstacles,reset:i},this.pathPlannerWorker.postMessage(this.lastPlanParams)}receivePlannedPath(t){if(this.editor.enabled)return;const{fromVehicleSegment:e,fromVehicleParams:n,vehiclePose:i,vehicleStation:a,latticeStartStation:s}=t.data;let{path:l}=t.data;if(this.averagePlanTime.addSample((performance.now()-this.lastPlanTime)/1e3),this.plannerReady=!0,null===l||this.plannerReset)return;(l=e.concat(l)).forEach(t=>Object.setPrototypeOf(t.pos,THREE.Vector2.prototype));const c=new o(l);this.autonomousCarController?this.autonomousCarController.replacePath(c):this.autonomousCarController=new r(c,this.car),this.scene.remove(this.plannedPathGroup),this.plannedPathGroup=new THREE.Group,this.scene.add(this.plannedPathGroup);const h=new THREE.CircleGeometry(.15,32),d=new THREE.MeshBasicMaterial({color:65408,depthTest:!1,transparent:!0,opacity:.7});new P(this.editor.lanePath,s).lattice.forEach(t=>{t.forEach(t=>{const e=new THREE.Mesh(h,d);e.position.set(t.pos.x,0,t.pos.y),e.rotation.x=-Math.PI/2,this.plannedPathGroup.add(e)})});const u=new THREE.Geometry;u.setFromPoints(l.map(t=>new THREE.Vector3(t.pos.x,0,t.pos.y)));const p=new MeshLine;p.setGeometry(u);const m=new THREE.Mesh(p.geometry,new MeshLineMaterial({color:new THREE.Color(16728319),lineWidth:.15,depthTest:!1,transparent:!0,opacity:.5,resolution:new THREE.Vector2(this.renderer.domElement.clientWidth,this.renderer.domElement.clientHeight)}));m.renderOrder=1,this.plannedPathGroup.add(m);const f=new THREE.LineBasicMaterial({color:65280,depthTest:!1}),g=new THREE.Geometry;g.vertices.push(...c.poses.map(t=>new THREE.Vector3(t.frontPos.x,0,t.frontPos.y))),this.plannedPathGroup.add(new THREE.Line(g,f))}}([33.5239,-111.908756],document.getElementById("container"))})}]);
//# sourceMappingURL=Dash.js.map